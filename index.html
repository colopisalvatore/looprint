<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="color-scheme" content="dark">
    <title>Looprint (Beta)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg: #0d1117;
            --card: #161b22;
            --accent: #2ea043;
            --accent-soft: #238636;
            --text: #c9d1d9;
            --muted: #8b949e;
            --input: #21262d;
            --border: #30363d;
            --danger: #f85149;
            --warning: #d29922;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 20px;
            display: flex; justify-content: center;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #161b22 0, #0d1117 45%, #02040a 100%);
            color: var(--text);
        }
        .container {
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(8px);
            padding: 24px 24px 20px;
            border-radius: 16px;
            border: 1px solid var(--border);
            max-width: 900px; width: 100%;
            box-shadow: 0 18px 45px rgba(0,0,0,0.55);
        }
        .header-row {
            display: flex; justify-content: space-between; gap: 16px;
            align-items: flex-start; padding-bottom: 14px;
            border-bottom: 1px solid var(--border); margin-bottom: 18px;
        }
        .header-logo {
            height: 48px; width: auto; margin-right: 16px;
            object-fit: contain;
        }
        @media (max-width: 640px) {
            .header-logo { height: 40px; margin-right: 12px; }
        }
        .language-selector {
            display: flex; align-items: center; gap: 8px;
            position: relative;
            z-index: 1000;
        }
        .language-selector-label {
            font-size: 0.75rem; color: var(--muted);
            cursor: pointer;
        }
        #google_translate_element {
            display: inline-block !important;
            position: relative;
            z-index: 1001;
            pointer-events: auto;
            min-width: 140px;
            visibility: visible !important;
            opacity: 1 !important;
        }
        /* Style Google Translate dropdown */
        .goog-te-banner-frame {
            display: none !important;
        }
        .goog-te-menu-value {
            color: var(--text) !important;
            font-weight: 500 !important;
        }
        .goog-te-menu-value span {
            color: var(--text) !important;
        }
        .goog-te-gadget {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif !important;
            font-size: 0.9rem !important;
            display: inline-block !important;
            visibility: visible !important;
        }
        .goog-te-gadget-simple {
            background-color: var(--input) !important;
            border: 1px solid var(--border) !important;
            border-radius: 8px !important;
            padding: 6px 12px !important;
            color: var(--text) !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            transition: all 0.2s ease !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }
        .goog-te-gadget-simple:hover {
            background-color: var(--card) !important;
            border-color: var(--accent) !important;
            box-shadow: 0 4px 8px rgba(46, 160, 67, 0.2) !important;
        }
        .goog-te-gadget-simple .goog-te-menu-value {
            color: var(--text) !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            font-weight: 500 !important;
        }
        .goog-te-gadget-simple .goog-te-menu-value span {
            color: var(--text) !important;
            pointer-events: auto !important;
        }
        /* Force text color - target all possible nested elements with direct color value */
        .goog-te-gadget-simple .goog-te-menu-value,
        .goog-te-gadget-simple .goog-te-menu-value span,
        .goog-te-gadget-simple .goog-te-menu-value span[style],
        .goog-te-menu-value,
        .goog-te-menu-value span,
        .goog-te-menu-value span[style] {
            color: #c9d1d9 !important; /* Direct light gray color for maximum compatibility with inline styles */
        }
        .goog-te-gadget-icon {
            display: none !important;
        }
        .goog-te-menu-frame {
            z-index: 1002 !important;
            border-radius: 8px !important;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3) !important;
            background-color: #161b22 !important;
        }
        .goog-te-menu2 {
            background-color: #161b22 !important;
            border: 1px solid #30363d !important;
            border-radius: 8px !important;
        }
        .goog-te-menu2-item {
            color: #c9d1d9 !important;
            padding: 8px 12px !important;
            background-color: #161b22 !important;
        }
        .goog-te-menu2-item:hover {
            background-color: #21262d !important;
        }
        .goog-te-menu2-item-selected {
            background-color: #21262d !important;
        }
        .goog-te-menu2-item div {
            color: #c9d1d9 !important;
            background-color: transparent !important;
        }
        .goog-te-menu2-item div div {
            color: #c9d1d9 !important;
            background-color: transparent !important;
        }
        .goog-te-menu2-item td {
            background-color: #161b22 !important;
        }
        .goog-te-menu2-item:hover td {
            background-color: #21262d !important;
        }
        .goog-te-menu-frame iframe {
            background-color: #161b22 !important;
        }
        body {
            top: 0 !important;
        }
        h1 { margin: 0 0 6px; font-size: 1.7rem; color: var(--accent); letter-spacing: 0.02em; }
        .subtitle { margin: 0; color: var(--muted); font-size: 0.9rem; max-width: 520px; }
        .badge {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 3px 8px; border-radius: 999px;
            border: 1px solid var(--border); font-size: 0.7rem;
            color: var(--muted); margin-top: 4px;
        }
        label { display: block; font-size: 0.85rem; font-weight: 600; margin-bottom: 6px; }
        select, input[type="file"], input[type="number"] {
            width: 100%; padding: 9px 10px; border-radius: 8px;
            border: 1px solid var(--border); background: var(--input);
            color: var(--text); font-size: 0.9rem; margin: 0;
        }
        select:focus, input:focus {
            outline: 2px solid var(--accent-soft); outline-offset: 1px; border-color: var(--accent-soft);
        }
        .section { margin-top: 0; padding-top: 14px; border-top: 1px solid var(--border); }
        .section:first-of-type { border-top: none; }
        .section-title { 
            font-size: 1.15rem; 
            font-weight: 700; 
            margin-bottom: 16px; 
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .help-text { margin: 4px 0 0; font-size: 0.78rem; color: var(--muted); }
        .row { display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; }
        .col { flex: 1; min-width: 200px; display: flex; flex-direction: column; }
        .checkbox-container {
            margin-top: 10px; padding: 9px 10px; border-radius: 8px;
            border: 1px solid var(--border); background: var(--input);
            display: flex; align-items: center; gap: 8px; font-size: 0.83rem;
        }
        .checkbox-container input { 
            margin-top: 0; 
            flex-shrink: 0;
        }
        .checkbox-container label {
            margin: 0; 
            cursor: pointer;
            display: inline;
            line-height: 1.4;
        }
        .checkbox-container label span {
            display: inline;
        }
        
        /* Button Styles */
        .btn-row { display: flex; gap: 12px; margin-top: 18px; }
        button { font-family: inherit; }
        button.primary {
            flex: 2; padding: 11px 12px;
            border-radius: 999px; border: none; font-size: 1rem;
            font-weight: bold; cursor: pointer;
            background: linear-gradient(135deg, var(--accent), var(--accent-soft));
            color: #06090f;
            box-shadow: 0 4px 6px rgba(46, 160, 67, 0.35);
            transition: all 0.2s ease;
        }
        button.primary:hover { filter: brightness(1.05); transform: translateY(-2px); box-shadow: 0 10px 20px rgba(46, 160, 67, 0.45); }
        button.primary:active { transform: translateY(0); }
        button.primary:disabled {
            background: var(--input); color: var(--muted);
            cursor: not-allowed; box-shadow: none; transform: none;
        }
        button.secondary {
            flex: 1; padding: 11px 12px;
            border-radius: 999px; border: 1px solid var(--border); 
            background: transparent; color: var(--muted);
            font-size: 0.9rem; font-weight: 600; cursor: pointer;
            transition: all 0.2s ease;
        }
        button.secondary:hover { border-color: var(--text); color: var(--text); }
        .btn-pill {
            width: auto; padding: 6px 10px; font-size: 0.8rem;
            border-radius: 999px; background: #111827;
            border: 1px solid var(--border); color: var(--text); cursor: pointer;
        }
        .btn-pill:hover { border-color: var(--accent); color: var(--accent); }
        
        .output-area {
            display: none; margin-top: 16px; padding: 12px 12px 10px;
            border-radius: 12px; border: 1px dashed var(--border);
            background: #05070d; font-size: 0.86rem;
        }
        .output-header { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .output-header-icon {
            width: 20px; height: 20px; border-radius: 999px;
            display: inline-flex; align-items: center; justify-content: center;
            background: rgba(46, 160, 67, 0.15); color: var(--accent); font-size: 0.9rem;
        }
        .output-header strong { color: var(--accent); }
        .stat-line {
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 0.78rem; color: var(--muted);
        }
        .stat-line span.value { color: var(--text); }
        .output-actions { margin-top: 10px; }
        
        /* Footer */
        .footer {
            margin-top: 18px; padding-top: 12px; border-top: 1px solid var(--border);
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between;
        }
        .footer-text { font-size: 0.75rem; color: var(--muted); max-width: 480px; }
        .footer-note {
            font-size: 0.72rem; color: var(--muted); text-align: right;
            display: flex; flex-direction: column; gap: 2px;
        }
        .footer-note span { color: var(--text); font-weight: 600; }
        #statusMessage { margin-top: 8px; font-size: 0.8rem; font-weight: 500; display: none; }
        
        /* Bed Preview & Selection */
        .bed-preview-wrapper {
            display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; margin-top: 16px; margin-bottom: 10px;
        }
        .bed-preview {
            position: relative; width: 100%; max-width: 260px; height: 170px;
            border-radius: 10px; border: 1px solid var(--border);
            background-color: #111827;
            background-image: linear-gradient(#1f2933 1px, transparent 1px), linear-gradient(90deg, #1f2933 1px, transparent 1px);
            background-size: 20px 20px; overflow: hidden;
            transition: opacity 0.3s ease;
        }
        .bed-preview-p1 {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }
        .bed-preview-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 10px;
        }
        /* L√ÖST TILSTAND */
        .bed-preview.locked {
            pointer-events: none;
            opacity: 0.6; 
            cursor: default !important;
        }
        .bed-label {
            position: absolute; font-size: 0.7rem; font-weight: 600;
            color: #6b7280; text-transform: uppercase; pointer-events: none;
        }
        .bed-label-front { bottom: 4px; left: 50%; transform: translateX(-50%); }
        .bed-label-back { top: 4px; left: 50%; transform: translateX(-50%); }
        .bed-label-left { top: 50%; left: 4px; transform: translateY(-50%) rotate(-90deg); }
        .bed-label-right { top: 50%; right: 4px; transform: translateY(-50%) rotate(90deg); }
        
        .bed-zone {
            position: absolute; bottom: 18px; height: 40px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center;
            justify-content: center; font-size: 0.7rem; font-weight: 600; color: #e5e7eb;
            cursor: pointer;
            /* ENSARTET BREDDE */
            width: calc(33.333% - 4px);
        }
        /* ENSARTET PLACERING */
        .bed-zone.left { left: 4px; background: rgba(249,115,22,0.20); }
        .bed-zone.center { left: 50%; transform: translateX(-50%); background: rgba(59,130,246,0.20); }
        .bed-zone.right { right: 4px; background: rgba(16,185,129,0.20); }

        .bed-zone.active {
             border: 2px solid var(--accent); 
             box-shadow: 0 0 8px var(--accent);
             opacity: 1 !important;
        }
        .bed-preview-text { flex: 1; min-width: 200px; font-size: 0.78rem; color: var(--muted); }
        .bed-offset-line { margin-top: 6px; font-size: 0.78rem; }
        .offset-warning { margin-top: 4px; font-size: 0.75rem; color: var(--danger); }
        .direction-warning {
            margin-top: 8px; padding: 8px 10px; border-radius: 6px;
            background: rgba(248, 81, 73, 0.1); border: 1px solid var(--danger);
            font-size: 0.8rem; color: var(--danger); display: none;
        }
        .direction-info {
            margin-top: 8px; padding: 8px 10px; border-radius: 6px;
            background: rgba(46, 160, 67, 0.1); border: 1px solid var(--accent);
            font-size: 0.8rem; color: var(--accent); display: none;
        }
        
        /* Selection Toggle (Status Display) */
        .push-selector {
            display: flex; gap: 10px; margin: 15px 0; padding: 10px;
            background: var(--input); border-radius: 10px; border: 1px solid var(--border);
            pointer-events: none;
        }
        .push-option {
            flex: 1; text-align: center; 
            padding: 8px 5px; border-radius: 6px;
            font-size: 0.85rem; font-weight: 600; color: var(--muted);
            border: 1px solid transparent; transition: all 0.2s;
        }
        .push-option.active {
            background: rgba(46, 160, 67, 0.2); color: var(--accent);
            border-color: var(--accent);
        }
        .push-selector-label {
            display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
            font-size: 0.85rem; font-weight: 600;
        }
        
        /* Code Sections Logic */
        .code-section {
            margin-top: 12px; padding: 10px 10px 12px;
            border-radius: 10px; border: 1px solid var(--border); background: #05070d;
            transition: all 0.3s ease;
        }
        .code-section.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .code-section.active { border-color: var(--accent); box-shadow: 0 0 10px rgba(46, 160, 67, 0.1); }
        .code-header { display: flex; flex-direction: column; gap: 4px; margin-bottom: 6px; }
        .code-title { font-size: 0.9rem; font-weight: 600; }
        .code-desc { font-size: 0.78rem; color: var(--muted); margin: 0; }
        .code-actions { margin: 4px 0 6px; display: flex; justify-content: flex-end; gap: 8px; }
        .code-textarea {
            width: 100%; min-height: 220px; max-height: 400px; resize: vertical;
            padding: 8px; border-radius: 8px; border: 1px solid var(--border);
            background: #000; color: var(--text);
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 0.75rem; line-height: 1.3;
        }
        
        /* Debug status */
        #placementDebug {
            margin-top: 4px; padding-top: 8px; 
            border-top: 1px dashed var(--border);
        }
        #placementDebug p:first-child { margin-top: 0; }
        
        /* Drag & Drop */
        .file-upload-area {
            position: relative;
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 32px 20px;
            text-align: center;
            transition: all 0.3s ease;
            background: var(--input);
        }
        .file-upload-area:hover {
            border-color: var(--accent);
            background: rgba(46, 160, 67, 0.05);
        }
        .file-upload-area.drag-over {
            border-color: var(--accent);
            background: rgba(46, 160, 67, 0.15);
            border-style: solid;
        }
        .file-upload-area.drag-over::before {
            content: "üìÅ Drop file here";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.3rem;
            color: var(--accent);
            font-weight: 600;
            pointer-events: none;
            z-index: 10;
        }
        .file-upload-area label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(46, 160, 67, 0.4);
        }
        .file-size-estimate {
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--muted);
            font-weight: 500;
        }
        .file-size-estimate strong {
            color: var(--accent);
        }
        
        /* Advanced Settings Toggle */
        .advanced-toggle-container {
            margin-top: 10px;
            padding: 10px;
            background: var(--input);
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .advanced-toggle-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0;
        }
        .advanced-toggle-container input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }
        #endCodeSection {
            display: none;
            margin-top: 0;
        }
        #endCodeSection.advanced-visible {
            display: block;
        }
        
        /* Loading indicator */
        .loading-container {
            display: none; margin-top: 10px;
        }
        .loading-container.active {
            display: block;
        }
        .progress-bar-container {
            background: var(--input); border-radius: 8px; height: 8px; overflow: hidden;
            margin-bottom: 4px;
        }
        .progress-bar {
            background: var(--accent); height: 100%; width: 0%; 
            transition: width 0.3s; border-radius: 8px;
        }
        .progress-text {
            font-size: 0.75rem; color: var(--muted); margin-top: 4px;
        }
        
        /* Bed preview locked indicator */
        .bed-preview.locked::after {
            content: "üîí Locked after file upload";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 10;
            border: 1px solid var(--border);
        }

        /* Instructions Modal */
        .instructions-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .instructions-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .instructions-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 24px;
            margin-top: 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
        }
        .instructions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .instructions-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--accent);
        }
        .instructions-close {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .instructions-close:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .instructions-section {
            margin-bottom: 32px;
        }
        .instructions-section h3 {
            color: var(--accent);
            font-size: 1.25rem;
            margin: 0 0 16px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
            font-weight: 700;
        }
        .instructions-section h4 {
            color: var(--text);
            font-size: 1.1rem;
            margin: 20px 0 12px 0;
            font-weight: 600;
        }
        .instructions-section p {
            margin: 0 0 14px 0;
            line-height: 1.7;
            color: var(--text);
        }
        .instructions-section ul, .instructions-section ol {
            margin: 14px 0;
            padding-left: 28px;
            color: var(--text);
        }
        .instructions-section li {
            margin-bottom: 10px;
            line-height: 1.7;
        }
        .instructions-section ol > li {
            margin-bottom: 16px;
        }
        .instructions-section ol > li > ul {
            margin-top: 8px;
        }
        .instructions-section strong {
            color: var(--text);
            font-weight: 600;
        }
        .instructions-section strong.highlight {
            color: var(--accent);
        }
        .instructions-section code {
            background: var(--input);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        /* Quick Start Box */
        .quick-start-box {
            background: linear-gradient(135deg, var(--accent)15, var(--card));
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }
        .quick-start-box h3 {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }
        .quick-start-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        .quick-start-step {
            background: var(--card);
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid var(--accent);
        }
        .quick-start-step strong {
            color: var(--accent);
            display: block;
            margin-bottom: 4px;
        }
        
        /* Accordion styling for printer-specific sections */
        .printer-accordion {
            margin-bottom: 12px;
            border: 2px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            background: var(--card);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s;
        }
        .printer-accordion:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .printer-accordion-header {
            padding: 16px 20px;
            background: var(--input);
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            position: relative;
        }
        .printer-accordion-header::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .printer-accordion-header:hover {
            background: var(--hover);
        }
        .printer-accordion-header:hover::before,
        .printer-accordion-header.active::before {
            opacity: 1;
        }
        .printer-accordion-header.active {
            background: var(--hover);
        }
        .printer-accordion-header h4 {
            margin: 0;
            color: var(--accent);
            font-size: 1.05rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .printer-accordion-icon {
            font-size: 1rem;
            color: var(--accent);
            transition: transform 0.3s ease;
            flex-shrink: 0;
        }
        .printer-accordion-header.active .printer-accordion-icon {
            transform: rotate(180deg);
        }
        .printer-accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--card);
        }
        .printer-accordion-content.active {
            max-height: 5000px;
            transition: max-height 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .printer-accordion-inner {
            padding: 20px;
            border-top: 1px solid var(--border);
        }
        .printer-accordion-inner p:first-child {
            margin-top: 0;
        }
        .printer-accordion-inner p:last-child {
            margin-bottom: 0;
        }
        
        /* Accordion controls */
        .accordion-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        .accordion-control-btn {
            background: var(--input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .accordion-control-btn:hover {
            background: var(--hover);
            border-color: var(--accent);
            color: var(--accent);
        }
            font-family: ui-monospace, monospace;
            font-size: 0.9em;
            color: var(--accent);
        }
        .instructions-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--accent), var(--accent-soft));
            color: #06090f;
            border-radius: 8px;
            border: none;
            text-decoration: none;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(46, 160, 67, 0.35);
        }
        .instructions-btn:hover {
            filter: brightness(1.05);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(46, 160, 67, 0.45);
        }
        .instructions-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(46, 160, 67, 0.35);
        }

        /* --- DONATION BUTTON STYLES --- */
        .donation-container {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .donate-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--accent), var(--accent-soft));
            color: #06090f;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(46, 160, 67, 0.35);
        }

        .donate-btn:hover {
            filter: brightness(1.05);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(46, 160, 67, 0.45);
        }

        @media (max-width: 640px) {
            .header-row { flex-direction: column; align-items: flex-start; }
            .header-row > div:first-child { flex-direction: column; align-items: flex-start; gap: 12px; }
            .instructions-content {
                padding: 16px;
                margin-top: 20px;
                margin-bottom: 20px;
            }
            .lang-block { width: 100%; text-align: left; }
            .footer { flex-direction: column; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header-row">
        <div style="flex: 1; display: flex; align-items: center; gap: 16px;">
            <img src="logo.png" alt="Looprint Logo" class="header-logo">
            <div style="flex: 1;">
                <h1 data-lang="title">Looprint (Beta)</h1>
                <p class="subtitle" data-lang="subtitle">
                    Automated multi-loop G-code builder for Bambu Lab P1/P1S, X1/X1C, A1, and A1 Mini. Supports G-code and 3MF files.
                </p>
            </div>
        </div>
        <div style="display: flex; align-items: center; gap: 12px;">
            <div class="language-selector">
                <div id="google_translate_element"></div>
            </div>
            <button class="instructions-btn" onclick="openInstructions()" title="View instructions">
                üìñ Instructions
            </button>
        </div>
    </div>
    
    <!-- Quick Start Guide -->
    <div class="quick-start-box" style="margin-bottom: 24px;">
        <h3 style="margin-top: 0;">üöÄ Quick Start</h3>
        <p style="margin-bottom: 16px;">Get started in 3 simple steps:</p>
        <div class="quick-start-steps">
            <div class="quick-start-step">
                <strong>1. Upload File</strong>
                <span style="font-size: 0.9rem;">Upload your sliced G-code or 3MF file</span>
            </div>
            <div class="quick-start-step">
                <strong>2. Configure</strong>
                <span style="font-size: 0.9rem;">Set number of loops and confirm safety settings</span>
            </div>
            <div class="quick-start-step">
                <strong>3. Generate</strong>
                <span style="font-size: 0.9rem;">Click "Generate Loop File" and download</span>
            </div>
        </div>
        <p style="margin-top: 16px; margin-bottom: 0; font-size: 0.9rem; color: var(--muted);">
            <strong>‚ö†Ô∏è Beta Notice:</strong> Looprint is still in beta. Not all features have been tested on hardware. Do not leave your printer unattended ‚Äî always stay nearby and monitor the process during automated looping.
        </p>
    </div>

    <div class="section" style="background: var(--input); padding: 16px; border-radius: 10px; border-left: 4px solid var(--accent);"> 
        <p class="help-text" style="margin: 0; font-size: 0.9rem;" id="factorianLinkFooter">
            <strong>üí° Based on <a href="https://factoriandesigns.com/" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: none;">Factorian Designs</a> G-code templates.</strong> I recommend watching his video: <a href="https://factoriandesigns.com/print-automation-bambu-lab-a1-a1-mini" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: none;">A1/A1 Mini</a> or <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: none;">P1/P1S/X1/X1C</a>.
        </p>
    </div>

    <!-- Export Instructions from Bambu Studio -->
    <div class="section">
        <div class="section-title">üì§ How to Export from Bambu Studio</div>
        <p class="help-text" style="margin-bottom: 16px;">Follow these steps to export your file from Bambu Studio:</p>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">
            <!-- G-code Export -->
            <div style="background: var(--input); border: 2px solid var(--border); border-radius: 10px; padding: 20px; border-left: 4px solid var(--accent);">
                <h4 style="margin: 0 0 12px 0; color: var(--accent); font-size: 1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    üìÑ G-code Files
                </h4>
                <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                    <li style="margin-bottom: 8px;">Slice your model in Bambu Studio</li>
                    <li style="margin-bottom: 8px;">Click <strong>"File"</strong> in the menu bar</li>
                    <li style="margin-bottom: 8px;">Select <strong>"Export"</strong> ‚Üí <strong>"Export G-Code"</strong></li>
                    <li style="margin-bottom: 0;">Upload the exported G-code file to Looprint</li>
                </ol>
                <p style="margin-top: 12px; margin-bottom: 0; font-size: 0.85rem; color: var(--muted); padding: 10px; background: var(--card); border-radius: 6px;">
                    <strong>Note:</strong> G-code files must be printed from SD card (required)
                </p>
            </div>
            
            <!-- 3MF Export -->
            <div style="background: var(--input); border: 2px solid var(--border); border-radius: 10px; padding: 20px; border-left: 4px solid var(--accent);">
                <h4 style="margin: 0 0 12px 0; color: var(--accent); font-size: 1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    üì¶ 3MF Files
                </h4>
                <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
                    <li style="margin-bottom: 8px;">Slice your model in Bambu Studio</li>
                    <li style="margin-bottom: 8px;">Click the <strong>dropdown</strong> where you normally click "Print Plate"</li>
                    <li style="margin-bottom: 8px;">Select <strong>"Export plate sliced file"</strong></li>
                    <li style="margin-bottom: 0;">Upload the exported 3MF file to Looprint</li>
                </ol>
                <p style="margin-top: 12px; margin-bottom: 0; font-size: 0.85rem; color: var(--muted); padding: 10px; background: var(--card); border-radius: 6px;">
                    <strong>Note:</strong> 3MF files can be sent directly to printer from Bambu Studio after generating
                </p>
            </div>
        </div>
    </div>

    <div class="section">
        <div class="section-title" data-lang="step1Title">üìÅ 1. Upload File</div>
        <div class="file-upload-area" id="fileUploadArea">
            <input type="file" id="fileInput" accept=".gcode,.gco,.g,.txt,.3mf" onchange="validateFileImmediate()" style="display: none;">
            <label for="fileInput" style="display: inline-block; padding: 12px 24px; background: var(--accent); color: #06090f; border-radius: 8px; cursor: pointer; font-weight: 600; margin-bottom: 10px; transition: all 0.2s; box-shadow: 0 2px 4px rgba(46, 160, 67, 0.3);">
                üìÅ Browse Files
            </label>
            <p style="margin: 10px 0 0; font-size: 0.9rem; color: var(--muted);">or drag and drop your G-code or 3MF file here</p>
        </div>
        <p id="fileSizeEstimate" class="file-size-estimate" style="display:none;"></p>
        <p id="fileValidationStatus" style="display:none; font-size:0.85rem; margin-top:12px; font-weight:600;"></p>
    </div>

    <div class="section">
        <div class="section-title" data-lang="step2Title">‚öôÔ∏è 2. Loop Configuration</div>
        <div class="row">
            <div class="col">
                <label for="loopCount" data-lang="loopsLabel">Number of loops</label>
                <input type="number" id="loopCount" value="5" min="1" step="1" onchange="saveSettings()">
            </div>
            <div class="col">
                <label for="printerModel">Printer Model</label>
                <select id="printerModel" onchange="handlePrinterModelChange()">
                    <option value="">Select printer model...</option>
                    <option value="P1">P1 / P1S</option>
                    <option value="A1">A1</option>
                    <option value="A1Mini">A1 Mini</option>
                    <option value="x1">X1 / X1C</option>
                </select>
                <small id="autoDetectedPrinterNote" style="display: none; color: var(--accent); margin-top: 6px; font-size: 0.75rem; font-weight: 600;">
                    ‚úì Auto-detected from 3MF file and locked
                </small>
            </div>
        </div>

        <div style="background: var(--input); padding: 16px; border-radius: 10px; border-left: 4px solid var(--accent); margin-top: 16px;">
            <div class="checkbox-container">
                <input type="checkbox" id="skirtConfirmed">
                <label for="skirtConfirmed">
                    <span data-lang="safetyText" style="font-weight: 600;">I confirm this file was sliced with Brim enabled.</span>
                </label>
            </div>
            <p class="help-text" style="margin-top: 8px; margin-left: 28px; margin-bottom: 0; font-size: 0.85rem; color: var(--muted);">
                This replaces the standard purge line behavior, ensuring a clean and consistent first layer.
            </p>
        </div>
        
        <div class="checkbox-container" id="purgeContainer" style="display: none; margin-top: 16px;">
            <input type="checkbox" id="purgeEnabled" checked>
            <label for="purgeEnabled">
                <span>Enable Start Line Purge (P1/P1S/X1/X1C)</span>
            </label>
            <p class="help-text" style="margin-top: 4px; margin-left: 28px; font-size: 0.85rem; color: var(--muted);">
                Filament flush sequence in start code (extrudes 50mm at 250¬∞C to clean nozzle). Useful when switching materials or after pause. Default: Enabled. Disable for faster start when using same filament.
            </p>
        </div>
        
        <div class="advanced-toggle-container" style="margin-top: 16px;">
            <label for="showAdvancedSettings">
                <input type="checkbox" id="showAdvancedSettings" onchange="toggleAdvancedSettings()">
                <span style="font-weight: 600;">‚öôÔ∏è Show Advanced Settings (Push-off Configuration)</span>
            </label>
        </div>
    </div>

    <div class="bed-preview-wrapper">
        <div class="bed-preview" id="bedPreviewContainer">
            <!-- P1/P1S/X1/X1C Mode: CSS-based zones -->
            <div class="bed-preview-p1" id="bedPreviewP1">
                <div class="bed-label bed-label-front" data-lang="bedPreviewFront">FRONT</div>
                <div class="bed-label bed-label-back" data-lang="bedPreviewBack">BACK</div>
                <div class="bed-label bed-label-left" data-lang="bedPreviewLeft">LEFT</div>
                <div class="bed-label bed-label-right" data-lang="bedPreviewRight">RIGHT</div>
                <div class="bed-zone center" id="zone-center" onclick="selectDirection('center')"><span data-lang="bedZoneCenter">Center</span></div>
                <div class="bed-zone right" id="zone-right" onclick="selectDirection('right')"><span data-lang="bedZoneRight">Right</span></div>
                <div class="bed-zone left" id="zone-left" onclick="selectDirection('left')"><span data-lang="bedZoneLeft">Left</span></div>
            </div>
            <!-- A1 Mode: Canvas-based visualization -->
            <canvas id="bedPreviewCanvas" class="bed-preview-canvas" style="display: none;"></canvas>
        </div>
        <div class="bed-preview-text">
            <strong data-lang="bedPreviewTitle">Bed Preview & Model Placement</strong>
            <p class="help-text" id="bedPreviewModeText" data-lang="bedPreviewText">
                The zone with the <strong style="color: var(--accent);">green border</strong> is the selected push direction.
                <br><span style="font-size: 0.85em;">In advanced mode, you can click any zone to change it after file upload.</span>
            </p>
            <p class="bed-offset-line">
                <span data-lang="bedPreviewOffsetLabel">Z push offset:</span>
                <strong><span id="bedOffsetDisplay">30</span> mm</strong>
                <span data-lang="bedPreviewOffsetSuffix">below top of print</span>
            </p>
            <p id="sweepIndicator" class="bed-offset-line" style="display: none; color: var(--accent); margin-top: 8px;">
                <span style="font-weight: 600;">üßπ Full Bed Sweep:</span>
                <strong><span id="sweepStatusText">Enabled</span></strong>
                <span id="sweepModeText" style="font-size: 0.85em; color: var(--muted);">(7 passes after each loop)</span>
            </p>
            <p class="offset-warning" data-lang="zOffsetWarning">‚ö†Ô∏è Advanced: Incorrect values can cause collisions.</p>
            <div id="directionWarning" class="direction-warning" style="display: none;">
                ‚ö†Ô∏è <strong>Warning:</strong> You have changed the push direction from the automatically detected direction. Make sure this matches your model placement.
            </div>
            <div id="directionInfo" class="direction-info" style="display: none;">
                ‚ÑπÔ∏è <strong>Auto-detected:</strong> Push direction was automatically set based on model placement.
            </div>
        </div>
    </div>

    <div class="btn-row" style="margin-top: 24px; margin-bottom: 24px; gap: 12px; flex-wrap: wrap;">
        <button class="primary" id="generateBtn" onclick="processFiles()" data-lang="generateBtn" style="flex: 1; min-width: 200px;">
            ‚ú® Generate Loop File
        </button>
        <button class="secondary" id="generateTestBtn" onclick="showTestFileInfo()" data-lang="generateTestBtn" style="display:none;" title="Generate a test file with only push-off sequence for testing">
            üß™ Generate Test File
        </button>
        <button class="secondary" id="generateSweepTestBtn" onclick="generateSweepTestFile()" style="display:none;" title="Generate a test file with only sweep sequence for testing">
            üßπ Generate Sweep Test File
        </button>
        <button class="secondary" onclick="resetDefaults()" data-lang="resetBtn">
            üîÑ Reset to Defaults
        </button>
    </div>

    <p id="statusMessage"></p>

    <div class="section" id="endCodeSection">
        <div class="section-title" data-lang="endSectionTitle">üîß 3. Push-off Configuration (Advanced)</div>
        <p class="help-text" data-lang="endSectionHelp">
            Push direction is automatically detected from your file. <strong>You can click the zones in the bed preview above to change it manually.</strong>
            <br><span style="font-size: 0.85em; color: var(--muted);">Note: In simple mode, push direction is locked to the auto-detected value. In advanced mode, you can change it but will see a warning if it differs from the auto-detected direction.</span>
        </p>
        
        
        <div class="row" style="margin-top: 15px;">
            <div class="col">
                <label for="cooldownTempInput" data-lang="cooldownTempLabel">Target Bed Temp (¬∞C)</label>
                <input type="number" id="cooldownTempInput" value="18" min="15" max="90" step="1" oninput="saveSettings(); checkCooldownWarning(); updateEndCodeTextareas();">
                <p id="cooldownWarningMessage" style="color:var(--danger); margin-top: 5px; font-size: 0.75rem; display: none; font-weight: 600;"></p>
                <p class="help-text" data-lang="cooldownHelp">Default 18¬∞C (Approx. 23¬∞C on the plate). Wait max 60 min.</p>
            </div>
            
            <div class="col">
                <label for="zOffsetInput" data-lang="zOffsetLabel">Z Push Offset (mm)</label>
                <input type="number" id="zOffsetInput" value="30" min="5" max="120" step="1" oninput="saveSettings(); applyOffset();">
                <p id="zOffsetStatus" style="font-size: 0.75rem; margin-top: 4px; display: none; font-weight: 600;"></p>
                <p class="help-text" data-lang="zOffsetHelp">Default 30mm below top (P1/X1). A1 Factorian logic uses 40mm in the automated calculation.</p>
            </div>
        </div>
        
        <div class="row" style="margin-top: 15px;">
            <div class="col">
                <label for="pushLaneOffsetInput">Push Lane Offset (mm)</label>
                <input type="number" id="pushLaneOffsetInput" value="30" min="10" max="60" step="1" oninput="saveSettings(); updatePushLaneOffset();">
                <p id="pushLaneOffsetStatus" style="font-size: 0.75rem; margin-top: 4px; display: none; font-weight: 600;"></p>
                <p id="pushLaneOffsetMaxInfo" style="font-size: 0.75rem; margin-top: 4px; display: none; color: var(--muted);"></p>
                <p class="help-text">Distance from model center for left/right push lanes. Default 30mm. Auto-adjusted if too large for model placement.</p>
            </div>
            <div class="col">
                <label for="pushSpeedInput">Push-off Speed (mm/min)</label>
                <input type="number" id="pushSpeedInput" value="300" min="100" max="1000" step="50" oninput="saveSettings(); updateEndCodeTextareas();">
                <p class="help-text">Speed of the push-off motion. Default 300mm/min. Lower = slower, safer for delicate prints.</p>
            </div>
        </div>

        <div class="setting-block" style="margin-top: 20px;">
            <div class="checkbox-container">
                <input type="checkbox" id="enableSweep" onchange="saveSettings(); toggleSweepSettings(); updateEndCodeTextareas();">
                <label for="enableSweep">
                    <span>Enable Full Bed Sweep</span>
                </label>
            </div>
            <p class="help-text" style="margin-top: 5px; margin-left: 24px;">Sweeps entire bed in 7 passes (safe one-way back-to-front pattern) after push-off to clear any debris. Returns in straight line before shifting to next pass. Default Z: 1mm (bed level), adjustable.</p>
            
            <div id="sweepSettings" style="margin-top: 15px; margin-left: 24px; display: none;">
                <div class="row" style="margin-top: 10px;">
                    <div class="col">
                        <label for="sweepSpeedInput">Sweep Speed (mm/min)</label>
                        <input type="number" id="sweepSpeedInput" value="300" min="100" max="1000" step="50" oninput="saveSettings(); updateEndCodeTextareas();">
                        <p class="help-text">Speed of the sweep motion. Default 300mm/min. Always runs 7 passes with automatic spacing.</p>
                    </div>
                    <div class="col">
                        <label for="sweepZInput">Sweep Z Height (mm)</label>
                        <input type="number" id="sweepZInput" value="1" min="0.5" max="50" step="0.5" oninput="saveSettings(); updateEndCodeTextareas();">
                        <p class="help-text">Z height for sweep (distance above bed). Default 1mm (bed level). Lower = closer to bed.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="setting-block" id="a1NegativeZContainer" style="margin-top: 20px; display: none;">
            <div class="checkbox-container">
                <input type="checkbox" id="enableA1NegativeZ" onchange="saveSettings(); updateEndCodeTextareas();">
                <label for="enableA1NegativeZ">
                    <span>Enable Negative Z Push-Off</span>
                </label>
            </div>
            <div style="margin-top: 10px; margin-left: 24px; padding: 10px; background: rgba(248, 81, 73, 0.1); border: 1px solid rgba(248, 81, 73, 0.3); border-radius: 6px;">
                <p style="margin: 0 0 8px 0; font-size: 0.78rem; color: var(--danger); font-weight: 600; line-height: 1.5;">
                    ‚ö†Ô∏è <strong>WARNING:</strong> This feature uses negative Z values (Z-17) when nozzle head is at X-48 (far left). Only use if you do NOT have a Z-axis stiffener mod installed.
                </p>
                <p style="margin: 0; font-size: 0.75rem; color: var(--muted); line-height: 1.5;">
                    Based on Factorian Designs custom end code logic. Use with caution!
                </p>
            </div>
            <p class="help-text" style="margin-top: 10px; margin-left: 24px; line-height: 1.5;">
                Adds an additional push-off sequence after standard push-off, using negative Z for low-height models. This is an advanced feature and should only be used when standard push-off is insufficient for very low parts.
            </p>
        </div>
        <div id="block-start" class="code-section" style="margin-top: 20px;">
            <div class="code-header">
                <div class="code-title">Start G-code</div>
                <p class="code-desc">Start code that will be inserted at the beginning of each loop. Variables are replaced with values from your file.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('startCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="startCode" class="code-textarea" readonly></textarea>
        </div>

        <div class="push-selector-label" style="margin-top: 20px;">
            <span>üìç</span><span data-lang="selectDirectionLabel">Selected Push Direction:</span>
        </div>
        <div class="push-selector">
            <div class="push-option" id="opt-left" data-lang="optLeft">Left</div>
            <div class="push-option active" id="opt-center" data-lang="optCenter">Center</div>
            <div class="push-option" id="opt-right" data-lang="optRight">Right</div>
        </div>

        <div id="block-left" class="code-section disabled">
            <div class="code-header">
                <div class="code-title" data-lang="endLeftTitle">Left Push End G-code</div>
                <p class="code-desc" data-lang="endLeftDesc">Pushes model from left zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endLeftCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endLeftCode" class="code-textarea" readonly></textarea>
        </div>

        <div id="block-center" class="code-section active">
            <div class="code-header">
                <div class="code-title" data-lang="endCenterTitle">Center Push End G-code</div>
                <p class="code-desc" data-lang="endCenterDesc">Pushes model from center zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endCenterCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endCenterCode" class="code-textarea" readonly></textarea>
        </div>
        
        <div id="block-right" class="code-section disabled">
            <div class="code-header">
                <div class="code-title" data-lang="endRightTitle">Right Push End G-code</div>
                <p class="code-desc" data-lang="endRightDesc">Pushes model from right zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endRightCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endRightCode" class="code-textarea" readonly></textarea>
        </div>
        
        <!-- A1 / A1 Mini End G-code Section (shown only when A1 or A1Mini is selected) -->
        <div id="block-a1" class="code-section" style="display: none; margin-top: 20px;">
            <div class="code-header">
                <div class="code-title">A1 / A1 Mini End G-code</div>
                <p class="code-desc">A1/A1 Mini-specific end code with Y-axis push-off and wiggle sweep. Z height calculated automatically using Factorian's 41mm rule.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endA1Code')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endA1Code" class="code-textarea" readonly></textarea>
        </div>

    </div>
    
    <div id="loadingContainer" class="loading-container">
        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>
        <p id="progressText" class="progress-text">Processing...</p>
    </div>

    <div id="output" class="output-area">
        <div class="output-header">
            <div class="output-header-icon">‚úÖ</div>
            <strong data-lang="outputReady">Loop File Ready</strong>
        </div>
        <p data-lang="outputDesc">Your file has been looped into a single file with push-off sequences between each loop.</p>
        <p class="stat-line"><span data-lang="statLabelSource">Source file:</span> <span class="value" id="statSourceName">‚Äì</span></p>
        <p class="stat-line"><span data-lang="statLabelLoops">Total loops:</span> <span class="value" id="statLoops">0</span></p>
        <p class="stat-line" id="pushDirectionStatLine" style="display:none;">
            <span data-lang="statLabelPushDirection">Push direction:</span> 
            <span class="value" id="statPushDirection">‚Äì</span>
        </p>
        <p class="stat-line" id="filamentStatLine" style="display:none;">
            <span data-lang="statLabelFilament">Est. Filament usage:</span> 
            <span class="value" id="statFilament">0</span> <span class="value" id="statFilamentUnit">g</span>
        </p>
        <p class="stat-line" id="timeStatLine" style="display:none;">
            <span data-lang="statLabelTime">Est. Total Print Time:</span> 
            <span class="value" id="statTime">0</span>
            <span style="font-size: 0.75rem; color: var(--muted); margin-left: 6px;" data-lang="timeCooldownNote">(estimate calculated with 60min cooldown per loop)</span>
        </p>
        <p class="stat-line" id="fileSizeStatLine" style="display:none;">
            <span data-lang="statLabelFileSize">Est. File size:</span> 
            <span class="value" id="statFileSize">0</span>
        </p>
        <p class="stat-line" id="bedTempStatLine" style="display:none;">
            <span data-lang="statLabelBedTemp">Target Bed Temp:</span> 
            <span class="value" id="statBedTemp">‚Äì</span>
        </p>
        <p class="stat-line" id="pushOffsetStatLine" style="display:none;">
            <span data-lang="statLabelPushOffset">Z Push Offset:</span> 
            <span class="value" id="statPushOffset">‚Äì</span>
        </p>

        <div class="output-actions">
            <button class="primary" style="font-size:0.9rem; padding-inline:18px;" onclick="downloadFile()" id="downloadBtn" data-lang="downloadBtn">Download Looped File</button>
        </div>
    </div>

    <div class="donation-container">
        <div style="text-align: center; margin-bottom: 12px;">
            <img src="logo.png" alt="Looprint Logo" style="height: 60px; width: auto; display: block; margin: 0 auto;">
        </div>
        <p class="help-text" style="margin-bottom: 8px; text-align: center;">Find this tool useful? Support the project and keep Looprint updated:</p>
        <div style="text-align: center;">
            <a href="https://buymeacoffee.com/nickiandersen" target="_blank" rel="noopener noreferrer" class="donate-btn">
                ‚òï Buy me a coffee
            </a>
        </div>
    </div>

    <div class="footer">
        <div class="footer-text" data-lang="footerText" style="display: none;">
            <strong>‚ö†Ô∏è Safety reminder:</strong> Always test with a simple model first. Print from SD card.
        </div>
        <div class="footer-note" data-lang="footerNote" id="factorianLinkFooterNote">
            Looprint loops your file and adds push-off sequences between loops. All print settings (temperatures, speeds, etc.) come from your original file. Start and end code are added automatically for all file types (G-code and 3MF).
        </div>
        <p style="width: 100%; text-align: right; font-size: 0.75rem; color: var(--text); margin: 0; padding: 5px 0 0; font-weight: 600;">Nicki Andersen</p>
        <p style="width: 100%; text-align: right; font-size: 0.75rem; color: var(--muted); margin: 0; padding: 2px 0 0;">(v3.0 Beta)</p>
    </div>
</div>

    <!-- Instructions Modal -->
    <div id="instructionsModal" class="instructions-modal" onclick="closeInstructionsOnBackdrop(event)">
        <div class="instructions-content" onclick="event.stopPropagation()">
            <div class="instructions-header">
                <h2>üìñ Looprint Instructions</h2>
                <button class="instructions-close" onclick="closeInstructions()">Close</button>
            </div>
            
            <div class="instructions-section">
                <h3>What is Looprint?</h3>
                <p>
                    Looprint is an automated multi-loop G-code builder for Bambu Lab P1/P1S, X1/X1C, A1, and A1 Mini printers. It takes your sliced G-code or 3MF file and automatically creates multiple print loops with push-off sequences between each loop, allowing you to print multiple copies of your model automatically.
                </p>
                <p id="factorianLinkInstructions">
                    <strong>Logic based on <a href="https://factoriandesigns.com/" target="_blank" rel="noopener noreferrer" style="color: var(--accent);">Factorian Designs</a> G-code templates.</strong> I recommend watching his videos: <a href="https://factoriandesigns.com/print-automation-bambu-lab-a1-a1-mini" target="_blank" rel="noopener noreferrer" style="color: var(--accent);" id="factorianLinkInstructionsAnchorA1">A1/A1 Mini</a> or <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent);" id="factorianLinkInstructionsAnchorP1X1">P1/P1S/X1/X1C</a>.
                </p>
            </div>

            <div class="instructions-section">
                <h3>Supported Printers</h3>
                <p>Looprint supports multiple Bambu Lab printer models. Click to expand details for your printer:</p>
                
                <div class="accordion-controls">
                    <button class="accordion-control-btn" onclick="expandAllAccordions()">Expand All</button>
                    <button class="accordion-control-btn" onclick="collapseAllAccordions()">Collapse All</button>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üñ®Ô∏è P1 / P1S (CoreXY)</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li>X-axis push (gantry moves)</li>
                                <li>Full bed sweep (7 passes, X-axis)</li>
                                <li>Dynamic multi-lane push system (Left, Center, Right)</li>
                                <li>Z offset: 30mm below model top</li>
                                <li>Start code with optional filament flush</li>
                                <li>M190 cooldown before push-off</li>
                                <li>End sound sequence</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üñ®Ô∏è X1 / X1C (CoreXY)</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li>X-axis push (gantry moves) - same as P1/P1S</li>
                                <li>Full bed sweep (7 passes, X-axis)</li>
                                <li>Dynamic multi-lane push system (Left, Center, Right)</li>
                                <li>Z offset: 30mm below model top</li>
                                <li>Start code with optional filament flush</li>
                                <li>Cutter sequence (G1 Y-3) before push-off (X1-specific)</li>
                                <li>M190 cooldown before push-off</li>
                                <li>End sound sequence</li>
                                <li>Automatic printer model detection from 3MF metadata (BL-P001 or BL-P002)</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üñ®Ô∏è A1 (Bed Slinger)</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li>Y-axis push (bed moves, gantry stationary)</li>
                                <li>Wiggle sweep (X: -48 to 256mm)</li>
                                <li>Automatic Y-axis push using Factorian's 41mm rule</li>
                                <li>Z offset: 40mm below model top (Factorian's rule)</li>
                                <li>Print head parked at X-48 (no clearance needed)</li>
                                <li>Automatic printer model detection from 3MF metadata (N2S)</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üñ®Ô∏è A1 Mini (Bed Slinger)</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li>Y-axis push (bed moves, gantry stationary) - same as A1</li>
                                <li>Wiggle sweep (X: -13 to 180mm)</li>
                                <li>Automatic Y-axis push using Factorian's 41mm rule</li>
                                <li>Z offset: 40mm below model top (Factorian's rule)</li>
                                <li>Automatic printer model detection from 3MF metadata (N1)</li>
                                <li>‚ö†Ô∏è <strong>Requires 50mm clearance to the left of the bed (see Safety Reminders)</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="instructions-section">
                <h3>Supported File Types</h3>
                <ul>
                    <li><strong class="highlight">G-code files</strong> - Export from Bambu Studio: File ‚Üí Export ‚Üí Export G-Code
                        <ul>
                            <li>Supported extensions: <code>.gcode</code>, <code>.gco</code>, <code>.g</code>, <code>.txt</code></li>
                            <li>Must be printed from SD card (required)</li>
                            <li>Printer model must be selected manually (P1/P1S, X1/X1C, A1, or A1 Mini)</li>
                        </ul>
                    </li>
                    <li><strong class="highlight">3MF files</strong> - Export from Bambu Studio: Dropdown (where "Print Plate" is) ‚Üí "Export plate sliced file"
                        <ul>
                            <li>Supported extension: <code>.3mf</code></li>
                            <li>Can be sent directly to the printer from Bambu Studio</li>
                            <li>Printer model is automatically detected from 3MF metadata and locked</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Start and end code are added automatically for all file types. You don't need any special printer profiles or modifications.
                </p>
                <p>
                    <strong>Note:</strong> Maximum file size: 150MB
                </p>
            </div>

            <div class="instructions-section">
                <h3>How to Use Looprint</h3>
                <ol>
                    <li>
                        <strong>Upload your file</strong>
                        <ul>
                            <li><strong>For 3MF files:</strong>
                                <ol>
                                    <li>Slice your model in Bambu Studio</li>
                                    <li>Click the dropdown where you normally click "Print Plate"</li>
                                    <li>Select "Export plate sliced file"</li>
                                    <li>Click "Choose File" or drag and drop the exported 3MF file to Looprint</li>
                                    <li>The file will be validated automatically</li>
                                    <li>Printer model is automatically detected from 3MF metadata and locked</li>
                                    <li>After generating: Open the downloaded 3MF file in Bambu Studio and click "Print Plate" (do not slice again)</li>
                                </ol>
                            </li>
                            <li><strong>For G-code files:</strong>
                                <ol>
                                    <li>Slice your model in Bambu Studio</li>
                                    <li>Click "File" in the menu bar</li>
                                    <li>Select "Export" ‚Üí "Export G-Code"</li>
                                    <li>Click "Choose File" or drag and drop the exported G-code file to Looprint</li>
                                    <li>The file will be validated automatically</li>
                                    <li>Select your printer model (P1/P1S, X1/X1C, or A1) from the dropdown</li>
                                    <li>After generating: Copy the downloaded G-code file to SD card and print from SD card (required)</li>
                                </ol>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Select Printer Model</strong>
                        <ul>
                            <li><strong class="highlight">For 3MF files:</strong> Printer model is automatically detected from metadata and locked (you'll see a checkmark note)</li>
                            <li><strong class="highlight">For G-code files:</strong> Select your printer model from the dropdown:
                                <ul>
                                    <li><strong>P1/P1S/X1/X1C:</strong> Shows push direction selector (Left/Center/Right) in bed preview</li>
                                    <li><strong>P1/P1S/X1/X1C:</strong> Shows "Enable Start Line Purge" checkbox (optional filament flush in start code)</li>
                                    <li><strong>A1:</strong> Shows "Automatic Y-axis" (no manual selection needed)</li>
                                </ul>
                            </li>
                            <li>The interface adapts based on your printer selection</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Configure loops</strong>
                        <ul>
                            <li>Set the number of loops (how many times to print your model)</li>
                            <li>Maximum: 1000 loops (recommended maximum: 50 loops to avoid memory issues)</li>
                            <li><strong>P1/P1S/X1/X1C:</strong> The program automatically detects your model's placement (Left, Center, or Right)</li>
                            <li><strong>A1:</strong> The program automatically calculates Y-axis push position using Factorian's 41mm rule</li>
                            <li>You can view the detected placement in the bed preview below</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Advanced settings (optional)</strong>
                        <ul>
                            <li>Click the checkbox "‚öôÔ∏è Show Advanced Settings" to access push-off configuration</li>
                            <li><strong>Target Bed Temp:</strong> Temperature to cool the bed to before push-off starts
                                <ul>
                                    <li>Default: 18¬∞C (Approx. 23¬∞C on the plate)</li>
                                    <li>Range: 15¬∞C - 90¬∞C</li>
                                    <li>Wait max 60 min for bed to cool before push-off sequence begins</li>
                                    <li>Warning shown if set above 35¬∞C (increases risk of sticking)</li>
                                </ul>
                            </li>
                            <li><strong>Z Push Offset:</strong> How far below the model top to push
                                <ul>
                                    <li>Default: 30mm (P1/P1S/X1/X1C) / 40mm (A1 - Factorian's rule)</li>
                                    <li>Range: 5mm - 120mm</li>
                                    <li><strong>A1:</strong> Uses Factorian's 41mm rule for automatic calculation</li>
                                </ul>
                            </li>
                            <li><strong>Push Lane Offset (P1/P1S/X1/X1C only):</strong> Distance from model center for left/right push lanes
                                <ul>
                                    <li>Default: 30mm</li>
                                    <li>Range: 10mm - 60mm</li>
                                    <li>Automatically adjusted if too large for model placement (prevents crashes)</li>
                                    <li>Maximum possible offset is shown when auto-adjusted</li>
                                    <li><strong>Not applicable for A1</strong> (uses automatic Y-axis push)</li>
                                </ul>
                            </li>
                            <li><strong>Push Direction (P1/P1S/X1/X1C only):</strong> Can be changed manually in advanced mode
                                <ul>
                                    <li>Click zones in the bed preview to change direction</li>
                                    <li>Warning shown if manually changed from auto-detected direction</li>
                                    <li><strong>A1:</strong> Automatic Y-axis push (no manual selection)</li>
                                </ul>
                            </li>
                            <li><strong>Enable Start Line Purge (P1/P1S/X1/X1C):</strong> Optional filament flush in start code
                                <ul>
                                    <li>Default: Enabled (uses start code with flush - matches Factorian's P1 template)</li>
                                    <li>When disabled: Uses start code without filament flush sequence (faster start)</li>
                                    <li>Useful when switching materials or after pause. Disable for faster start when using same filament.</li>
                                </ul>
                            </li>
                            <li><strong>Push-off Speed:</strong> Speed of the push-off motion
                                <ul>
                                    <li>Default: 300 mm/min</li>
                                    <li>Range: 100 - 1000 mm/min</li>
                                    <li>Lower = slower, safer for delicate prints</li>
                                </ul>
                            </li>
                            <li><strong>Full Bed Sweep / Wiggle Sweep (optional):</strong> Clears debris after push-off
                                <ul>
                                    <li><strong>P1/P1S/X1/X1C:</strong> Full bed sweep - 7 passes in safe one-way back-to-front pattern (X-axis)</li>
                                    <li><strong>A1:</strong> Wiggle sweep - X-axis wiggle from -48mm to 256mm</li>
                                    <li>Sweep Speed: Default 300 mm/min (range: 100-1000 mm/min)</li>
                                    <li>Sweep Z Height: Default 1mm (bed level, range: 0.5-50mm)</li>
                                    <li>Always runs with automatic spacing</li>
                                    <li>Respects safe bed boundaries to avoid collisions</li>
                                    <li>Can be tested separately with "Generate Sweep Test File" button (appears when enabled)</li>
                                    <li><strong class="highlight">A1 Mini Warning:</strong> Requires 50mm clearance to the left of the bed (see Safety Reminders section)</li>
                                </ul>
                            </li>
                            <li><strong>Enable Negative Z Push-Off (A1 only - advanced):</strong> Optional feature for low-height models
                                <ul>
                                    <li>Only available for A1 (not A1 Mini, P1, X1)</li>
                                    <li>Uses negative Z values (Z-17) when nozzle head is at X-48 (far left)</li>
                                    <li>Adds an additional push-off sequence after standard push-off</li>
                                    <li><strong class="highlight">‚ö†Ô∏è WARNING:</strong> Only use if you do NOT have a Z-axis stiffener mod installed</li>
                                    <li>Based on Factorian Designs custom end code logic</li>
                                    <li>Should only be used when standard push-off is insufficient for very low parts</li>
                                    <li>Use with caution - this is an advanced feature</li>
                                </ul>
                            </li>
                            <li><strong class="highlight">Safety confirmation:</strong> Checkbox to confirm your model was sliced with Brim enabled. Brim replaces the standard purge line behavior, ensuring a clean and consistent first layer.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Generate and download</strong>
                        <ul>
                            <li>Click "Generate Loop File" to create the looped file</li>
                            <li>Or click "Generate Test File" (appears after file upload) to test just the push-off sequence</li>
                            <li>Or click "Generate Sweep Test File" (appears when Full Bed Sweep is enabled) to test just the sweep sequence</li>
                            <li>Wait for processing to complete (progress bar shows status)</li>
                            <li>Download your looped file</li>
                            <li>Use "Reset to Defaults" button to reset all settings to defaults</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="instructions-section">
                <h3>What Looprint Does</h3>
                <p>When you generate a looped file, Looprint:</p>
                <ol>
                    <li><strong>Detects printer model</strong> - Automatically from 3MF metadata or manual selection for G-code</li>
                    <li><strong>Analyzes your file</strong> - Detects model placement, dimensions, and print settings</li>
                    <li><strong>Removes original start/end code</strong> - Cleans up the slicer's start and end code</li>
                    <li><strong>Adds custom start code</strong> - Inserts optimized printer-specific start code with proper temperature settings</li>
                    <li><strong>Loops the print</strong> - Repeats your print G-code for the specified number of loops</li>
                    <li><strong>Adds push-off sequences</strong> - Inserts automated push-off code between each loop:
                        <ul>
                            <li><strong>P1/P1S/X1/X1C:</strong> X-axis push with dynamic multi-lane system (Left, Center, Right)</li>
                            <li><strong>X1/X1C:</strong> Includes cutter sequence (G1 Y-3) before push-off</li>
                            <li><strong>A1:</strong> Y-axis push using Factorian's 41mm rule (automatic calculation)</li>
                        </ul>
                    </li>
                    <li><strong>Adds bed sweep (optional)</strong> - If enabled, clears debris after push-off:
                        <ul>
                            <li><strong>P1/P1S/X1/X1C:</strong> Full bed sweep (7 passes, X-axis)</li>
                            <li><strong>A1:</strong> Wiggle sweep (X: -48 to 256mm)</li>
                        </ul>
                    </li>
                    <li><strong>Adds custom end code</strong> - Inserts printer-specific end code that cools the bed and prepares for the next loop
                        <ul>
                            <li><strong>P1/P1S:</strong> Includes M190 cooldown, dynamic push, and end sound</li>
                            <li><strong>X1/X1C:</strong> Includes M190 cooldown, cutter sequence, dynamic push, and end sound</li>
                        </ul>
                    </li>
                    <li><strong>Preserves all settings</strong> - All temperatures, speeds, and other settings from your original file are maintained</li>
                    <li><strong>Adds metadata watermark (G-code only)</strong> - Includes Looprint signature with GitHub link in G-code comments (not printed on the model)</li>
                </ol>
            </div>

            <div class="instructions-section">
                <h3>Printer-Specific Push Systems</h3>
                <p>Click to expand technical details for your printer model:</p>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>‚öôÔ∏è P1 / P1S / X1 / X1C: Dynamic Multi-Lane Push System</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <p>
                                Looprint uses a dynamic push-off system that calculates three push lanes based on your model's position:
                            </p>
                            <ul>
                                <li><strong>Center lane:</strong> Pushes at the model's center (X = (minX + maxX) / 2)</li>
                                <li><strong>Left lane:</strong> Pushes at center - offset (default: 30mm to the left of center)</li>
                                <li><strong>Right lane:</strong> Pushes at center + offset (default: 30mm to the right of center)</li>
                            </ul>
                            <p>
                                This ensures stable ejection regardless of your model's shape. The offset is automatically adjusted if it would cause the printer to crash into the bed edges. A warning is displayed if auto-adjustment occurs, showing the maximum possible offset.
                            </p>
                            <p>
                                <strong>Safety Clear:</strong> After push-off, the hotend moves to a safe X position to avoid hitting the model on the next loop.
                            </p>
                            <p style="margin-top: 12px;">
                                <strong>X1/X1C Specific:</strong> Includes cutter sequence (`G1 Y-3`) before push-off. See "Supported Printers" section above for complete feature list.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>‚öôÔ∏è A1: Automatic Y-Axis Push System</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <p>
                                A1 uses a bed slinger design where the bed moves (Y-axis) and the gantry stays stationary. Looprint automatically calculates the optimal push position using Factorian's 41mm rule:
                            </p>
                            <ul>
                                <li><strong>Automatic Y-axis push:</strong> Model center Y is calculated from G-code coordinates</li>
                                <li><strong>Factorian's 41mm rule:</strong> Z offset automatically set to 40mm below model top</li>
                                <li><strong>No manual selection:</strong> Push direction is fully automatic</li>
                                <li><strong>Wiggle sweep:</strong> X-axis wiggle from -48mm to 256mm to clear debris</li>
                                <li><strong>Negative Z Push-Off (advanced, optional):</strong> Available in Advanced Settings for very low-height models. See Advanced Settings section for details and warnings.</li>
                            </ul>
                            <p>
                                <strong>‚ö†Ô∏è Important:</strong> A1 Mini only: Wiggle sweep requires 50mm clearance to the left of the bed. See "Important Safety Reminders" section for details.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="instructions-section" style="background: var(--input); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                <h3 style="margin-top: 0;">‚ö†Ô∏è Important Safety Reminders</h3>
                <ul style="margin-bottom: 0;">
                    <li><strong>Beta Notice:</strong> Looprint is still in beta. Do not leave your printer unattended ‚Äî always stay nearby and monitor the process during automated looping.</li>
                    <li><strong>Use Brim</strong> - Your model must be sliced with Brim enabled. This replaces the standard purge line behavior, ensuring a clean and consistent first layer.</li>
                    <li><strong>Place model at edge</strong> - Position your model at the edge of the bed for proper ejection</li>
                    <li><strong class="highlight">G-code files:</strong> Must be printed from SD card (required)</li>
                    <li><strong class="highlight">3MF files:</strong> After generating, open the downloaded 3MF file in Bambu Studio and click "Print Plate" (do not slice again)</li>
                    <li><strong>Monitor first print</strong> - Watch the first loop to ensure everything works as expected</li>
                    <li><strong>A1 Mini users:</strong> Ensure 50mm clearance to the left of the bed for wiggle sweep (A1 print head is parked further left, no clearance needed)</li>
                    <li><strong>P1/P1S/X1/X1C users:</strong> Ensure model placement allows for dynamic push lanes (Left, Center, Right)</li>
                </ul>
            </div>

            <div class="instructions-section">
                <h3>Tips & Best Practices</h3>
                <ul>
                    <li>Start with 2-3 loops to test before doing longer runs</li>
                    <li>Use "Generate Test File" to test push-off sequence only</li>
                    <li>Use "Generate Sweep Test File" (when Full Bed Sweep is enabled) to test sweep sequence only</li>
                    <li>Full Bed Sweep is useful for clearing debris between loops, especially with multiple prints</li>
                    <li>Keep your bed clean and properly leveled</li>
                    <li>Ensure your model has a good first layer adhesion</li>
                    <li>The cooldown temperature (default 18¬∞C) helps the finished print release from the bed so it can be pushed off</li>
                    <li>If prints stick and won't release, try lowering the cooldown temperature slightly</li>
                    <li>If prints release too easily or don't stick enough during printing, you may need to adjust the cooldown temperature</li>
                </ul>
            </div>

            <div class="instructions-section">
                <h3>Troubleshooting</h3>
                <p>Having issues? Click to expand troubleshooting for your printer model:</p>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üîß General Issues</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li><strong>File won't upload:</strong> Ensure it's a valid G-code (.gcode, .gco, .g, .txt) or 3MF (.3mf) file. Maximum file size: 150MB</li>
                                <li><strong>Push-off doesn't work:</strong> Verify Brim is enabled and model is at bed edge. Use "Generate Test File" to test push-off sequence</li>
                                <li><strong>Temperature issues:</strong> All temperatures come from your original file - check your slicer settings. Start code automatically extracts and uses correct temperatures</li>
                                <li><strong>File too large:</strong> Maximum file size is 150MB. Large files may take longer to process - be patient. Progress bar shows processing status</li>
                                <li><strong>Too many loops warning:</strong> If you set more than 100 loops, you'll get a warning. Recommended maximum is 50 loops</li>
                                <li><strong>Cooldown temperature warning:</strong> If set above 35¬∞C, you'll see a warning about increased sticking risk</li>
                                <li><strong>Settings not saving:</strong> Settings are saved to browser localStorage. Clear browser data if you have issues</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üîß P1 / P1S / X1 / X1C Issues</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li><strong>Wrong placement detected:</strong> Check that your model is clearly on one side of the bed. You can manually change push direction in advanced settings if needed</li>
                                <li><strong>Push lane offset auto-adjusted:</strong> If you see a warning about offset being adjusted, the value was too large for your model placement. Check the displayed maximum value</li>
                                <li><strong>X1/X1C - Cutter sequence not working:</strong> Verify end code includes `G1 Y-3` before push-off. Check that M190 cooldown completes before cutter sequence. Use "Generate Test File" to debug</li>
                                <li><strong>X1/X1C - Start code flush option:</strong> "Start Line Purge" checkbox controls filament flush in start code. Default: Enabled (matches Factorian's P1 template). Disable for faster start when using same filament.</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="printer-accordion">
                    <div class="printer-accordion-header" onclick="toggleAccordion(this)">
                        <h4>üîß A1 Issues</h4>
                        <span class="printer-accordion-icon">‚ñº</span>
                    </div>
                    <div class="printer-accordion-content">
                        <div class="printer-accordion-inner">
                            <ul>
                                <li><strong>Wiggle sweep collision warning:</strong> Ensure 50mm clearance to the left of the bed. Check model placement in bed preview</li>
                                <li><strong>Y-axis push not working:</strong> Verify model center Y is correctly calculated. Check that first_layer_center_no_wipe_tower is extracted correctly. Use "Generate Test File" to debug</li>
                                <li><strong>Temperature offset:</strong> A1 automatically applies -4¬∞C temperature offset</li>
                                <li><strong>Negative Z Push-Off:</strong> Only available for A1 (not A1 Mini). See Advanced Settings section for details and warnings.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="instructions-section">
                <h3>Need Help?</h3>
                <p>
                    If you encounter issues or have questions, make sure you've watched the Factorian Designs videos about the automation system that Looprint is based on: <a href="https://factoriandesigns.com/print-automation-bambu-lab-a1-a1-mini" target="_blank" rel="noopener noreferrer" style="color: var(--accent);" id="factorianLinkHelpAnchorA1">A1/A1 Mini</a> or <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent);" id="factorianLinkHelpAnchorP1X1">P1/P1S/X1/X1C</a>.
                </p>
            </div>
    </div>
</div>

<script>
    // ===== CONSTANTS =====
    const COOLDOWN_WARNING_THRESHOLD = 35;
    const REQUIRED_SIGNATURE = "FactorianDesigns";
    const LOOPRINT_SIGNATURE = "Looprint Loop File"; 
    const END_CODE_START_MARKER = ";===== date:";
    // Regex pattern for finding G-code files in 3MF structure
    const GCODE_FILE_IN_3MF_REGEX = /^Metadata\/plate_\d+\.gcode$/i; 
    
    // Performance and processing constants
    const FILE_SIZE_OVERHEAD_FACTOR = 1.1; // 10% overhead for headers and end codes
    const CHUNKED_PROCESSING_DELAY_MS = 2; // Reduced from 10ms for better performance
    const MAX_Z_HEIGHT_MM = 1000; // Increased from 500mm for taller models
    const FILE_SIZE_ESTIMATE_3MF_OVERHEAD = 1.15; // 15% overhead for 3MF files (compression, headers)
    const MAX_PLACEMENT_PARSE_LINES = 100000; // Reduced from 500000 for better performance
    
    // Start code for 3MF files (inserted in each loop)
    const START_CODE_3MF = `;===== machine: P1S ======================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20231107 =====================
;===== turn on the HB fan & MC board fan =================
M104 S75 ;set extruder temp to turn on the HB fan and prevent filament oozing from nozzle
M710 A1 S255 ;turn on MC fan by default(P1S)
;===== reset machine status =================
M290 X40 Y40 Z2.6666666
G91
M17 Z0.4 ; lower the z-motor current
G380 S2 Z30 F300 ; G380 is same as G38; lower the hotbed , to prevent the nozzle is below the hotbed
G380 S2 Z-25 F300 ;
G1 Z5 F300;
G90
M17 X1.2 Y1.2 Z0.75 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 5
M221 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem
G29.1 Z{+0.0} ; clear z-trim value first
M204 S10000 ; init ACC set to 10m/s^2

;===== heatbed preheat ====================
M1002 gcode_claim_action : 2
M140 S[bed_temperature_initial_layer_single] ;set bed temp
M190 S[bed_temperature_initial_layer_single] ;wait for bed temp



;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;===== prepare print temperature and material ==========
M104 S[nozzle_temperature_initial_layer] ;set extruder temp
G91
G0 Z10 F1200
G90
G28 X
M975 S1 ; turn on
G1 X60 F12000
G1 Y245
G1 Y265 F3000
M620 M
M620 S[initial_extruder]A   ; switch material if AMS exist
    M109 S[nozzle_temperature_initial_layer]
    G1 X120 F12000

    G1 X20 Y50 F12000
    G1 Y-3
    T[initial_extruder]
    G1 X54 F12000
    G1 Y265
    M400
M621 S[initial_extruder]A
M620.1 E F{filament_max_volumetric_speed[initial_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_extruder]}


M412 S1 ; ===turn on filament runout detection===

M109 S250 ;set nozzle to common flush temp
M106 P1 S0
G92 E0
G1 E50 F200
M400
M104 S[nozzle_temperature_initial_layer]
G92 E0
G1 E50 F200
M400
M106 P1 S255
G92 E0
G1 E5 F300
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20} ; drop nozzle temp, make filament shink a bit
G92 E0
G1 E-0.5 F300

G1 X70 F9000
G1 X76 F15000
G1 X65 F15000
G1 X76 F15000
G1 X65 F15000; shake to put down garbage
G1 X80 F6000
G1 X95 F15000
G1 X80 F15000
G1 X165 F15000; wipe and shake
M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1
M106 S255
G1 X65 Y230 F18000
G1 Y264 F6000
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20}
G1 X100 F18000 ; first wipe mouth

G0 X135 Y253 F20000  ; move to exposed steel surface edge
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
G0 Z5 F20000

G1 X60 Y265
G92 E0
G1 E-0.5 F300 ; retrack more
G1 X100 F5000; second wipe mouth
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X90 F5000
G0 X128 Y261 Z-1.5 F20000  ; move to exposed steel surface and stop the nozzle
M104 S140 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)

M221 S; push soft endstop status
M221 Z0 ;turn off Z axis endstop
G0 Z0.5 F20000
G0 X125 Y259.5 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 X128
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300

M109 S140 ; wait nozzle temp down to heatbed acceptable
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000

M221 R; pop softend status
G1 Z10 F1200
M400
G1 Z10
G1 F30000
G1 X230 Y15
G29.2 S1 ; turn on ABL
;G28 ; home again after hard wipe mouth
M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================


;===== bed leveling ==================================
;M1002 judge_flag g29_before_print_flag
;M622 J1
;
;    M1002 gcode_claim_action : 1
;    G29 A X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
;    M400
;    M500 ; save cali data
;
;M623
G1 X128 Y128; move to the middle of the buildplate
G28 Z P1 T300; level clean nozzle 
																 
;===== bed leveling end ================================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623
;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression


;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead


;M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; set extrude temp earlier, to reduce wait time

;===== mech mode fast check============================
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q1 A7 B30 C80  H15 K0
;M974 Q1 S2 P0
;
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q0 A7 B30 C90 Q0 H15 K0
;M974 Q0 S2 P0
;
;M975 S1
;G1 F30000
;G1 X230 Y15
;G28 X ; re-home XY
;===== fmech mode fast check============================


;===== nozzle load line ===============================
M975 S1
G90
M83
T1000
;G1 X18.0 Y1.0 Z0.8 F18000;Move to start position
;M109 S{nozzle_temperature_initial_layer[initial_extruder]}
;G1 Z0.2
;G0 E2 F300
;G0 X240 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
;G0 Y11 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)/ 4 * 60}
;G0 X239.5
;G0 E0.2
;G0 Y1.5 E0.700
;G0 X18 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
M400

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.07} ; for Textured PEI Plate
{endif}
;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}; -20 ¬∞C so print already starts and nozzle doesn't ooze unnecessarily
M104 S[nozzle_temperature_initial_layer]  ; let it reach target temperatur while printing																																			   
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression

; ================================== Start Code End ======================================`;

    // P1 Start Code Template WITHOUT Flush (for optional purge checkbox)
    const P1_START_NO_FLUSH = `;===== machine: P1S ======================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20231107 =====================
;===== turn on the HB fan & MC board fan =================
M104 S75 ;set extruder temp to turn on the HB fan and prevent filament oozing from nozzle
M710 A1 S255 ;turn on MC fan by default(P1S)
;===== reset machine status =================
M290 X40 Y40 Z2.6666666
G91
M17 Z0.4 ; lower the z-motor current
G380 S2 Z30 F300 ; G380 is same as G38; lower the hotbed , to prevent the nozzle is below the hotbed
G380 S2 Z-25 F300 ;
G1 Z5 F300;
G90
M17 X1.2 Y1.2 Z0.75 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 5
M221 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem
G29.1 Z{+0.0} ; clear z-trim value first
M204 S10000 ; init ACC set to 10m/s^2

;===== heatbed preheat ====================
M1002 gcode_claim_action : 2
M140 S[bed_temperature_initial_layer_single] ;set bed temp
M190 S[bed_temperature_initial_layer_single] ;wait for bed temp



;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;===== prepare print temperature and material ==========
M104 S[nozzle_temperature_initial_layer] ;set extruder temp
G91
G0 Z10 F1200
G90
G28 X
M975 S1 ; turn on
G1 X60 F12000
G1 Y245
G1 Y265 F3000
M620 M
M620 S[initial_extruder]A   ; switch material if AMS exist
    M109 S[nozzle_temperature_initial_layer]
    G1 X120 F12000

    G1 X20 Y50 F12000
    G1 Y-3
    T[initial_extruder]
    G1 X54 F12000
    G1 Y265
    M400
M621 S[initial_extruder]A
M620.1 E F{filament_max_volumetric_speed[initial_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_extruder]}


M412 S1 ; ===turn on filament runout detection===

;M109 S250 ;set nozzle to common flush temp
;M106 P1 S0
;G92 E0
;G1 E50 F200
;M400
;M104 S[nozzle_temperature_initial_layer]
;G92 E0
;G1 E50 F200
;M400
;M106 P1 S255
;G92 E0
;G1 E5 F300
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20} ; drop nozzle temp, make filament shink a bit
G92 E0
G1 E-0.5 F300

G1 X70 F9000
G1 X76 F15000
G1 X65 F15000
G1 X76 F15000
G1 X65 F15000; shake to put down garbage
G1 X80 F6000
G1 X95 F15000
G1 X80 F15000
G1 X165 F15000; wipe and shake
M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1
M106 S255
G1 X65 Y230 F18000
G1 Y264 F6000
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20}
G1 X100 F18000 ; first wipe mouth

G0 X135 Y253 F20000  ; move to exposed steel surface edge
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
G0 Z5 F20000

G1 X60 Y265
G92 E0
G1 E-0.5 F300 ; retrack more
G1 X100 F5000; second wipe mouth
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X90 F5000
G0 X128 Y261 Z-1.5 F20000  ; move to exposed steel surface and stop the nozzle
M104 S140 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)

M221 S; push soft endstop status
M221 Z0 ;turn off Z axis endstop
G0 Z0.5 F20000
G0 X125 Y259.5 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 X128
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300

M109 S140 ; wait nozzle temp down to heatbed acceptable
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000

M221 R; pop softend status
G1 Z10 F1200
M400
G1 Z10
G1 F30000
G1 X230 Y15
G29.2 S1 ; turn on ABL
;G28 ; home again after hard wipe mouth
M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================


;===== bed leveling ==================================
;M1002 judge_flag g29_before_print_flag
;M622 J1
;
;    M1002 gcode_claim_action : 1
;    G29 A X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
;    M400
;    M500 ; save cali data
;
;M623
G1 X128 Y128; move to the middle of the buildplate
G28 Z P1 T300; level clean nozzle 
																 
;===== bed leveling end ================================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623
;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression


;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead


;M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; set extrude temp earlier, to reduce wait time

;===== mech mode fast check============================
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q1 A7 B30 C80  H15 K0
;M974 Q1 S2 P0
;
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q0 A7 B30 C90 Q0 H15 K0
;M974 Q0 S2 P0
;
;M975 S1
;G1 F30000
;G1 X230 Y15
;G28 X ; re-home XY
;===== fmech mode fast check============================


;===== nozzle load line ===============================
M975 S1
G90
M83
T1000
;G1 X18.0 Y1.0 Z0.8 F18000;Move to start position
;M109 S{nozzle_temperature_initial_layer[initial_extruder]}
;G1 Z0.2
;G0 E2 F300
;G0 X240 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
;G0 Y11 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)/ 4 * 60}
;G0 X239.5
;G0 E0.2
;G0 Y1.5 E0.700
;G0 X18 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
M400

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.07} ; for Textured PEI Plate
{endif}
;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}; -20 ¬∞C so print already starts and nozzle doesn't ooze unnecessarily
M104 S[nozzle_temperature_initial_layer]  ; let it reach target temperatur while printing																																			   
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression

; ================================== Start Code End ======================================`;
    
    // A1 Start Code Template (from Start_A1.txt)
    const START_CODE_A1 = `;===== machine: A1 ========================= 
;Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20240620 =====================
G392 S0
M9833.2
;M400
;M73 P1.717

;===== start to heat heatbead&hotend==========
M1002 gcode_claim_action : 2
M1002 set_filament_type:{filament_type[initial_no_support_extruder]}
M104 S140
M140 S[bed_temperature_initial_layer_single]

;=====start printer sound ===================
M17
M400 S1
M1006 S1
M1006 A0 B10 L100 C37 D10 M60 E37 F10 N60
M1006 A0 B10 L100 C41 D10 M60 E41 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A43 B10 L100 C46 D10 M70 E39 F10 N80
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N80
M1006 A0 B10 L100 C43 D10 M60 E39 F10 N80
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N80
M1006 A0 B10 L100 C41 D10 M80 E41 F10 N80
M1006 A0 B10 L100 C44 D10 M80 E44 F10 N80
M1006 A0 B10 L100 C49 D10 M80 E49 F10 N80
M1006 A0 B10 L100 C0 D10 M80 E0 F10 N80
M1006 A44 B10 L100 C48 D10 M60 E39 F10 N80
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N80
M1006 A0 B10 L100 C44 D10 M80 E39 F10 N80
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N80
M1006 A43 B10 L100 C46 D10 M60 E39 F10 N80
M1006 W
M18 
;=====start printer sound ===================

;=====avoid end stop =================
G91
G380 S2 Z40 F1200
G380 S3 Z-15 F1200
G90

;===== reset machine status =================
;M290 X39 Y39 Z8
M204 S6000

M630 S0 P0
G91
M17 Z0.3 ; lower the z-motor current

G90
M17 X0.65 Y1.2 Z0.6 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
;M211 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem

;====== cog noise reduction=================
M982.2 S1 ; turn on cog noise reduction

M1002 gcode_claim_action : 13

G28 X
G91
G1 Z5 F1200
G90
G0 X128 F30000
G0 Y254 F3000
G91
G1 Z-5 F1200

M109 S25 H140

M17 E0.3
M83
G1 E10 F1200
G1 E-0.5 F30
M17 D

G28 Z P0 T140; home z with low precision,permit 300deg temperature
M104 S{nozzle_temperature_initial_layer[initial_extruder]}

M1002 judge_flag build_plate_detect_flag
M622 S1
  G39.4
  G90
  G1 Z5 F1200
M623

;M400
;M73 P1.717

;===== prepare print temperature and material ==========
M1002 gcode_claim_action : 24

M400
;G392 S1
M211 X0 Y0 Z0 ;turn off soft endstop
M975 S1 ; turn on

G90
G1 X-28.5 F30000
G1 X-48.2 F3000

M620 M ;enable remap
M620 S[initial_no_support_extruder]A   ; switch material if AMS exist
    M1002 gcode_claim_action : 4
    M400
    M1002 set_filament_type:UNKNOWN
    M109 S[nozzle_temperature_initial_layer]
    M104 S250
    M400
    T[initial_no_support_extruder]
    G1 X-48.2 F3000
    M400

    M620.1 E F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_no_support_extruder]}
    M109 S250 ;set nozzle to common flush temp
    M106 P1 S0
    G92 E0
    G1 E50 F200
    M400
    M1002 set_filament_type:{filament_type[initial_no_support_extruder]}
M621 S[initial_no_support_extruder]A

M109 S{nozzle_temperature_range_high[initial_no_support_extruder]} H300
G92 E0
G1 E50 F200 ; lower extrusion speed to avoid clog
M400
M106 P1 S178
G92 E0
G1 E5 F200
M104 S{nozzle_temperature_initial_layer[initial_no_support_extruder]}
G92 E0
G1 E-0.5 F300

G1 X-28.5 F30000
G1 X-48.2 F3000
G1 X-28.5 F30000 ;wipe and shake
G1 X-48.2 F3000
G1 X-28.5 F30000 ;wipe and shake
G1 X-48.2 F3000

;G392 S0

M400
M106 P1 S0
;===== prepare print temperature and material end =====

;M400
;M73 P1.717

;===== auto extrude cali start =========================
M975 S1
;G392 S1

G90
M83
T1000
G1 X-48.2 Y0 Z10 F10000
M400
M1002 set_filament_type:UNKNOWN

M412 S1 ;  ===turn on  filament runout detection===
M400 P10
M620.3 W1; === turn on filament tangle detection===
M400 S2

M1002 set_filament_type:{filament_type[initial_no_support_extruder]}

;M1002 set_flag extrude_cali_flag=1
M1002 judge_flag extrude_cali_flag

M622 J1
    M1002 gcode_claim_action : 8

    M109 S{nozzle_temperature[initial_extruder]}
    G1 E10 F{outer_wall_volumetric_speed/2.4*60}
    M983 F{outer_wall_volumetric_speed/2.4} A0.3 H[nozzle_diameter]; cali dynamic extrusion compensation

    M106 P1 S255
    M400 S5
    G1 X-28.5 F18000
    G1 X-48.2 F3000
    G1 X-28.5 F18000 ;wipe and shake
    G1 X-48.2 F3000
    G1 X-28.5 F12000 ;wipe and shake
    G1 X-48.2 F3000
    M400
    M106 P1 S0

    M1002 judge_last_extrude_cali_success
    M622 J0
        M983 F{outer_wall_volumetric_speed/2.4} A0.3 H[nozzle_diameter]; cali dynamic extrusion compensation
        M106 P1 S255
        M400 S5
        G1 X-28.5 F18000
        G1 X-48.2 F3000
        G1 X-28.5 F18000 ;wipe and shake
        G1 X-48.2 F3000
        G1 X-28.5 F12000 ;wipe and shake
        M400
        M106 P1 S0
    M623
    
    G1 X-48.2 F3000
    M400
    M984 A0.1 E1 S1 F{outer_wall_volumetric_speed/2.4} H[nozzle_diameter]
    M106 P1 S178
    M400 S7
    G1 X-28.5 F18000
    G1 X-48.2 F3000
    G1 X-28.5 F18000 ;wipe and shake
    G1 X-48.2 F3000
    G1 X-28.5 F12000 ;wipe and shake
    G1 X-48.2 F3000
    M400
    M106 P1 S0
M623 ; end of "draw extrinsic para cali paint"

;G392 S0
;===== auto extrude cali end ========================

;M400
;M73 P1.717

M104 S170 ; prepare to wipe nozzle
M106 S255 ; turn on fan

;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14

M975 S1
M106 S255 ; turn on fan (G28 has turn off fan)
M211 S; push soft endstop status
M211 X0 Y0 Z0 ;turn off Z axis endstop

;===== remove waste by touching start =====

M104 S170 ; set temp down to heatbed acceptable

M83
G1 E-1 F500
G90
M83

M109 S170
G0 X108 Y-0.5 F30000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X110 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X112 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X114 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X116 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X118 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X120 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X122 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X124 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X126 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X128 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X130 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X132 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X134 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X136 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X138 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X140 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X142 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X144 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X146 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X148 F10000
G380 S3 Z-5 F1200

G1 Z5 F30000
;===== remove waste by touching end =====

G1 Z10 F1200
G0 X118 Y261 F30000
G1 Z5 F1200
M109 S{nozzle_temperature_initial_layer[initial_extruder]-50}

G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
M104 S140 ; prepare to abl
G0 Z5 F20000

G0 X128 Y261 F20000  ; move to exposed steel surface
G0 Z-1.01 F1200      ; stop the nozzle

G91
G2 I1 J0 X2 Y0 F2000.1
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5

G90
G1 Z10 F1200

;===== brush material wipe nozzle =====

G90
G1 Y250 F30000
G1 X55
G1 Z1.300 F1200
G1 Y262.5 F6000
G91
G1 X-35 F30000
G1 Y-0.5
G1 X45
G1 Y-0.5
G1 X-45
G1 Y-0.5
G1 X45
G1 Y-0.5
G1 X-45
G1 Y-0.5
G1 X45
G1 Z5.000 F1200

G90
G1 X30 Y250.000 F30000
G1 Z1.300 F1200
G1 Y262.5 F6000
G91
G1 X35 F30000
G1 Y-0.5
G1 X-45
G1 Y-0.5
G1 X45
G1 Y-0.5
G1 X-45
G1 Y-0.5
G1 X45
G1 Y-0.5
G1 X-45
G1 Z10.000 F1200

;===== brush material wipe nozzle end =====

G90
G1 Y250 F30000
G1 X138
G1 Y261
G0 Z-1.01 F1200      ; stop the nozzle

G91
G2 I1 J0 X2 Y0 F2000.1
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5

M109 S140
M106 S255 ; turn on fan (G28 has turn off fan)

M211 R; pop softend status

;===== wipe nozzle end ================================

;M400
;M73 P1.717

;===== bed leveling ==================================
M1002 judge_flag g29_before_print_flag

G90
G1 Z5 F1200
G1 X0 Y0 F30000
G29.2 S1 ; turn on ABL

M190 S[bed_temperature_initial_layer_single]; ensure bed temp
M109 S140
M106 S0 ; turn off fan , too noisy

M622 J1
    M1002 gcode_claim_action : 1
    G29 A1 X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
    M400
    M500 ; save cali data
M623
;===== bed leveling end ================================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623

;===== home after wipe mouth end =======================

;M400
;M73 P1.717

G1 X108.000 Y-0.500 F30000
G1 Z0.300 F1200
M400
G2814 Z0.32

M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; prepare to print

;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
M400

G1 Z3 F800 ; move nozzle up a little
M106 P1 S255 ; turn on fan to cool tip of nozzle, prevents oozing
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20} ; wait for warm up but don't fully heat yet to prevent oozing

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.02} ; for Textured PEI Plate
{endif}

M960 S1 P0 ; turn off laser
M960 S2 P0 ; turn off laser
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression
G90
M83
T1000

M211 X0 Y0 Z0 ;turn off soft endstop
;G392 S1 ; turn on clog detection
M1007 S1 ; turn on mass estimation
G29.4

G0 E2.2 F800 ; Extrude a little so nozzle is filled for print start you might have to increase this up to E2.5 depending on your filament
M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; heat up to full temp in first few moves`;

    // A1 Mini Start Code (from Factorian's Start_A1_Mini.txt)
    const START_CODE_A1_MINI = `;===== machine: A1 mini =========================
;Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20240620 =====================

;===== start to heat heatbead&hotend==========
M1002 gcode_claim_action : 2
M1002 set_filament_type:{filament_type[initial_no_support_extruder]}
M104 S170
M140 S[bed_temperature_initial_layer_single]
G392 S0 ;turn off clog detect
M9833.2
;=====start printer sound ===================
M17
M400 S1
M1006 S1
M1006 A0 B0 L100 C37 D10 M100 E37 F10 N100
M1006 A0 B0 L100 C41 D10 M100 E41 F10 N100
M1006 A0 B0 L100 C44 D10 M100 E44 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A43 B10 L100 C39 D10 M100 E46 F10 N100
M1006 A0 B0 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B0 L100 C39 D10 M100 E43 F10 N100
M1006 A0 B0 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B0 L100 C41 D10 M100 E41 F10 N100
M1006 A0 B0 L100 C44 D10 M100 E44 F10 N100
M1006 A0 B0 L100 C49 D10 M100 E49 F10 N100
M1006 A0 B0 L100 C0 D10 M100 E0 F10 N100
M1006 A44 B10 L100 C39 D10 M100 E48 F10 N100
M1006 A0 B0 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B0 L100 C39 D10 M100 E44 F10 N100
M1006 A0 B0 L100 C0 D10 M100 E0 F10 N100
M1006 A43 B10 L100 C39 D10 M100 E46 F10 N100
M1006 W
M18
;=====avoid end stop =================
G91
G380 S2 Z30 F1200
G380 S3 Z-20 F1200
G1 Z5 F1200
G90

;===== reset machine status =================
M204 S6000

M630 S0 P0
G91
M17 Z0.3 ; lower the z-motor current

G90
M17 X0.7 Y0.9 Z0.5 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M83
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
;====== cog noise reduction=================
M982.2 S1 ; turn on cog noise reduction

;===== prepare print temperature and material ==========
M400
M18
M109 S100 H170
M104 S170
M400
M17
M400
G28 X

M211 X0 Y0 Z0 ;turn off soft endstop ; turn off soft endstop to prevent protential logic problem

M975 S1 ; turn on

G1 X0.0 F30000
G1 X-13.5 F3000

M620 M ;enable remap
M620 S[initial_no_support_extruder]A   ; switch material if AMS exist
    G392 S0 ;turn on clog detect
    M1002 gcode_claim_action : 4
    M400
    M1002 set_filament_type:UNKNOWN
    M109 S[nozzle_temperature_initial_layer]
    M104 S250
    M400
    T[initial_no_support_extruder]
    G1 X-13.5 F3000
    M400
    M620.1 E F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_no_support_extruder]}
    M109 S250 ;set nozzle to common flush temp
    M106 P1 S0
    G92 E0
    G1 E50 F200
    M400
    M1002 set_filament_type:{filament_type[initial_no_support_extruder]}
    M104 S{nozzle_temperature_range_high[initial_no_support_extruder]}
    G92 E0
    G1 E50 F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60}
    M400
    M106 P1 S178
    G92 E0
    G1 E5 F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60}
    M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20} ; drop nozzle temp, make filament shink a bit
    M104 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-40}
    G92 E0
    G1 E-0.5 F300

    G1 X0 F30000
    G1 X-13.5 F3000
    G1 X0 F30000 ;wipe and shake
    G1 X-13.5 F3000
    G1 X0 F12000 ;wipe and shake
    G1 X0 F30000
    G1 X-13.5 F3000
    M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-40}
    G392 S0 ;turn off clog detect
M621 S[initial_no_support_extruder]A

M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== mech mode fast check============================
M1002 gcode_claim_action : 3
G0 X25 Y175 F20000 ; find a soft place to home
;M104 S0
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
M104 S170

; build plate detect
M1002 judge_flag build_plate_detect_flag
M622 S1
  G39.4
  M400
M623

G1 Z5 F3000
; ++++++++++++ Ab hier Mech Mode, davor leveling +++++++++++

M975 S1
G1 F30000
G1 X-1 Y10
G28 X ; re-home XY

;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1

M104 S170 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)
M211 S; push soft endstop status
M211 X0 Y0 Z0 ;turn off Z axis endstop

M83
G1 E-1 F500
G90
M83

M109 S170
M104 S140
G0 X90 Y-4 F30000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X91 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X92 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X93 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X94 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X95 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X96 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X97 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X98 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X99 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X99 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X99 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X99 F10000
G380 S3 Z-5 F1200
G1 Z2 F1200
G1 X99 F10000
G380 S3 Z-5 F1200

G1 Z5 F30000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
G1 X25 Y175 F30000.1 ;Brush material
G1 Z0.2 F30000.1
G1 Y185
G91
G1 X-30 F30000
G1 Y-2
G1 X27
G1 Y1.5
G1 X-28
G1 Y-2
G1 X30
G1 Y1.5
G1 X-30
G90
M83

G1 Z5 F3000
G0 X50 Y175 F20000 ; find a soft place to home
G28 Z P0 T300; home z with low precision, permit 300deg temperature
G29.2 S0 ; turn off ABL

G0 X85 Y185 F10000 ;move to exposed steel surface and stop the nozzle
G0 Z-1.01 F10000
G91

G2 I1 J0 X2 Y0 F2000.1
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5
G2 I1 J0 X2
G2 I-0.75 J0 X-1.5

G90
G1 Z5 F30000
G1 X25 Y175 F30000.1 ;Brush material
G1 Z0.2 F30000.1
G1 Y185
G91
G1 X-30 F30000
G1 Y-2
G1 X27
G1 Y1.5
G1 X-28
G1 Y-2
G1 X30
G1 Y1.5
G1 X-30
G90
M83

G1 Z5
G0 X55 Y175 F20000 ; find a soft place to home
G28 Z P0 T300; home z with low precision, permit 300deg temperature
G29.2 S0 ; turn off ABL

G1 Z10
G1 X85 Y185
G1 Z-1.01
G1 X95
G1 X90

M211 R; pop softend status

M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================


;===== wait heatbed  ====================
M1002 gcode_claim_action : 2
M104 S0
M190 S[bed_temperature_initial_layer_single];set bed temp
M109 S140

G1 Z5 F3000
G29.2 S1
G1 X10 Y10 F20000

;===== bed leveling ==================================
;M1002 set_flag g29_before_print_flag=1
M1002 judge_flag g29_before_print_flag
M622 J1
    M1002 gcode_claim_action : 1
    G29 A1 X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
    M400
    M500 ; save cali data
M623
;===== bed leveling end ================================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28 T145

M623

;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression
;===== nozzle load line ===============================
M975 S1
G90
M83
T1000

G1 X-13.5 Y0 Z10 F10000
G1 E1.2 F500
M400
M1002 set_filament_type:UNKNOWN
;M109 S{nozzle_temperature[initial_extruder]}
M400

M412 S1 ;    ===turn on  filament runout detection===
M400 P10

G392 S0 ;turn on clog detect

M620.3 W1; === turn on filament tangle detection===
M400 S2

;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0

M400 ; wait all motion done before implement the emprical L parameters

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.02} ; for Textured PEI Plate
{endif}

M960 S1 P0 ; turn off laser
M960 S2 P0 ; turn off laser
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression
G90
M83
T1000

M211 X0 Y0 Z0 ;turn off soft endstop
M1007 S1

G0 E1 F800 ;Extrude a little so nozzle is filled for print start you might have to increase this up to E1.3 depending on your filament
M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; heat up to full temp in first few moves`;

    // Bed boundaries (mm) - for placement detection
    const PUSH_LEFT_BOUNDARY = 90;
    const PUSH_RIGHT_BOUNDARY = 166;
    
    // Placement detection
    const MIN_POINTS_REQUIRED = 50;
    const MAX_DATA_POINTS = 10000;
    const MAX_LINES_TO_PARSE = MAX_PLACEMENT_PARSE_LINES; // Use constant
    const Z_FILTER_THRESHOLD = 4.0; // mm
    
    // Placement detection tolerance
    const PLACEMENT_TOLERANCE = 1.0; // mm
    
    // Bed boundaries for push-off (safe X positions)
    const BED_MIN_X = 10;                // Minimum safe X position (mm from left edge)
    const BED_MAX_X = 246;               // Maximum safe X position (mm from left edge, bed width ~256mm)
    
    // Default values
    const DEFAULT_LOOPS = 5;
    const DEFAULT_TEMP = 18;
    const DEFAULT_OFFSET = 30;
    const MIN_OFFSET = 5;
    const MAX_OFFSET = 120;
    const MIN_TEMP = 15;
    const MAX_TEMP = 90;
    const MAX_LOOPS = 1000;
    
    // Dynamic push lane offset settings
    const DEFAULT_PUSH_LANE_OFFSET = 30; // Default offset from model center (mm)
    const MIN_PUSH_LANE_OFFSET = 10;     // Minimum offset (safety margin from bed edges)
    const MAX_PUSH_LANE_OFFSET = 60;     // Maximum offset (prevents excessive values)
    
    // Push-off speed settings
    const DEFAULT_PUSH_SPEED = 300;  // Default push-off speed (mm/min)
    const MIN_PUSH_SPEED = 100;      // Minimum speed (mm/min)
    const MAX_PUSH_SPEED = 1000;     // Maximum speed (mm/min)
    
    // File size limits
    const MAX_FILE_SIZE = 150 * 1024 * 1024; // 150MB
    const MAX_GENERATED_FILE_SIZE = 1000 * 1024 * 1024; // 1GB limit for generated files
    
    // Full bed sweep settings (always 7 passes with automatic spacing)
    const DEFAULT_SWEEP_SPEED = 300;  // Default sweep speed (mm/min)
    const MIN_SWEEP_SPEED = 100;      // Minimum speed (mm/min)
    const MAX_SWEEP_SPEED = 1000;     // Maximum speed (mm/min)
    const DEFAULT_SWEEP_Z = 1;        // Default sweep Z height (mm) - bed level
    const MIN_SWEEP_Z = 0.5;          // Minimum Z height (mm)
    const MAX_SWEEP_Z = 50;            // Maximum Z height (mm)
    
    // Debug mode - set to false for production
    const DEBUG_MODE = true; // Set to true to enable console logging for debugging
    // TEMPORARY: Enabled for diagnostic logging of first_layer_center_no_wipe_tower extraction issues

    // X1 Start Code Templates (loaded from X1 folder)
    const X1_START_FLUSH = `;===== machine: X1 ==================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20240528 ==================
;===== start printer sound ================
M17
M400 S1
M1006 S1
M1006 A0 B10 L100 C37 D10 M60 E37 F10 N60
M1006 A0 B10 L100 C41 D10 M60 E41 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A46 B10 L100 C43 D10 M70 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A43 B10 L100 C0 D10 M60 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A41 B10 L100 C0 D10 M100 E41 F10 N100
M1006 A44 B10 L100 C0 D10 M100 E44 F10 N100
M1006 A49 B10 L100 C0 D10 M100 E49 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A48 B10 L100 C44 D10 M60 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A44 B10 L100 C0 D10 M90 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A46 B10 L100 C43 D10 M60 E39 F10 N100
M1006 W
;===== turn on the HB fan =================
M104 S75 ;set extruder temp to turn on the HB fan and prevent filament oozing from nozzle
;===== reset machine status =================
M290 X40 Y40 Z2.6666666
G91
M17 Z0.4 ; lower the z-motor current
G380 S2 Z30 F300 ; G380 is same as G38; lower the hotbed , to prevent the nozzle is below the hotbed
G380 S2 Z-25 F300 ;
G1 Z5 F300;
G90
M17 X1.2 Y1.2 Z0.75 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 5
M221 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem
G29.1 Z{+0.0} ; clear z-trim value first
M204 S10000 ; init ACC set to 10m/s^2

;===== heatbed preheat ====================
M1002 gcode_claim_action : 2
M140 S[bed_temperature_initial_layer_single] ;set bed temp
M190 S[bed_temperature_initial_layer_single] ;wait for bed temp

;{if scan_first_layer}
;=========register first layer scan=====
;M977 S1 P60
;{endif}

;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_no_support_extruder]=="PLA"}
    {if (bed_temperature[initial_no_support_extruder] >45)||(bed_temperature_initial_layer[initial_no_support_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
    M142 P1 R35 S40
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;===== prepare print temperature and material ==========
M104 S[nozzle_temperature_initial_layer] ;set extruder temp
G91
G0 Z10 F1200
G90
G28 X
M975 S1 ; turn on
G1 X60 F12000
G1 Y245
G1 Y265 F3000
M620 M
M620 S[initial_no_support_extruder]A   ; switch material if AMS exist
    M109 S[nozzle_temperature_initial_layer]
    G1 X120 F12000

    G1 X20 Y50 F12000
    G1 Y-3
    T[initial_no_support_extruder]
    G1 X54 F12000
    G1 Y265
    M400
M621 S[initial_no_support_extruder]A
M620.1 E F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_no_support_extruder]}

M412 S1 ; ===turn on filament runout detection===

M109 S250 ;set nozzle to common flush temp
M106 P1 S0
G92 E0
G1 E50 F200
M400
M104 S[nozzle_temperature_initial_layer]
G92 E0
G1 E50 F200
M400
M106 P1 S255
G92 E0
G1 E5 F300
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20} ; drop nozzle temp, make filament shink a bit
G92 E0
G1 E-0.5 F300

G1 X70 F9000
G1 X76 F15000
G1 X65 F15000
G1 X76 F15000
G1 X65 F15000; shake to put down garbage
G1 X80 F6000
G1 X95 F15000
G1 X80 F15000
G1 X165 F15000; wipe and shake
M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1
M106 S255
G1 X65 Y230 F18000
G1 Y264 F6000
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}
G1 X100 F18000 ; first wipe mouth

G0 X135 Y253 F20000  ; move to exposed steel surface edge
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
G0 Z5 F20000

G1 X60 Y265
G92 E0
G1 E-0.5 F300 ; retrack more
G1 X100 F5000; second wipe mouth
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X90 F5000
G0 X128 Y261 Z-1.5 F20000  ; move to exposed steel surface and stop the nozzle
M104 S140 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)

M221 S; push soft endstop status
M221 Z0 ;turn off Z axis endstop
G0 Z0.5 F20000
G0 X125 Y259.5 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 X128
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300

M109 S140 ; wait nozzle temp down to heatbed acceptable
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000

M221 R; pop softend status
G1 Z10 F1200
M400
G1 Z10
G1 F30000
G1 X128 Y128
G29.2 S1 ; turn on ABL
;G28 ; home again after hard wipe mouth
M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================

;===== check scanner clarity ===========================
;G1 X128 Y128 F24000
;G28 Z P0
;M972 S5 P0
;G1 X230 Y15 F24000
;===== check scanner clarity end =======================

;===== bed leveling ==================================
;M1002 judge_flag g29_before_print_flag
;M622 J1
;
;    M1002 gcode_claim_action : 1
;    G29 A X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
;    M400
;    M500 ; save cali data
;
;M623
;===== bed leveling end ===============================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623
;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression

;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_no_support_extruder]=="PLA"}
    {if (bed_temperature[initial_no_support_extruder] >45)||(bed_temperature_initial_layer[initial_no_support_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
    M142 P1 R35 S40
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;M104 S{nozzle_temperature_initial_layer[initial_no_support_extruder]} ; set extrude temp earlier, to reduce wait time

;===== nozzle load line ===============================
M975 S1
G90
M83
T1000
;G1 X18.0 Y1.0 Z0.8 F18000;Move to start position
;M109 S{nozzle_temperature[initial_no_support_extruder]}
;G1 Z0.2
;G0 E2 F300
;G0 X240 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
;G0 Y11 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)/ 4 * 60}
;G0 X239.5
;G0 E0.2
;G0 Y1.5 E0.700
;G0 X231 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
M400

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.07} ; for Textured PEI Plate
{endif}

;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
;M973 S4 ; turn off scanner
;M400 ; wait all motion done before implement the emprical L parameters
;M900 L500.0 ; Empirical parameters
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}; -20 ¬∞C so print already starts and nozzle doesn't ooze unnecessarily
M104 S[nozzle_temperature_initial_layer]  ; let it reach target temperatur while printing
M960 S1 P0 ; turn off laser
M960 S2 P0 ; turn off laser
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression
G90
M83
T1000
;G1 E{-retraction_length[initial_no_support_extruder]} F1800
;G1 X128.0 Y253.0 Z0.2 F24000.0;Move to start position
;G1 E{retraction_length[initial_no_support_extruder]} F1800
;M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]}
;G0 X253 E6.4 F{outer_wall_volumetric_speed/(0.3*0.6)    * 60}
;G0 Y128 E6.4
;G0 X252.5
;G0 Y252.5 E6.4
;G0 X128 E6.4

; ================================== Start Code End ======================================`;

    const X1_START_NO_FLUSH = `;===== machine: X1 ==================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20240528 ==================
;===== start printer sound ================
M17
M400 S1
M1006 S1
M1006 A0 B10 L100 C37 D10 M60 E37 F10 N60
M1006 A0 B10 L100 C41 D10 M60 E41 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A46 B10 L100 C43 D10 M70 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A43 B10 L100 C0 D10 M60 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A41 B10 L100 C0 D10 M100 E41 F10 N100
M1006 A44 B10 L100 C0 D10 M100 E44 F10 N100
M1006 A49 B10 L100 C0 D10 M100 E49 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A48 B10 L100 C44 D10 M60 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A44 B10 L100 C0 D10 M90 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N100
M1006 A46 B10 L100 C43 D10 M60 E39 F10 N100
M1006 W
;===== turn on the HB fan =================
M104 S75 ;set extruder temp to turn on the HB fan and prevent filament oozing from nozzle
;===== reset machine status =================
M290 X40 Y40 Z2.6666666
G91
M17 Z0.4 ; lower the z-motor current
G380 S2 Z30 F300 ; G380 is same as G38; lower the hotbed , to prevent the nozzle is below the hotbed
G380 S2 Z-25 F300 ;
G1 Z5 F300;
G90
M17 X1.2 Y1.2 Z0.75 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 5
M221 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem
G29.1 Z{+0.0} ; clear z-trim value first
M204 S10000 ; init ACC set to 10m/s^2

;===== heatbed preheat ====================
M1002 gcode_claim_action : 2
M140 S[bed_temperature_initial_layer_single] ;set bed temp
M190 S[bed_temperature_initial_layer_single] ;wait for bed temp

;{if scan_first_layer}
;=========register first layer scan=====
;M977 S1 P60
;{endif}

;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_no_support_extruder]=="PLA"}
    {if (bed_temperature[initial_no_support_extruder] >45)||(bed_temperature_initial_layer[initial_no_support_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
    M142 P1 R35 S40
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;===== prepare print temperature and material ==========
M104 S[nozzle_temperature_initial_layer] ;set extruder temp
G91
G0 Z10 F1200
G90
G28 X
M975 S1 ; turn on
G1 X60 F12000
G1 Y245
G1 Y265 F3000
M620 M
M620 S[initial_no_support_extruder]A   ; switch material if AMS exist
    M109 S[nozzle_temperature_initial_layer]
    G1 X120 F12000

    G1 X20 Y50 F12000
    G1 Y-3
    T[initial_no_support_extruder]
    G1 X54 F12000
    G1 Y265
    M400
M621 S[initial_no_support_extruder]A
M620.1 E F{filament_max_volumetric_speed[initial_no_support_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_no_support_extruder]}

M412 S1 ; ===turn on filament runout detection===

;M109 S250 ;set nozzle to common flush temp
;M106 P1 S0
;G92 E0
;G1 E50 F200
;M400
;M104 S[nozzle_temperature_initial_layer]
;G92 E0
;G1 E50 F200
;M400
;M106 P1 S255
;G92 E0
;G1 E5 F300
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20} ; drop nozzle temp, make filament shink a bit
G92 E0
G1 E-0.5 F300

G1 X70 F9000
G1 X76 F15000
G1 X65 F15000
G1 X76 F15000
G1 X65 F15000; shake to put down garbage
G1 X80 F6000
G1 X95 F15000
G1 X80 F15000
G1 X165 F15000; wipe and shake
M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1
M106 S255
G1 X65 Y230 F18000
G1 Y264 F6000
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}
G1 X100 F18000 ; first wipe mouth

G0 X135 Y253 F20000  ; move to exposed steel surface edge
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
G0 Z5 F20000

G1 X60 Y265
G92 E0
G1 E-0.5 F300 ; retrack more
G1 X100 F5000; second wipe mouth
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X90 F5000
G0 X128 Y261 Z-1.5 F20000  ; move to exposed steel surface and stop the nozzle
M104 S140 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)

M221 S; push soft endstop status
M221 Z0 ;turn off Z axis endstop
G0 Z0.5 F20000
G0 X125 Y259.5 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 X128
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300

M109 S140 ; wait nozzle temp down to heatbed acceptable
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000

M221 R; pop softend status
G1 Z10 F1200
M400
G1 Z10
G1 F30000
G1 X128 Y128
G29.2 S1 ; turn on ABL
;G28 ; home again after hard wipe mouth
M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================

;===== check scanner clarity ===========================
;G1 X128 Y128 F24000
;G28 Z P0
;M972 S5 P0
;G1 X230 Y15 F24000
;===== check scanner clarity end =======================

;===== bed leveling ==================================
;M1002 judge_flag g29_before_print_flag
;M622 J1
;
;    M1002 gcode_claim_action : 1
;    G29 A X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
;    M400
;    M500 ; save cali data
;
;M623
;===== bed leveling end ===============================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623
;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression

;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_no_support_extruder]=="PLA"}
    {if (bed_temperature[initial_no_support_extruder] >45)||(bed_temperature_initial_layer[initial_no_support_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
    M142 P1 R35 S40
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;M104 S{nozzle_temperature_initial_layer[initial_no_support_extruder]} ; set extrude temp earlier, to reduce wait time

;===== nozzle load line ===============================
M975 S1
G90
M83
T1000
;G1 X18.0 Y1.0 Z0.8 F18000;Move to start position
;M109 S{nozzle_temperature[initial_no_support_extruder]}
;G1 Z0.2
;G0 E2 F300
;G0 X240 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
;G0 Y11 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)/ 4 * 60}
;G0 X239.5
;G0 E0.2
;G0 Y1.5 E0.700
;G0 X231 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
M400

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.07} ; for Textured PEI Plate
{endif}

;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
;M973 S4 ; turn off scanner
;M400 ; wait all motion done before implement the emprical L parameters
;M900 L500.0 ; Empirical parameters
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}; -20 ¬∞C so print already starts and nozzle doesn't ooze unnecessarily
M104 S[nozzle_temperature_initial_layer]  ; let it reach target temperatur while printing
M960 S1 P0 ; turn off laser
M960 S2 P0 ; turn off laser
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression
G90
M83
T1000
;G1 E{-retraction_length[initial_no_support_extruder]} F1800
;G1 X128.0 Y253.0 Z0.2 F24000.0;Move to start position
;G1 E{retraction_length[initial_no_support_extruder]} F1800
;M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]}
;G0 X253 E6.4 F{outer_wall_volumetric_speed/(0.3*0.6)    * 60}
;G0 Y128 E6.4
;G0 X252.5
;G0 Y252.5 E6.4
;G0 X128 E6.4

; ================================== Start Code End ======================================`;

    // X1 End Code Cutter Sequence (extracted from End_Code_Automatic_Pushoff_X1_V2.txt, lines 1-26)
    // Everything up to and including M104 S0 ; turn off hotend
    const X1_END_CUTTER_SEQUENCE = `;===== date: 20240528 ============ Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
M400 ; wait for buffer to clear
G92 E0 ; zero the extruder
G1 E-0.8 F1800 ; retract
G1 Z{max_layer_z + 0.5} F900 ; lower z a little
G1 X65 Y245 F12000 ; move to safe pos
G1 Y265 F3000

G1 X65 Y245 F12000
G1 Y265 F3000
M140 S0 ; turn off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan

G1 X100 F12000 ; wipe
; pull back filament to AMS
M620 S255
G1 X20 Y50 F12000
G1 Y-3
T255
G1 X65 F12000
G1 Y265
G1 X100 F12000 ; wipe
M621 S255
M104 S0 ; turn off hotend
`;

    // X1 End Sound (from End_Code_Automatic_Pushoff_X1_V2.txt, lines 144-165)
    // P1 End Sound (same as X1, since they share firmware)
    const P1_END_SOUND = `;=====printer finish  sound=========
M17
M400 S1
M1006 S1
M1006 A0 B20 L100 C37 D20 M40 E42 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C46 D10 M80 E46 F10 N80
M1006 A44 B20 L100 C39 D20 M60 E48 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C48 D10 M60 E44 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10  N100
M1006 A49 B20 L100 C44 D20 M100 E41 F20 N100
M1006 A0 B20 L100 C0 D20 M60 E0 F20 N100
M1006 A0 B20 L100 C37 D20 M30 E37 F20 N60
M1006 W

M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power
M960 S5 P0 ; turn off logo lamp
`;

    const X1_END_SOUND = `;=====printer finish  sound=========
M17
M400 S1
M1006 S1
M1006 A0 B20 L100 C37 D20 M40 E42 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C46 D10 M80 E46 F10 N80
M1006 A44 B20 L100 C39 D20 M60 E48 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C48 D10 M60 E44 F10 N100
M1006 A0 B10 L100 C0 D10 M60 E0 F10  N100
M1006 A49 B20 L100 C44 D20 M100 E41 F20 N100
M1006 A0 B20 L100 C0 D20 M60 E0 F20 N100
M1006 A0 B20 L100 C37 D20 M30 E37 F20 N60
M1006 W

M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power
M960 S5 P0 ; turn off logo lamp
`;

    // Printer model configuration
    const PRINTER_MODELS = {
        P1: {
            name: "P1/P1S",
            bedBounds: { minX: 10, maxX: 246, minY: 0, maxY: 256 },
            tempOffset: 0,
            m190Timeout: false,
            requiresClogDetection: false,
            pushAxis: "X", // Gantry-based
            hasBackTab: true,
            zOffsetRule: 30 // max_layer_z - 30
        },
        A1: {
            name: "A1",
            bedBounds: { minX: -48, maxX: 256, minY: 0, maxY: 262 },
            tempOffset: -4, // Subtract 4¬∞C
            m190Timeout: true, // Needs loop
            requiresClogDetection: true, // G392 S0 mandatory
            pushAxis: "Y", // Bed slinger
            hasBackTab: false,
            poopZoneX: -13,
            wiggleXMin: -48,
            wiggleXMax: 256,
            zOffsetRule: 40, // max_layer_z - 40
            requiresClearance: false // Print head parked at X-48, no clearance needed
        },
        A1Mini: {
            name: "A1 Mini",
            bedBounds: { minX: -13, maxX: 180, minY: 0, maxY: 185 },
            tempOffset: -4, // Subtract 4¬∞C (same as A1)
            m190Timeout: true, // Needs loop (same as A1)
            requiresClogDetection: true, // G392 S0 mandatory (same as A1)
            pushAxis: "Y", // Bed slinger (same as A1)
            hasBackTab: false,
            poopZoneX: -13.5,
            wiggleXMin: -13,
            wiggleXMax: 180,
            zOffsetRule: 40, // max_layer_z - 40 (same as A1)
            requiresClearance: true // Requires 50mm clearance to the left
        },
        x1: {
            name: "X1/X1C",
            bedBounds: { minX: 10, maxX: 246, minY: 0, maxY: 256 }, // Same as P1
            tempOffset: 0,
            m190Timeout: false,
            requiresClogDetection: false,
            pushAxis: "X", // Gantry-based (same as P1)
            hasBackTab: true,
            zOffsetRule: 30 // max_layer_z - 30 (same as P1)
        }
    };

    // ============================================================================
    // LOGIC FIREWALL: Strict separation between P1 Engine and A1 Engine
    // ============================================================================
    // CRITICAL SAFETY ARCHITECTURE:
    // - P1 Engine: CoreXY, X-axis push (gantry moves, bed stationary)
    // - A1 Engine: Bed Slinger, Y-axis push (bed moves, gantry stationary)
    // - Zero logic bleed-over between engines
    // - All engine-specific functions MUST validate printer model at entry
    // ============================================================================
    
    // Global printer model state
    let currentPrinterModel = null; // No default - set when file is uploaded or manually selected
    let autoDetectedPrinterModel = null; // Stores auto-detected printer model from 3MF file
    
    /**
     * ============================================================================
     * LOGIC FIREWALL: Strict Engine Validation Guards
     * ============================================================================
     * 
     * PURPOSE: Prevent logic bleed-over between P1 Engine and A1 Engine
     * 
     * ARCHITECTURE:
     * - P1 Engine: CoreXY kinematics, X-axis push (gantry moves, bed stationary)
     *   - Uses: calculateDynamicPushCoordinates(), generateSweepGcode() (P1 path)
     *   - End code: Multi-lane X-axis push system
     *   - Bed bounds: X: 10-246mm, Y: 0-256mm
     * 
     * - A1 Engine: Bed slinger kinematics, Y-axis push (bed moves, gantry stationary)
     *   - Uses: generateA1PushGcode(), generateA1WiggleSweep(), getA1EndCode()
     *   - End code: Single Y-axis push with wiggle sweep
     *   - Bed bounds: X: -48-256mm, Y: 0-262mm
     * 
     * GUARD FUNCTIONS:
     * - FIREWALL_P1_ONLY(): Throws error if called when currentPrinterModel !== 'P1'
     * - FIREWALL_A1_ONLY(): Throws error if called when currentPrinterModel !== 'A1'
     * - FIREWALL_VALIDATE_MODEL(): Validates against allowed models array
     * 
     * USAGE:
     * - Call at function entry point for engine-specific functions
     * - Ensures wrong engine logic cannot execute
     * - Provides clear error messages for debugging
     * 
     * CRITICAL FUNCTIONS PROTECTED:
     * - getEndCode(): Routes to P1/X1 or A1, validates before processing
     * - calculateDynamicPushCoordinates(): P1/X1-only (X-axis multi-lane push)
     * - generateSweepGcode(): Routes to A1 wiggle or P1/X1 full bed sweep
     * - generateA1PushGcode(): A1-only (Y-axis push)
     * - generateA1WiggleSweep(): A1-only (X-48 to X256 wiggle)
     * - getA1EndCode(): A1-only (complete A1 end sequence)
     * - process3MFFile() / processGcodeFile(): Validates end code selection
     * 
     * ============================================================================
     */
    function FIREWALL_P1_ONLY(functionName) {
        if (currentPrinterModel !== 'P1') {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} is P1-only but called with model: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: P1 engine access granted`);
    }
    
    function FIREWALL_A1_ONLY(functionName) {
        if (currentPrinterModel !== 'A1') {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} is A1-only but called with model: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: A1 engine access granted`);
    }
    
    function FIREWALL_A1_A1MINI_ONLY(functionName) {
        if (currentPrinterModel !== 'A1' && currentPrinterModel !== 'A1Mini') {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} is A1/A1Mini-only but called with model: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: ${currentPrinterModel} engine access granted`);
    }
    
    function FIREWALL_X1_ONLY(functionName) {
        if (currentPrinterModel !== 'x1') {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} is X1-only but called with model: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: X1 engine access granted`);
    }
    
    function FIREWALL_P1_X1_ONLY(functionName) {
        if (currentPrinterModel !== 'P1' && currentPrinterModel !== 'x1') {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} is P1/X1-only but called with model: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: ${currentPrinterModel} engine access granted`);
    }
    
    function FIREWALL_VALIDATE_MODEL(functionName, allowedModels) {
        if (!allowedModels.includes(currentPrinterModel)) {
            const error = new Error(`FIREWALL VIOLATION: ${functionName} requires one of [${allowedModels.join(', ')}] but current model is: ${currentPrinterModel}`);
            if (DEBUG_MODE) console.error('[FIREWALL]', error.message);
            throw error;
        }
        if (DEBUG_MODE) console.log(`[FIREWALL] ${functionName}: Model ${currentPrinterModel} validated`);
    }

    // Global: LOCKED TO ENGLISH
    let currentLang = "en";
    let finalFileContent = null; // Can be string (small files) or Blob (large files)
    let originalFilename = "";
    let currentOffset = 30;
    let currentFilamentUsage = "";
    let currentDirection = "center";
    let autoDetectedDirection = null; // Stores the automatically detected direction
    let lastValidationStatus = { key: null, color: null };
    let lastDebugData = null; 
    let currentFileType = "gcode"; // "gcode" or "3mf"
    
    // DOM element cache for performance (cached on page load)
    const DOM = {
        fileInput: null,
        generateBtn: null,
        generateTestBtn: null,
        loopCount: null,
        output: null,
        fileSizeEstimate: null,
        directionWarning: null,
        directionInfo: null,
        placementDebug: null,
        debugOutputContent: null,
        fileValidationStatus: null,
        zOffsetInput: null,
        bedOffsetDisplay: null,
        cooldownTempInput: null,
        showAdvancedSettings: null,
        // Will be initialized on page load
    }; 

    // formatString function removed - was never used

    const LANG = {
        en: { 
            title: "Looprint (Beta)", subtitle: "Automated multi-loop G-code builder for Bambu Lab P1/P1S, X1/X1C, and A1. Supports G-code and 3MF files.",
            step1Title: "1. Upload File",             step1Help: "Upload a G-code file (directly from slicer) or a 3MF file. Start and end code will be added automatically.",
            validationWarning: "‚úì Push direction is automatically detected from model placement.", validationError: "Validation failed: Could not read or parse the file. Please ensure it is a valid G-code or 3MF file.",
            validationErrorLooprint: "Validation failed: This file has already been processed by Looprint. Please upload the original sliced file.",
            validationErrorParse: "Validation failed: Could not read or parse the file content. Ensure it is a valid G-code or 3MF file.",
            validationSuccess: "File verified: Valid G-code or 3MF file detected. Start and end code will be added automatically.", step2Title: "2. Loop Configuration", loopsLabel: "Number of loops", safetyText: "I confirm this file was sliced with Brim enabled.",
            safetyHelp: "", generateBtn: "Generate Loop File", generateTestBtn: "Generate Test File", resetBtn: "Reset to Defaults", 
            outputReady: "Loop File Ready", outputDesc: "Your file has been looped into a single file with push-off sequences between each loop.", statLabelSource: "Source file:", statLabelLoops: "Total loops:",
            statLabelFilament: "Est. Filament usage:", statLabelTime: "Est. Total Print Time:", timeCooldownNote: "(estimate calculated with 60min cooldown per loop)", statLabelFileSize: "Est. File size:", statLabelPushDirection: "Push direction:", statLabelBedTemp: "Target Bed Temp:", statLabelPushOffset: "Z Push Offset:", downloadBtn: "Download Looped File",             footerText: "",
            footerText3MF: "",
            footerNote: "Looprint loops your file and adds push-off sequences between loops. All print settings (temperatures, speeds, etc.) come from your original file. Start and end code are added automatically for all file types (G-code and 3MF).",
            resourcesLink: "", 
            endSectionTitle: "3. Push-off Configuration (Advanced)",
            endSectionHelp: "Push direction is automatically detected from your file. You can click the zones in the bed preview below to change it manually. Note: In simple mode, push direction is locked to the auto-detected value. In advanced mode, you can change it but will see a warning if it differs from the auto-detected direction.",
            cooldownTempLabel: "Target Bed Temp (¬∞C)", cooldownHelp: "Default 18¬∞C (Approx. 23¬∞C on the plate). Wait max 60 min.", cooldownRiskWarning: `Warning: Target > ${COOLDOWN_WARNING_THRESHOLD}¬∞C increases risk of sticking.`,
            zOffsetLabel: "Z Push Offset (mm)", zOffsetApply: "Apply", zOffsetHelp: "Default 30mm below top (P1). A1 Factorian logic uses 40mm in the automated calculation.", zOffsetWarning: "‚ö†Ô∏è Advanced: Incorrect values can cause collisions.",
            zOffsetErrorRange: "Offset must be between 5 mm and 120 mm.", zOffsetApplied: "Offset updated.", selectDirectionLabel: "Selected Push Direction:",
            optLeft: "Left", optCenter: "Center", optRight: "Right", endCenterTitle: "Center Push End G-code", endCenterDesc: "Pushes model from center zone towards front. Z height calculated automatically.",
            endRightTitle: "Right Push End G-code", endRightDesc: "Pushes model from right zone towards front. Z height calculated automatically.", endLeftTitle: "Left Push End G-code", endLeftDesc: "Pushes model from left zone towards front. Z height calculated automatically.",
            copyBtn: "Copy G-code", fileError: "Please select a G-code or 3MF file.", loopsError: "Please enter a valid loop count (at least 1).", loopsTooManyError: "Too many loops. Maximum recommended: 50. Large files may cause memory issues.", skirtError: "Safety check failed: You must confirm that Brim was enabled.",
            fileEmptyError: "The uploaded file appears to be empty or unreadable.", copySuccess: "Copied!", copyError: "Failed to copy.", bedPreviewTitle: "Bed Preview & Model Placement",
            bedPreviewText: "The zone with the green border is the selected push direction. In advanced mode, you can click any zone to change it after file upload.", bedPreviewFront: "FRONT", bedPreviewBack: "BACK", bedPreviewLeft: "LEFT", bedPreviewRight: "RIGHT",
            bedZoneCenter: "Center", bedZoneRight: "Right", bedZoneLeft: "Left", bedPreviewOffsetLabel: "Z push offset:", bedPreviewOffsetSuffix: "below top of print",
            debugHeaderTitle: "üìç Model Placement Analysis:",
            debugInfoTooFew: 'Too few G-code data points found (Need >50). Defaulted to Center.',
            debugInfoFiltered: 'All data points filtered out. Defaulted to Center.',
            debugInfoOverlap: 'Model width: %s. Overlap -> Left: %smm, Center: %smm, Right: %smm.',
            debugInfoWinner: 'Zone "%s" has the most model overlap. Selected.',
            zoneLeft: "Left", zoneCenter: "Center", zoneRight: "Right",
            debugInfoDedicatedRight: 'Model is fully located in the RIGHT zone (minX: %s > 166).',
            debugInfoDedicatedLeft: 'Model is fully located in the LEFT zone (maxX: %s < 90).',
            debugZoneSelection: 'Selected Zone:',
        }
    };

    /**
     * Applies English text to all elements with data-lang attribute
     */
    function applyEnglishText() {
        const dict = LANG.en;
        document.querySelectorAll("[data-lang]").forEach(el => {
            const key = el.getAttribute("data-lang");
            const value = dict[key] || key;
            // Special handling for footerNote to preserve HTML link
            if (key === "footerNote" && value.includes("<a ")) {
                el.innerHTML = value;
            } else {
                el.textContent = value;
            }
        });
    }
    
    /**
     * Toggles visibility of advanced settings section
     */
    function toggleAccordion(header) {
        const accordion = header.closest('.printer-accordion');
        const content = accordion.querySelector('.printer-accordion-content');
        const isActive = header.classList.contains('active');
        
        // Toggle current accordion
        if (isActive) {
            header.classList.remove('active');
            content.classList.remove('active');
        } else {
            header.classList.add('active');
            content.classList.add('active');
        }
    }
    
    function expandAllAccordions() {
        const headers = document.querySelectorAll('.printer-accordion-header');
        headers.forEach(header => {
            if (!header.classList.contains('active')) {
                header.classList.add('active');
                header.closest('.printer-accordion').querySelector('.printer-accordion-content').classList.add('active');
            }
        });
    }
    
    function collapseAllAccordions() {
        const headers = document.querySelectorAll('.printer-accordion-header');
        headers.forEach(header => {
            if (header.classList.contains('active')) {
                header.classList.remove('active');
                header.closest('.printer-accordion').querySelector('.printer-accordion-content').classList.remove('active');
            }
        });
    }
    
    function toggleAdvancedSettings() {
        const checkbox = document.getElementById("showAdvancedSettings");
        const advancedSection = document.getElementById("endCodeSection");
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const debugEl = document.getElementById("placementDebug");
        
        if (checkbox.checked) {
            advancedSection.classList.add("advanced-visible");
            // Update visibility of printer-specific controls (e.g., A1 Negative Z container)
            // This ensures correct visibility when Advanced Settings opens
            handlePrinterModelChange();
            // Update start code textarea
            // If file is uploaded, try to get G-code content from file input
            const fileInput = DOM.fileInput || document.getElementById("fileInput");
            if (fileInput.files.length > 0 && autoDetectedDirection !== null) {
                // File is uploaded - read it and update start code with variables
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    updateStartCodeTextarea(e.target.result);
                };
                reader.readAsText(file);
            } else {
                // No file uploaded - show template
                updateStartCodeTextarea(null);
            }
            // In advanced mode, unlock bed preview if file is uploaded (user can change it)
            // But keep it locked if we're in simple mode (auto-detected)
            if (autoDetectedDirection !== null) {
                // File is uploaded - unlock in advanced mode so user can change
                bedPreviewContainer.classList.remove('locked');
                updateDirectionInfo();
                // Show debug info if available
                if (lastDebugData && debugEl) {
                    debugEl.style.display = "block";
                }
            }
        } else {
            advancedSection.classList.remove("advanced-visible");
            // In simple mode, always lock bed preview after file upload
            if (autoDetectedDirection !== null) {
                bedPreviewContainer.classList.add('locked');
            }
            // Hide warnings and debug when hiding advanced (but keep directionInfo visible)
            document.getElementById("directionWarning").style.display = "none";
            // directionInfo should still be visible in simple mode to show auto-detected direction
            if (debugEl) debugEl.style.display = "none";
            // Update direction info to show auto-detected message
            updateDirectionInfo();
        }
        
        // Save preference to localStorage
        try {
            localStorage.setItem('looprint_showAdvanced', checkbox.checked ? 'true' : 'false');
        } catch (e) {
            if (DEBUG_MODE) console.warn("Could not save advanced settings preference:", e);
        }
    }
    
    /**
     * Toggles visibility of sweep settings based on checkbox state
     */
    function toggleSweepSettings() {
        const enableSweep = document.getElementById("enableSweep");
        const sweepSettings = document.getElementById("sweepSettings");
        const sweepTestBtn = document.getElementById("generateSweepTestBtn");
        const sweepIndicator = document.getElementById("sweepIndicator");
        
        if (enableSweep && sweepSettings) {
            sweepSettings.style.display = enableSweep.checked ? 'block' : 'none';
        }
        
        // Show/hide sweep indicator in bed preview
        if (sweepIndicator && enableSweep) {
            sweepIndicator.style.display = enableSweep.checked ? 'block' : 'none';
        }
        
        // Show/hide sweep test button based on sweep being enabled
        if (sweepTestBtn) {
            // Only show if sweep is enabled AND a file has been uploaded (test button is visible)
            const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
            const fileUploaded = testBtn && testBtn.style.display !== 'none';
            sweepTestBtn.style.display = (enableSweep && enableSweep.checked && fileUploaded) ? 'inline-block' : 'none';
        }
    }
    
    /**
     * Generates G-code for full bed sweep
     * Always runs 7 passes: SAFE one-way back-to-front pattern
     * Safety: Lifts before returning to avoid dragging debris into printer mechanics
     * @param {number} zHeight - Z height for sweep (mm above bed, default 1mm)
     * @param {number} speed - Speed of sweep motion (mm/min)
     * @returns {string} Generated sweep G-code
     */
    function generateSweepGcode(zHeight = DEFAULT_SWEEP_Z, speed = DEFAULT_SWEEP_SPEED) {
        try {
            // LOGIC FIREWALL: Strict routing - A1 must use generateA1WiggleSweep, never fall through to P1 logic
            if (currentPrinterModel === 'A1') {
                return generateA1WiggleSweep(zHeight, speed);
            }
            
            if (currentPrinterModel === 'A1Mini') {
                return generateA1MiniWiggleSweep(zHeight, speed);
            }
            
            // LOGIC FIREWALL: P1/X1 path - validate we're actually P1 or X1
            FIREWALL_P1_X1_ONLY('generateSweepGcode');
            
            // Validate inputs
            speed = Math.max(MIN_SWEEP_SPEED, Math.min(MAX_SWEEP_SPEED, parseFloat(speed) || DEFAULT_SWEEP_SPEED));
            zHeight = Math.max(MIN_SWEEP_Z, Math.min(MAX_SWEEP_Z, parseFloat(zHeight) || DEFAULT_SWEEP_Z));
            
            // Use fixed Z height for sweep (default 1mm - bed level)
            const zPositionLow = `G1 Z${zHeight.toFixed(1)} F600`;
            
            // Calculate Z position for lift (5mm above sweep height for safety)
            const zPositionLift = `G1 Z${(zHeight + 5).toFixed(1)} F600`;
            
            // Calculate sweep parameters - always 7 passes across X-axis
            // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
            const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
            const bedMinX = bedBounds.minX || 10;
            const bedMaxX = bedBounds.maxX || 246;
            const bedMinY = bedBounds.minY || 0;
            const bedMaxY = bedBounds.maxY || 256;
            
            if (DEBUG_MODE) console.log("[DIAG] generateSweepGcode: Using bed bounds for", currentPrinterModel, "- X:", bedMinX, "-", bedMaxX, "Y:", bedMinY, "-", bedMaxY);
            
            // Use safe bed boundaries to avoid filament cutter on left and right edges
            const NUM_PASSES = 7;
            const frontY = Math.max(bedMinY, 10);  // Front edge (10mm from front, or bedMinY if larger)
            const backY = bedMaxY;   // Back edge
            const safeBedWidth = bedMaxX - bedMinX; // Safe bed width
            const xSpacing = safeBedWidth / (NUM_PASSES - 1); // Spacing between X passes
            
            if (DEBUG_MODE) console.log("[DIAG] generateSweepGcode: Sweep parameters - frontY:", frontY, "backY:", backY, "safeBedWidth:", safeBedWidth, "xSpacing:", xSpacing);
            
            // Calculate X positions for all 7 passes (left to right, within safe boundaries)
            const xPositions = [];
            for (let i = 0; i < NUM_PASSES; i++) {
                xPositions.push(bedMinX + (i * xSpacing)); // Start from bedMinX
            }
            
            // Generate sweep G-code
            let sweepCode = `; --- FULL BED SWEEP (Looprint) ---
; SAFE one-way back-to-front pattern (7 passes across X-axis)
; Pattern: Lift ‚Üí Rapid return to back (in air) ‚Üí Drop ‚Üí Push forward slowly
; Speed: ${speed}mm/min (forward push), F12000 (rapid return in air)
M400 ; Wait for all motion to complete
G1 E-0.5 F300 ; Retract filament slightly
${zPositionLow} ; Move to bed level (as low as possible)
M400 ; Wait for motion to complete

; Start at back-left position
G1 X${xPositions[0].toFixed(1)} Y${backY} F5000 ; Move to start position (left edge, back)
`;
            
            // Generate sweep passes: Each pass follows "Lift-Return-Drop-Push" cycle
            // Pattern: Always push back-to-front (Y=256 to Y=10) to avoid dragging debris
            for (let i = 0; i < NUM_PASSES; i++) {
                const xPos = xPositions[i];
                
                // Pass ${i + 1}: Push forward from back to front (one-way only)
                sweepCode += `; --- PASS ${i + 1}/${NUM_PASSES} (X=${xPos.toFixed(1)}) ---
G1 X${xPos.toFixed(1)} Y${backY} F${speed} ; Position at back
G1 X${xPos.toFixed(1)} Y${frontY} F${speed} ; PUSH: Forward from back to front (slow, clears debris)
`;
                
                // If not last pass, return to back in straight line, then move to next X position
                if (i < NUM_PASSES - 1) {
                    const nextX = xPositions[i + 1];
                    sweepCode += `G1 X${xPos.toFixed(1)} Y${backY} F12000 ; RETURN: Move back to back edge in straight line (same X, fast)
M400 ; Wait for return to complete
G1 X${nextX.toFixed(1)} Y${backY} F12000 ; SHIFT: Move to next X position at back (fast)
M400 ; Wait for shift to complete
`;
                }
            }
            
            // Final return to safe position
            sweepCode += `G1 X${bedMinX} Y${frontY} F12000 ; Return to safe left position at front (avoids filament cutter)
M400 ; Wait for all motion to complete
; --- END FULL BED SWEEP ---
`;
            
            return sweepCode;
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in generateSweepGcode:", error);
            return ""; // Return empty string on error
        }
    }
    
    /**
     * Updates direction info/warning messages
     * Uses textContent/createElement to prevent XSS
     */
    function updateDirectionInfo() {
        const directionWarning = DOM.directionWarning || document.getElementById("directionWarning");
        const directionInfo = DOM.directionInfo || document.getElementById("directionInfo");
        
        // A1/A1Mini doesn't have push direction - hide info/warning
        if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
            directionWarning.style.display = "none";
            directionInfo.style.display = "none";
            return;
        }
        
        if (autoDetectedDirection === null) {
            // No file uploaded yet
            directionWarning.style.display = "none";
            directionInfo.style.display = "none";
            return;
        }
        
        const isAdvanced = (DOM.showAdvancedSettings || document.getElementById("showAdvancedSettings")).checked;
        
        // Clear existing content
        directionWarning.textContent = '';
        directionInfo.textContent = '';
        
        if (currentDirection === autoDetectedDirection) {
            // Matches auto-detected - show info in both simple and advanced mode
            directionWarning.style.display = "none";
            directionInfo.style.display = "block";
            
            // Use createElement for safe HTML insertion
            const icon = document.createTextNode("‚ÑπÔ∏è ");
            const strong = document.createElement("strong");
            strong.textContent = "Auto-detected: ";
            const text = document.createTextNode(`Push direction "${autoDetectedDirection}" was automatically set based on model placement.`);
            directionInfo.appendChild(icon);
            directionInfo.appendChild(strong);
            directionInfo.appendChild(text);
        } else {
            // Changed from auto-detected - only show warning in advanced mode
            if (isAdvanced) {
                directionWarning.style.display = "block";
                directionInfo.style.display = "none";
                
                // Use createElement for safe HTML insertion
                const icon = document.createTextNode("‚ö†Ô∏è ");
                const strong = document.createElement("strong");
                strong.textContent = "Warning: ";
                const text = document.createTextNode(`Auto-detected direction was "${autoDetectedDirection}", but you've changed it to "${currentDirection}". Make sure this matches your model placement.`);
                directionWarning.appendChild(icon);
                directionWarning.appendChild(strong);
                directionWarning.appendChild(text);
            } else {
                // In simple mode, if direction was changed (shouldn't happen, but just in case), show info
                directionWarning.style.display = "none";
                directionInfo.style.display = "block";
                
                const icon = document.createTextNode("‚ÑπÔ∏è ");
                const strong = document.createElement("strong");
                strong.textContent = "Auto-detected: ";
                const text = document.createTextNode(`Push direction "${autoDetectedDirection}" was automatically set based on model placement.`);
                directionInfo.appendChild(icon);
                directionInfo.appendChild(strong);
                directionInfo.appendChild(text);
            }
        }
    }

    /**
     * Validates and sets input value from localStorage
     * @param {string} inputId - ID of input element
     * @param {string} savedValue - Value from localStorage
     * @param {number} min - Minimum allowed value
     * @param {number} max - Maximum allowed value
     * @param {number} defaultValue - Default value if validation fails
     * @returns {number} The validated value
     */
    function validateAndSetInput(inputId, savedValue, min, max, defaultValue) {
        const input = document.getElementById(inputId);
        if (!input) return defaultValue;
        
        const numValue = parseFloat(savedValue);
        if (!isNaN(numValue) && numValue >= min && numValue <= max) {
            input.value = numValue;
            return numValue;
        } else {
            input.value = defaultValue;
            return defaultValue;
        }
    }

    /**
     * Formats bytes to human readable size
     * @param {number} bytes - Size in bytes
     * @returns {string} Formatted size string
     */
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
    }
    
    /**
     * Updates file size estimate display
     * Uses safe DOM manipulation to prevent XSS
     */
    function updateFileSizeEstimate() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const estimateEl = document.getElementById("fileSizeEstimate");
        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
        const loopCount = parseInt(loopCountEl.value, 10) || DEFAULT_LOOPS;
        
        if (!fileInput.files.length) {
            estimateEl.style.display = "none";
            return;
        }
        
        const file = fileInput.files[0];
        const fileSize = file.size;
        const estimatedSize = fileSize * loopCount;
        
        // Add some overhead for headers and end codes
        const overheadFactor = currentFileType === "3mf" ? FILE_SIZE_ESTIMATE_3MF_OVERHEAD : FILE_SIZE_OVERHEAD_FACTOR;
        const estimatedWithOverhead = estimatedSize * overheadFactor;
        
        // Use textContent for safety (formatFileSize is safe, but avoid innerHTML)
        estimateEl.textContent = '';
        const strong = document.createElement("strong");
        strong.textContent = "Estimated output: ";
        const text = document.createTextNode(`~${formatFileSize(estimatedWithOverhead)} (${loopCount} loops √ó ${formatFileSize(fileSize)})`);
        estimateEl.appendChild(strong);
        estimateEl.appendChild(text);
        estimateEl.style.display = "block";
    }
    
    /**
     * Sets up drag and drop functionality for file upload
     * Handles dragenter, dragover, dragleave, and drop events
     */
    function setupDragAndDrop() {
        const uploadArea = document.getElementById("fileUploadArea");
        const fileInput = document.getElementById("fileInput");
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('drag-over');
            }, false);
        });
        
        uploadArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                fileInput.files = files;
                validateFileImmediate();
            }
        }, false);
    }

    /**
     * Initialize DOM cache for performance
     * Caches all frequently accessed DOM elements
     */
    function initDOMCache() {
        DOM.fileInput = document.getElementById("fileInput");
        DOM.generateBtn = document.getElementById("generateBtn");
        DOM.generateTestBtn = document.getElementById("generateTestBtn");
        DOM.loopCount = document.getElementById("loopCount");
        DOM.output = document.getElementById("output");
        DOM.fileSizeEstimate = document.getElementById("fileSizeEstimate");
        DOM.directionWarning = document.getElementById("directionWarning");
        DOM.directionInfo = document.getElementById("directionInfo");
        DOM.placementDebug = document.getElementById("placementDebug");
        DOM.debugOutputContent = document.getElementById("debugOutputContent");
        DOM.fileValidationStatus = document.getElementById("fileValidationStatus");
        DOM.zOffsetInput = document.getElementById("zOffsetInput");
        DOM.bedOffsetDisplay = document.getElementById("bedOffsetDisplay");
        DOM.cooldownTempInput = document.getElementById("cooldownTempInput");
        DOM.showAdvancedSettings = document.getElementById("showAdvancedSettings");
    }

    window.onload = function() {
        initDOMCache();
        // --- LOCKED TO ENGLISH ---
        applyEnglishText();
        // Footer text will be shown when a file is uploaded
        
        // Don't load saved printer model on page load - start neutral
        // Printer model will be set when file is uploaded (auto-detected) or manually selected
        const modelSelect = document.getElementById("printerModel");
        if (modelSelect) {
            modelSelect.value = ""; // No default selection
        }
        
        try {
            const savedLoops = localStorage.getItem('looprint_loops');
            const savedTemp = localStorage.getItem('looprint_temp');
            const savedOffset = localStorage.getItem('looprint_offset');
            const savedPushLaneOffset = localStorage.getItem('looprint_pushLaneOffset');

            // Validate and set values with proper bounds checking
            validateAndSetInput("loopCount", savedLoops, 1, MAX_LOOPS, DEFAULT_LOOPS);
            validateAndSetInput("cooldownTempInput", savedTemp, MIN_TEMP, MAX_TEMP, DEFAULT_TEMP);
            
            if (savedOffset) {
                const offset = parseFloat(savedOffset);
                if (!isNaN(offset) && offset >= MIN_OFFSET && offset <= MAX_OFFSET) {
                    document.getElementById("zOffsetInput").value = offset;
                    currentOffset = offset;
                    document.getElementById("bedOffsetDisplay").textContent = offset;
                } else {
                    // Reset to default if invalid
                    document.getElementById("zOffsetInput").value = DEFAULT_OFFSET;
                    currentOffset = DEFAULT_OFFSET;
                    document.getElementById("bedOffsetDisplay").textContent = DEFAULT_OFFSET;
                }
            }
            
            // Load push lane offset
            if (savedPushLaneOffset) {
                const pushLaneOffset = parseFloat(savedPushLaneOffset);
                if (!isNaN(pushLaneOffset) && pushLaneOffset >= MIN_PUSH_LANE_OFFSET && pushLaneOffset <= MAX_PUSH_LANE_OFFSET) {
                    const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                    if (pushLaneOffsetInput) {
                        pushLaneOffsetInput.value = pushLaneOffset;
                    }
                }
            }
            
            // Load push-off speed
            const savedPushSpeed = localStorage.getItem('looprint_pushSpeed');
            const pushSpeedInput = document.getElementById("pushSpeedInput");
            if (pushSpeedInput && savedPushSpeed) {
                const pushSpeed = parseFloat(savedPushSpeed);
                if (!isNaN(pushSpeed) && pushSpeed >= MIN_PUSH_SPEED && pushSpeed <= MAX_PUSH_SPEED) {
                    pushSpeedInput.value = pushSpeed;
                }
            }
            
            // Load sweep settings
            const savedEnableSweep = localStorage.getItem('looprint_enableSweep');
            const savedSweepSpeed = localStorage.getItem('looprint_sweepSpeed');
            const savedSweepZ = localStorage.getItem('looprint_sweepZ');
            
            const enableSweep = document.getElementById("enableSweep");
            const sweepSpeedInput = document.getElementById("sweepSpeedInput");
            const sweepZInput = document.getElementById("sweepZInput");
            
            if (enableSweep && savedEnableSweep === 'true') {
                enableSweep.checked = true;
                toggleSweepSettings();
            }
            
            if (sweepSpeedInput && savedSweepSpeed) {
                const speed = parseFloat(savedSweepSpeed);
                if (!isNaN(speed) && speed >= MIN_SWEEP_SPEED && speed <= MAX_SWEEP_SPEED) {
                    sweepSpeedInput.value = speed;
                }
            }
            
            if (sweepZInput && savedSweepZ) {
                const zHeight = parseFloat(savedSweepZ);
                if (!isNaN(zHeight) && zHeight >= MIN_SWEEP_Z && zHeight <= MAX_SWEEP_Z) {
                    sweepZInput.value = zHeight;
                }
            }
            
            // Load A1 Negative Z setting
            const savedEnableA1NegativeZ = localStorage.getItem('looprint_enableA1NegativeZ');
            const enableA1NegativeZ = document.getElementById('enableA1NegativeZ');
            if (enableA1NegativeZ && savedEnableA1NegativeZ === 'true') {
                enableA1NegativeZ.checked = true;
            }
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully - defaults will be used
            if (DEBUG_MODE) console.warn("Could not load settings from localStorage:", e);
        }

        setupDragAndDrop();
        updateEndCodeTextareas();
        updateStartCodeTextarea(null); // Show template on page load
        checkCooldownWarning();
        toggleSweepSettings(); // Initialize sweep settings visibility
        selectDirection('center', false);
            (DOM.generateBtn || document.getElementById("generateBtn")).disabled = true;
        document.getElementById("bedPreviewContainer").classList.remove('locked');
        autoDetectedDirection = null; // Reset on page load
        
        // Initialize bed preview visualization (will hide everything since no printer model selected)
        updatePreview();
        
        // Initialize push direction controls visibility (will hide everything since no printer model selected)
        handlePrinterModelChange();
        
        // Update Factorian links on page load (defaults to P1/X1 link)
        updateFactorianLinks();
        
        // Redraw A1 canvas on window resize for crisp rendering
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                    drawBedPreview();
                }
            }, 100);
        });
        
        // Load advanced settings preference
        try {
            const showAdvanced = localStorage.getItem('looprint_showAdvanced');
            if (showAdvanced === 'true') {
                document.getElementById("showAdvancedSettings").checked = true;
                toggleAdvancedSettings();
            }
        } catch (e) {
            if (DEBUG_MODE) console.warn("Could not load advanced settings preference:", e);
        }
        
        // Update file size estimate when loop count changes
        document.getElementById("loopCount").addEventListener('input', updateFileSizeEstimate);
    };

    function updateValidationStatusText() {
        const statusEl = document.getElementById("fileValidationStatus");
        const dict = LANG.en;

        if (statusEl.style.display !== "none" && lastValidationStatus.key) {
            statusEl.textContent = dict[lastValidationStatus.key] || lastValidationStatus.key;
            statusEl.style.color = lastValidationStatus.color;
        }
    }

    /**
     * Renders debug text for model placement analysis
     * Uses safe DOM methods to prevent XSS
     */
    function renderDebugText() {
        if (!lastDebugData) return;
        
        const dict = LANG.en;
        const debugOutput = document.getElementById("debugOutputContent");
        
        // Clear existing content safely
        if (!debugOutput) return; // Exit if element doesn't exist
        
        debugOutput.textContent = '';
        
        let minX = lastDebugData.minX.toFixed(1);
        let maxX = lastDebugData.maxX.toFixed(1);
        
        let headerLine = `Min X: ${minX}, Max X: ${maxX}`;

        if (lastDebugData.infoKey === 'debugInfoTooFew' || lastDebugData.infoKey === 'debugInfoFiltered') {
            // Simple case: just text
            const resultLine = dict[lastDebugData.infoKey] || lastDebugData.infoKey;
            debugOutput.textContent = `${headerLine}\n${resultLine}`;
        } else {
            // Complex case: need to show zone name with formatting
            let zoneKey = 'zone' + lastDebugData.direction.charAt(0).toUpperCase() + lastDebugData.direction.slice(1);
            let zoneNameTranslated = dict[zoneKey] || lastDebugData.direction;
            
            // Create elements safely to avoid XSS
            const headerText = document.createTextNode(headerLine);
            const br = document.createElement('br');
            const selectionText = document.createTextNode(dict.debugZoneSelection + ' ');
            const strong = document.createElement('strong');
            strong.textContent = zoneNameTranslated;
            
            debugOutput.appendChild(headerText);
            debugOutput.appendChild(br);
            debugOutput.appendChild(selectionText);
            debugOutput.appendChild(strong);
        }
    }

    /**
     * Saves current settings to localStorage
     */
    function saveSettings() {
        try {
            localStorage.setItem('looprint_loops', document.getElementById("loopCount").value);
            localStorage.setItem('looprint_temp', document.getElementById("cooldownTempInput").value);
            localStorage.setItem('looprint_offset', document.getElementById("zOffsetInput").value);
            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
            if (pushLaneOffsetInput) {
                localStorage.setItem('looprint_pushLaneOffset', pushLaneOffsetInput.value);
            }
            // Save push-off speed
            const pushSpeedInput = document.getElementById("pushSpeedInput");
            if (pushSpeedInput) {
                localStorage.setItem('looprint_pushSpeed', pushSpeedInput.value);
            }
            // Save sweep settings
            const enableSweep = document.getElementById("enableSweep");
            const sweepSpeedInput = document.getElementById("sweepSpeedInput");
            const sweepZInput = document.getElementById("sweepZInput");
            if (enableSweep) {
                localStorage.setItem('looprint_enableSweep', enableSweep.checked ? 'true' : 'false');
            }
            if (sweepSpeedInput) {
                localStorage.setItem('looprint_sweepSpeed', sweepSpeedInput.value);
            }
            if (sweepZInput) {
                localStorage.setItem('looprint_sweepZ', sweepZInput.value);
            }
            // Save A1 Negative Z setting
            const enableA1NegativeZ = document.getElementById('enableA1NegativeZ');
            if (enableA1NegativeZ) {
                localStorage.setItem('looprint_enableA1NegativeZ', enableA1NegativeZ.checked ? 'true' : 'false');
            }
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully - settings just won't persist
            if (DEBUG_MODE) console.warn("Could not save settings to localStorage:", e);
        }
    }
    
    /**
     * Selects push direction and updates UI accordingly
     * @param {string} dir - Direction: 'left', 'center', or 'right'
     * @param {boolean} updateCode - Whether to update end code textareas
     * @param {boolean} isAutoDetected - Whether this is from auto-detection
     */
    function selectDirection(dir, updateCode = true, isAutoDetected = false) {
        // Check if bed preview is locked (in simple mode after file upload)
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const isAdvanced = document.getElementById("showAdvancedSettings").checked;
        
        if (bedPreviewContainer.classList.contains('locked') && !isAdvanced && !isAutoDetected) {
            // In simple mode and locked - don't allow manual changes
            return;
        }
        
        currentDirection = dir;
        
        // Store auto-detected direction
        if (isAutoDetected) {
            autoDetectedDirection = dir;
        }
        
        document.querySelectorAll('.bed-zone').forEach(el => el.classList.remove('active'));
        document.getElementById('zone-' + dir).classList.add('active');

        document.querySelectorAll('.push-option').forEach(el => el.classList.remove('active'));
        document.getElementById('opt-' + dir).classList.add('active');
        
        const blocks = {
            left: document.getElementById('block-left'),
            center: document.getElementById('block-center'),
            right: document.getElementById('block-right')
        };
        
        Object.values(blocks).forEach(el => {
            el.classList.remove('active');
            el.classList.add('disabled');
        });
        
        if (blocks[dir]) {
            blocks[dir].classList.remove('disabled');
            blocks[dir].classList.add('active');
        }

        if (updateCode) {
            updateEndCodeTextareas();
        }
        
        // Update direction info/warning if in advanced mode
        if (isAdvanced) {
            updateDirectionInfo();
        }
    }
    
    /**
     * Parses time string (e.g., "2h 30m 15s") to total seconds
     * @param {string} timeStr - Time string to parse
     * @returns {number} Total seconds
     */
    function parseTimeStringToSeconds(timeStr) {
        let totalSeconds = 0;
        const dMatch = timeStr.match(/(\d+)d/);
        const hMatch = timeStr.match(/(\d+)h/);
        const mMatch = timeStr.match(/(\d+)m/);
        const sMatch = timeStr.match(/(\d+)s/);

        if (dMatch) totalSeconds += parseInt(dMatch[1]) * 86400;
        if (hMatch) totalSeconds += parseInt(hMatch[1]) * 3600;
        if (mMatch) totalSeconds += parseInt(mMatch[1]) * 60;
        if (sMatch) totalSeconds += parseInt(sMatch[1]);
        
        return totalSeconds;
    }

    /**
     * Formats total seconds to human-readable time string
     * @param {number} totalSeconds - Total seconds
     * @returns {string} Formatted time string (e.g., "2h 30m")
     */
    function formatSecondsToTime(totalSeconds) {
        const d = Math.floor(totalSeconds / 86400);
        totalSeconds %= 86400;
        const h = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        const m = Math.floor(totalSeconds / 60);
        const s = Math.round(totalSeconds % 60);

        let result = "";
        if (d > 0) result += `${d}d `;
        if (h > 0) result += `${h}h `;
        if (m > 0) result += `${m}m `;
        
        if (d === 0 && h === 0) {
            result += `${s}s`;
        } else if (result === "") {
             result += "0s";
        }

        return result.trim();
    }
    
    /**
     * Determines model placement on print bed based on G-code coordinates
     * Optimized for large files with line-by-line parsing
     * @param {string} gcode - The G-code file content
     * @returns {Object} Placement result with direction, coordinates, and debug info
     * @property {string} direction - 'left', 'center', or 'right'
     * @property {number} minX - Minimum X coordinate found
     * @property {number} maxX - Maximum X coordinate found
     * @property {string} infoKey - Debug information key for display
     */
    function determineModelPlacement(gcode) {
        const xCoords = [];
        const yCoords = [];
        let yCoordsFound = 0;
        let yCoordsFiltered = 0;
        let lines = null;
        
        // For store filer: Parse linje-for-linje i stedet for kompleks regex p√• hele filen
        // Optimized: Only parse first portion of file (model placement is typically early)
        try {
            lines = gcode.split('\n');
            const MAX_LINES = Math.min(lines.length, MAX_PLACEMENT_PARSE_LINES);
            
            // CRITICAL: Ensure currentPrinterModel is set before using it
            if (!currentPrinterModel) {
                if (DEBUG_MODE) console.warn("[DIAG] determineModelPlacement: currentPrinterModel is null! Using P1 bounds as fallback");
                currentPrinterModel = "P1"; // Fallback to P1 if not set
            }
            
            // Get correct Y-range based on printer model (needed for Y coordinate collection)
            const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
            const minYRange = bedBounds.minY || 0;
            const maxYRange = bedBounds.maxY || 256;
            
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: Collecting Y coordinates for printer model:", currentPrinterModel, "Y-range:", minYRange, "-", maxYRange);
            
            for (let i = 0; i < MAX_LINES; i++) {
                const line = lines[i].trim();
                
                // Hurtig check: Skip linjer der ikke starter med G0 eller G1
                if (!line.startsWith('G0') && !line.startsWith('G1')) continue;
                
                // Check om linjen har X, Y og E koordinater
                if (!line.includes('X') || !line.includes('Y') || !line.includes('E')) continue;
                
                // Parse koordinater
                const xMatch = line.match(/X([\d\.]+)/);
                if (!xMatch) continue;
                
                const zMatch = line.match(/Z([\d\.]+)/);
                const eMatch = line.match(/E([\d\.-]+)/);
                const yMatch = line.match(/Y([\d\.]+)/);

                const zValue = zMatch ? parseFloat(zMatch[1]) : 0;
                const eValue = eMatch ? parseFloat(eMatch[1]) : 0;

                // Vi inkluderer linjen, hvis:
                // 1. Z-h√∏jden er over threshold (langt over start purge)
                // 2. E-v√¶rdien er positiv (det er en reel ekstrudering/printlinje), uanset Z-h√∏jde
                if (zValue > Z_FILTER_THRESHOLD || eValue > 0) {
                    const xValue = parseFloat(xMatch[1]);
                    if (!isNaN(xValue)) {
                        // CRITICAL: Filter out purge lines and start code coordinates
                        // Enhanced filtering to exclude wipe sequences and start code movements
                        const yValue = yMatch ? parseFloat(yMatch[1]) : null;
                        
                        // Filter criteria for start code/wipe sequences:
                        // 1. Negative Z values (wipe sequences typically have Z < 0)
                        // 2. High Y values (Y > 250 typically for wipe sequences)
                        // 3. Common wipe X positions in first 5000 lines (X65, X100, X165)
                        //    NOTE: X128 is NOT filtered alone - it can be model center for center-placed models!
                        //    But if X128 is combined with high Y (>250) or negative Z, it's likely a wipe sequence
                        // 4. Low X values in first 2000 lines (purge lines)
                        // 5. High X values (>200) in first 5000 lines - these are typically from start code movements, not the model
                        const isNegativeZ = zValue < 0;
                        const isHighY = yValue !== null && yValue > 250;
                        // Only filter specific wipe positions (X65, X100, X165) - NOT X128 alone (can be model center)
                        // But filter X128 if combined with high Y or negative Z (wipe sequence indicators)
                        const isWipeXPosition = (i < 5000 && (Math.abs(xValue - 65) < 1 || Math.abs(xValue - 100) < 1 || Math.abs(xValue - 165) < 1));
                        const isX128WithWipeIndicators = (i < 5000 && Math.abs(xValue - 128) < 1 && (isHighY || isNegativeZ));
                        const isLowXPurge = (i < 2000 && xValue < 50) || (xValue < 30);
                        // CRITICAL: Filter high X values (>200) in first 5000 lines - these are start code movements, not model coordinates
                        const isHighXStartCode = (i < 5000 && xValue > 200);
                        
                        const isLikelyPurgeOrWipe = isNegativeZ || isHighY || isWipeXPosition || isX128WithWipeIndicators || isLowXPurge || isHighXStartCode;
                        
                        if (!isLikelyPurgeOrWipe) {
                            xCoords.push(xValue);
                        } else if (DEBUG_MODE && xCoords.length < 10) {
                            // Determine the reason for filtering (priority order matters for logging)
                            let reason = "unknown";
                            if (isNegativeZ) reason = "negativeZ";
                            else if (isHighY) reason = "highY";
                            else if (isHighXStartCode) reason = "highXStartCode";
                            else if (isWipeXPosition) reason = "wipeX";
                            else if (isX128WithWipeIndicators) reason = "x128WithWipe";
                            else if (isLowXPurge) reason = "lowXPurge";
                            console.log("[DIAG] determineModelPlacement: Skipping likely purge/wipe line - line:", i, "X:", xValue, "Y:", yValue, "Z:", zValue, "E:", eValue, "reason:", reason);
                        }
                    }
                    
                    // CRITICAL: Also collect Y coordinates in the same loop
                    if (yMatch) {
                        const yValue = parseFloat(yMatch[1]);
                        if (!isNaN(yValue)) {
                            yCoordsFound++;
                            // Filter by correct Y-range for current printer model
                            if (yValue >= minYRange && yValue <= maxYRange) {
                                yCoords.push(yValue);
                                yCoordsFiltered++;
                            } else if (DEBUG_MODE && yCoordsFound <= 10) {
                                // Log first few out-of-range values for debugging
                                console.log("[DIAG] determineModelPlacement: Y coordinate out of range:", yValue, "(valid range:", minYRange, "-", maxYRange + ")");
                            }
                        }
                    }
                }
                
                // Stop tidligt hvis vi har nok data points
                if (xCoords.length > MAX_DATA_POINTS) break;
            }
            
            if (DEBUG_MODE) {
                console.log("[DIAG] determineModelPlacement: Y coordinate collection stats - found:", yCoordsFound, "filtered:", yCoordsFiltered, "valid:", yCoords.length);
            }
        } catch (error) {
            // Don't use regex fallback on entire file - it's too slow for large files
            // Instead, return default center placement with error info
            if (DEBUG_MODE) console.warn("Line-by-line parsing failed:", error);
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
        } 

        if (xCoords.length < MIN_POINTS_REQUIRED) {
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoTooFew' }; 
        }

        // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
        const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
        const bedMinX = bedBounds.minX || 10;
        const bedMaxX = bedBounds.maxX || 246;
        
        if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: Filtering X coordinates using", currentPrinterModel, "bounds - minX:", bedMinX, "maxX:", bedMaxX);
        
        const filteredCoords = xCoords.filter(x => x > bedMinX && x < bedMaxX); 
        
        if (filteredCoords.length === 0) {
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
        }

        // Use reducer for large arrays to avoid stack overflow
        const minX = filteredCoords.reduce((min, val) => val < min ? val : min, filteredCoords[0]);
        const maxX = filteredCoords.reduce((max, val) => val > max ? val : max, filteredCoords[0]);
        const totalWidth = maxX - minX;
        
        if (DEBUG_MODE) {
            console.log("[DIAG] determineModelPlacement: After filtering - minX:", minX, "maxX:", maxX, "totalWidth:", totalWidth, "filteredCoords.length:", filteredCoords.length);
            // Show sample of collected coordinates for debugging
            if (filteredCoords.length > 0) {
                const sampleSize = Math.min(20, filteredCoords.length);
                const sample = filteredCoords.slice(0, sampleSize).sort((a, b) => a - b);
                console.log("[DIAG] determineModelPlacement: Sample of collected X coordinates (first", sampleSize, "sorted):", sample);
                if (filteredCoords.length > sampleSize) {
                    const lastSample = filteredCoords.slice(-sampleSize).sort((a, b) => a - b);
                    console.log("[DIAG] determineModelPlacement: Sample of collected X coordinates (last", sampleSize, "sorted):", lastSample);
                }
            }
        }
        
        // Calculate Y coordinates if collected (already collected in the main loop above)
        let minY, maxY;
        if (yCoords.length > 0) {
            minY = yCoords.reduce((min, val) => val < min ? val : min, yCoords[0]);
            maxY = yCoords.reduce((max, val) => val > max ? val : max, yCoords[0]);
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: Collected Y coordinates - minY:", minY, "maxY:", maxY);
        } else {
            if (DEBUG_MODE) {
                if (yCoordsFound > 0) {
                    console.log("[DIAG] determineModelPlacement: Y coordinates found but all filtered out (out of range)");
                } else {
                    console.log("[DIAG] determineModelPlacement: No Y coordinates collected (no matching lines found)");
                }
            }
        }
        
        // 1. DEDIKERET H√òJRE PLACERING:
        if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: Checking placement - minX:", minX, "maxX:", maxX, "PUSH_RIGHT_BOUNDARY:", PUSH_RIGHT_BOUNDARY, "PUSH_LEFT_BOUNDARY:", PUSH_LEFT_BOUNDARY);
        if (minX > PUSH_RIGHT_BOUNDARY) {
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: DEDICATED RIGHT detected (minX >", PUSH_RIGHT_BOUNDARY + ")");
            const result = { direction: 'right', minX: minX, maxX: maxX, infoKey: 'debugInfoDedicatedRight' };
            if (minY !== undefined && maxY !== undefined) {
                result.minY = minY;
                result.maxY = maxY;
            }
            return result;
        }
        
        // 2. DEDIKERET VENSTRE PLACERING:
        if (maxX < PUSH_LEFT_BOUNDARY) {
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: DEDICATED LEFT detected (maxX <", PUSH_LEFT_BOUNDARY + ")");
            const result = { direction: 'left', minX: minX, maxX: maxX, infoKey: 'debugInfoDedicatedLeft' };
            if (minY !== undefined && maxY !== undefined) {
                result.minY = minY;
                result.maxY = maxY;
            }
            return result;
        }
        
        // 3. OVERLAP / CENTER PLACERING:
        const widthLeft = Math.max(0, Math.min(maxX, PUSH_LEFT_BOUNDARY) - minX);
        const widthRight = Math.max(0, maxX - Math.max(minX, PUSH_RIGHT_BOUNDARY));
        const widthCenter = totalWidth - widthLeft - widthRight;

        if (DEBUG_MODE) {
            console.log("[DIAG] determineModelPlacement: Overlap calculation - widthLeft:", widthLeft, "widthCenter:", widthCenter, "widthRight:", widthRight, "totalWidth:", totalWidth);
            console.log("[DIAG] determineModelPlacement: Zone boundaries - PUSH_LEFT_BOUNDARY:", PUSH_LEFT_BOUNDARY, "PUSH_RIGHT_BOUNDARY:", PUSH_RIGHT_BOUNDARY);
            console.log("[DIAG] determineModelPlacement: Model spans from X", minX, "to X", maxX, "(center would be at", (minX + maxX) / 2 + ")");
        }

        let direction = 'center'; 
        let winnerText = 'Center';

        // Priority logic (FIXED for center-placed models):
        // 1. FIRST: Check if center is dominant (>50mm and larger than both edges) - prioritize center
        // 2. THEN: If center is not dominant, check if one edge zone is clearly larger than the other
        // 3. If edge zones are similar but one is larger, prefer the larger one (only if center is not dominant)
        // 4. Default to center if unclear
        
        const edgeDifference = Math.abs(widthRight - widthLeft);
        const edgeThreshold = 10; // mm - minimum difference to prefer one edge over the other
        
        // PRIORITY 1: Check if center is dominant FIRST (before checking edge zones)
        // This ensures center-placed models are correctly identified even if edge zones are slightly imbalanced
        // For center-placed models: widthCenter should be > both edges, and center should be substantial (>30mm)
        // OR if both edges are 0 (model is entirely in center zone), it's definitely center
        const isCenterDominant = (widthCenter > widthLeft && widthCenter > widthRight && widthCenter > 30) || (widthLeft === 0 && widthRight === 0 && widthCenter > 0);
        if (isCenterDominant) {
            // Center is clearly dominant and substantial, OR model is entirely in center zone
            direction = 'center';
            winnerText = 'Center';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: CENTER selected (center is clearly dominant - widthCenter:", widthCenter, "> widthLeft:", widthLeft, "and widthRight:", widthRight, "OR model entirely in center zone)");
        } else if (widthRight > widthLeft + edgeThreshold) {
            // Right zone is clearly larger (only if center is not dominant)
            direction = 'right';
            winnerText = 'Right';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: RIGHT selected (widthRight > widthLeft + threshold)");
        } else if (widthLeft > widthRight + edgeThreshold) {
            // Left zone is clearly larger (only if center is not dominant)
            direction = 'left';
            winnerText = 'Left';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: LEFT selected (widthLeft > widthRight + threshold)");
        } else if (widthRight > widthLeft) {
            // Right is slightly larger (within threshold, only if center is not dominant)
            direction = 'right';
            winnerText = 'Right';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: RIGHT selected (widthRight > widthLeft, within threshold)");
        } else if (widthLeft > widthRight) {
            // Left is slightly larger (within threshold, only if center is not dominant)
            direction = 'left';
            winnerText = 'Left';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: LEFT selected (widthLeft > widthRight, within threshold)");
        } else {
            // Default to center if unclear
            direction = 'center';
            winnerText = 'Center';
            if (DEBUG_MODE) console.log("[DIAG] determineModelPlacement: CENTER selected (default/unclear)");
        }

        const result = { 
            direction: direction, 
            minX: minX, 
            maxX: maxX,
            totalWidth: totalWidth,
            widthLeft: widthLeft,
            widthCenter: widthCenter,
            widthRight: widthRight,
            winnerText: winnerText,
            infoKey: 'debugInfoOverlap'
        };
        
        // Add Y coordinates if collected (already calculated above)
        if (minY !== undefined && maxY !== undefined) {
            result.minY = minY;
            result.maxY = maxY;
        }
        
        return result;
    }
    // --- SLUT P√Ö determineModelPlacement() FUNKTION ---

    /**
     * Updates statistics display with file information
     * @param {string} content - G-code file content
     * @param {number} loopCount - Number of loops
     */
    function updateStatsDisplay(content, loopCount) {
        const loopValEl = document.getElementById("statLoops");
        const filamentStatLine = document.getElementById("filamentStatLine");
        const filamentValEl = document.getElementById("statFilament");
        const filamentUnitEl = document.getElementById("statFilamentUnit");
        const timeStatLine = document.getElementById("timeStatLine");
        const timeValEl = document.getElementById("statTime");
        const fileSizeStatLine = document.getElementById("fileSizeStatLine");
        const fileSizeValEl = document.getElementById("statFileSize");
        const pushDirectionStatLine = document.getElementById("pushDirectionStatLine");
        const pushDirectionValEl = document.getElementById("statPushDirection");
        const bedTempStatLine = document.getElementById("bedTempStatLine");
        const bedTempValEl = document.getElementById("statBedTemp");
        const pushOffsetStatLine = document.getElementById("pushOffsetStatLine");
        const pushOffsetValEl = document.getElementById("statPushOffset");

        loopValEl.textContent = loopCount.toString();
        loopValEl.style.color = "var(--accent)";
        loopValEl.style.fontWeight = "bold";
        
        // Display push direction (P1/X1) or push status (A1)
        if (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') {
            const directionNames = { left: "Left", center: "Center", right: "Right" };
            const directionName = directionNames[currentDirection] || currentDirection;
            pushDirectionValEl.textContent = directionName;
            pushDirectionStatLine.style.display = "block";
            pushDirectionValEl.style.color = "var(--accent)";
            pushDirectionValEl.style.fontWeight = "bold";
        } else if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
            // A1/A1Mini use automatic Y-axis push - show status instead of direction
            pushDirectionValEl.textContent = "Automatic Y-axis";
            pushDirectionStatLine.style.display = "block";
            pushDirectionValEl.style.color = "var(--accent)";
            pushDirectionValEl.style.fontWeight = "bold";
        } else {
            // Unknown model - hide the stat line
            pushDirectionStatLine.style.display = "none";
        }
        
        // Display bed temp
        const cooldownTempInput = DOM.cooldownTempInput || document.getElementById("cooldownTempInput");
        if (cooldownTempInput) {
            const bedTemp = cooldownTempInput.value || "18";
            bedTempValEl.textContent = bedTemp + "¬∞C";
            bedTempStatLine.style.display = "block";
            bedTempValEl.style.color = "var(--accent)";
            bedTempValEl.style.fontWeight = "bold";
        } else {
            bedTempStatLine.style.display = "none";
        }
        
        // Display push offset
        const bedOffsetDisplay = DOM.bedOffsetDisplay || document.getElementById("bedOffsetDisplay");
        if (bedOffsetDisplay) {
            const pushOffset = bedOffsetDisplay.textContent || currentOffset || "30";
            pushOffsetValEl.textContent = pushOffset + " mm";
            pushOffsetStatLine.style.display = "block";
            pushOffsetValEl.style.color = "var(--accent)";
            pushOffsetValEl.style.fontWeight = "bold";
        } else {
            pushOffsetStatLine.style.display = "none";
        }
        
        // Calculate and display estimated file size
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (fileInput.files.length > 0) {
            const fileSize = fileInput.files[0].size;
            const estimatedSize = fileSize * loopCount * 1.1; // Add 10% overhead
            fileSizeValEl.textContent = formatFileSize(estimatedSize);
            fileSizeStatLine.style.display = "block";
            fileSizeValEl.style.color = "var(--accent)";
            fileSizeValEl.style.fontWeight = "bold";
        } else {
            fileSizeStatLine.style.display = "none";
        }

        let singleUsage = 0;
        const filamentMatch = content.match(/;\s*total\s+filament\s+(?:used|weight)\s+\[g\]\s*[:=]\s*([\d\.]+)/i);
        if (filamentMatch && filamentMatch[1]) {
            singleUsage = parseFloat(filamentMatch[1]);
        }

        if (singleUsage > 0) {
            const totalUsage = (singleUsage * loopCount).toFixed(1);
            filamentValEl.textContent = totalUsage;
            filamentStatLine.style.display = "block";
            currentFilamentUsage = totalUsage;
            filamentValEl.style.color = "var(--accent)";
            filamentValEl.style.fontWeight = "bold"; 
            filamentUnitEl.style.color = "var(--accent)";
            filamentUnitEl.style.fontWeight = "bold"; 
        } else {
            filamentValEl.textContent = "0.0";
            filamentStatLine.style.display = "none";
            currentFilamentUsage = "";
        }

        const timeMatch = content.match(/;\s*(?:estimated|model)\s+printing\s+time.*[:=]\s*(.+)/i);
        
        if (timeMatch && timeMatch[1]) {
            const singleTimeStr = timeMatch[1].trim();
            const singleSeconds = parseTimeStringToSeconds(singleTimeStr);
            
            if (singleSeconds > 0) {
                // Calculate total print time: (single print time * loops) + (cooldown time * (loops - 1))
                // Cooldown is 60 minutes (3600 seconds) between each loop (conservative estimate)
                const COOLDOWN_SECONDS = 60 * 60; // 60 minutes in seconds
                const totalSeconds = (singleSeconds * loopCount) + (COOLDOWN_SECONDS * (loopCount - 1));
                const formattedTotalTime = formatSecondsToTime(totalSeconds);
                
                timeValEl.textContent = formattedTotalTime;
                timeStatLine.style.display = "block";
                timeValEl.style.color = "var(--accent)";
                timeValEl.style.fontWeight = "bold";
            } else {
                timeValEl.textContent = "0s";
                timeStatLine.style.display = "none";
            }
        } else {
            timeValEl.textContent = "0s";
            timeStatLine.style.display = "none";
        }
        
        document.getElementById("output").style.display = "block";
    }

    /**
     * Updates footer text based on file type
     * @param {boolean} is3MF - Whether the current file is a 3MF file
     */
    function updateFooterText(is3MF) {
        const footerTextEl = document.querySelector('.footer-text[data-lang="footerText"]');
        if (footerTextEl) {
            const dict = LANG.en;
            const text = is3MF ? dict.footerText3MF : dict.footerText;
            
            // Clear existing content safely
            footerTextEl.textContent = '';
            
            // Parse text to preserve <strong> tag structure safely
            // Text format: "<strong>‚ö†Ô∏è Safety reminder:</strong> Always test..."
            const strongMatch = text.match(/^<strong>(.*?)<\/strong>(.*)$/);
            if (strongMatch) {
                const strongText = strongMatch[1];
                const restText = strongMatch[2];
                
                const strong = document.createElement('strong');
                strong.textContent = strongText;
                
                footerTextEl.appendChild(strong);
                footerTextEl.appendChild(document.createTextNode(restText));
            } else {
                // No <strong> tag, just use textContent
                footerTextEl.textContent = text;
            }
            
            // Footer text is no longer used - Beta Notice is shown in Quick Start Guide instead
            footerTextEl.style.display = "none";
        }
    }

    function validateFileImmediate() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const statusEl = document.getElementById("fileValidationStatus");
        const debugEl = document.getElementById("placementDebug"); // May not exist if removed
        const debugOutput = document.getElementById("debugOutputContent"); // May not exist if removed
        const genBtn = DOM.generateBtn || document.getElementById("generateBtn");
        const outputEl = DOM.output || document.getElementById("output");
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const dict = LANG.en;
        
        lastValidationStatus = { key: null, color: null };
        lastDebugData = null; 

        if (!fileInput.files.length) {
            statusEl.style.display = "none";
            if (debugEl) debugEl.style.display = "none";
            genBtn.disabled = true;
            const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
            if (testBtn) {
                testBtn.style.display = "none";
            }
            const sweepTestBtn = document.getElementById("generateSweepTestBtn");
            if (sweepTestBtn) {
                sweepTestBtn.style.display = "none";
            }
            outputEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
            updateFileSizeEstimate(); // Hide estimate
            autoDetectedDirection = null; // Reset auto-detected direction
            document.getElementById("directionWarning").style.display = "none";
            document.getElementById("directionInfo").style.display = "none";
            
            // Unlock printer model selector when file is removed
            autoDetectedPrinterModel = null;
            const modelSelect = document.getElementById("printerModel");
            const autoDetectedNote = document.getElementById("autoDetectedPrinterNote");
            if (modelSelect) {
                modelSelect.disabled = false;
            }
            if (autoDetectedNote) {
                autoDetectedNote.style.display = 'none';
            }
            
            // Reset bed preview when file is removed
            updatePreview();
            // Hide footer text when no file is selected
            const footerTextEl = document.querySelector('.footer-text[data-lang="footerText"]');
            if (footerTextEl) {
                footerTextEl.style.display = "none";
            }
            return;
        }
        
        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        // Check file size
        if (file.size > MAX_FILE_SIZE) {
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(1);
            const maxSizeMB = (MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
            statusEl.textContent = `File too large (${fileSizeMB}MB). Maximum: ${maxSizeMB}MB`;
            statusEl.style.color = "var(--danger)";
            statusEl.style.display = "block";
            genBtn.disabled = true;
            outputEl.style.display = "none";
            if (debugEl) debugEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
            return;
        }
        
        genBtn.disabled = true; 
        outputEl.style.display = "none";
        statusEl.style.display = "none";
        if (debugEl) debugEl.style.display = "none";
        if (debugOutput) debugOutput.textContent = ''; 
        bedPreviewContainer.classList.remove('locked');
        
        // Reset bed preview when new file is selected (will be updated after model detection)
        // Hide both previews initially to avoid showing wrong model
        const bedPreviewP1 = document.getElementById("bedPreviewP1");
        const bedPreviewCanvas = document.getElementById("bedPreviewCanvas");
        if (bedPreviewP1) bedPreviewP1.style.display = 'none';
        if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'none';
        
        // Also reset currentPrinterModel to default to ensure clean state
        // It will be updated when model is detected
        // For 3MF files, we'll detect it from metadata, so don't set default yet
        // For G-code files, we'll use the dropdown value
        if (!is3MF) {
            const modelSelect = document.getElementById("printerModel");
            currentPrinterModel = (modelSelect && modelSelect.value) || "P1";
        } else {
            // For 3MF, don't set default - let detection set it
            // This prevents using wrong bounds if detection hasn't run yet
            currentPrinterModel = null;
        }

        document.getElementById("statSourceName").textContent = file.name; 
        
        // Handle 3MF files differently
        if (is3MF) {
            // For 3MF files, validate by trying to unzip and find G-code
            updateProgress(10, "Validating 3MF file...");
            
            // Check if JSZip is available
            if (typeof JSZip === 'undefined') {
                statusEl.textContent = "Error: JSZip library not loaded. Please refresh the page.";
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
                genBtn.disabled = true;
                return;
            }
            
            // Validate 3MF file structure
            file.arrayBuffer().then(async (arrayBuffer) => {
                try {
                    updateProgress(30, "Checking 3MF structure...");
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    
                    // Find G-code file
                    const gcodeFiles = [];
                    zip.forEach((relativePath) => {
                        if (relativePath.match(GCODE_FILE_IN_3MF_REGEX)) {
                            gcodeFiles.push(relativePath);
                        }
                    });
                    
                    if (gcodeFiles.length === 0) {
                        statusEl.textContent = "Error: No G-code file found in 3MF. Expected: Metadata/plate_*.gcode";
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        return;
                    }
                    
                    // Try to read and validate G-code content
                    updateProgress(50, "Validating G-code in 3MF...");
                    const gcodePath = gcodeFiles[0];
                    const gcodeContent = await zip.file(gcodePath).async('string');
                    
                    // Check for Looprint signature (should not be present - file already processed)
                    // Check for both the signature and "Generated by Looprint" watermark
                    const hasLooprint = gcodeContent.indexOf(LOOPRINT_SIGNATURE) !== -1 || 
                                       gcodeContent.indexOf("Generated by Looprint") !== -1 ||
                                       gcodeContent.indexOf("Contact: Nicki.Andersen@gmail.com") !== -1 ||
                                       gcodeContent.indexOf("github.com/NickiAndersen/looprint") !== -1;
                    
                    if (hasLooprint) {
                        statusEl.textContent = dict.validationErrorLooprint;
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        updateProgress(0);
                        return;
                    }
                    
                    // For 3MF files, we don't require FactorianDesigns signature because:
                    // - Start/end G-code is in the printer profile, not in the G-code file
                    // - The signature will be added when we generate the looped file
                    // Instead, validate that it's a valid G-code file with max_z_height
                    const hasMaxZHeight = /;\s*max_z_height\s*[:=]\s*[\d\.]+/i.test(gcodeContent);
                    
                    if (!hasMaxZHeight) {
                        statusEl.textContent = "Error: G-code file in 3MF does not contain max_z_height. Please ensure the file was sliced correctly.";
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        return;
                    }
                    
                    // CRITICAL: Detect printer model FIRST, before determineModelPlacement()
                    // This ensures determineModelPlacement() uses correct bounds (P1 vs A1)
                    updateProgress(70, "Detecting printer model...");
                    let detectedPrinterModel = null;
                    try {
                        // Method 1: Check slice_info.config for printer_model_id (most reliable)
                        const sliceInfoFile = zip.file("Metadata/slice_info.config");
                        if (DEBUG_MODE) console.log("sliceInfoFile found:", !!sliceInfoFile);
                        if (sliceInfoFile) {
                            try {
                                const sliceInfoContent = await sliceInfoFile.async('string');
                                if (DEBUG_MODE) console.log("slice_info.config content preview:", sliceInfoContent.substring(0, 500));
                                
                                // Look for printer_model_id in XML: <metadata key="printer_model_id" value="N2S"/>
                                let modelIdMatch = sliceInfoContent.match(/key=["']printer_model_id["'][^>]*value=["']([^"']+)["']/i);
                                if (!modelIdMatch) {
                                    modelIdMatch = sliceInfoContent.match(/printer_model_id[^>]*value=["']([^"']+)["']/i);
                                }
                                if (!modelIdMatch) {
                                    const lines = sliceInfoContent.split('\n');
                                    for (const line of lines) {
                                        if (line.includes('printer_model_id')) {
                                            const valueMatch = line.match(/value=["']([^"']+)["']/i);
                                            if (valueMatch) {
                                                modelIdMatch = valueMatch;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (modelIdMatch) {
                                    const modelId = modelIdMatch[1].toUpperCase().trim();
                                    if (DEBUG_MODE) console.log("Found printer_model_id:", modelId);
                                    
                                    // Check for X1/X1C first (before P1 check, since X1 contains 'X1' which would match P1 check)
                                    // X1/X1C uses BL-P001 or BL-P002 as printer_model_id (found in actual X1.gcode.3mf files)
                                    if (modelId === 'BL-P001' || modelId === 'BL-P002' || modelId === 'C12' || modelId === 'X1' || modelId === 'X1C' || 
                                        (modelId.includes('X1') && !modelId.includes('P1'))) {
                                        detectedPrinterModel = 'x1';
                                        if (DEBUG_MODE) console.log("Detected X1 from printer_model_id");
                                    } else if (modelId === 'N1' || (modelId.includes('A1Mini') || modelId.includes('A1 Mini'))) {
                                        detectedPrinterModel = 'A1Mini';
                                    } else if (modelId === 'N2S' || modelId.includes('A1')) {
                                        detectedPrinterModel = 'A1';
                                        if (DEBUG_MODE) console.log("Detected A1 from printer_model_id");
                                    } else if (modelId === 'C11' || modelId.includes('P1')) {
                                        detectedPrinterModel = 'P1';
                                        if (DEBUG_MODE) console.log("Detected P1 from printer_model_id");
                                    }
                                } else {
                                    if (DEBUG_MODE) console.warn("No printer_model_id match found in slice_info.config");
                                }
                            } catch (e) {
                                if (DEBUG_MODE) console.warn("Could not read slice_info.config:", e);
                            }
                        } else {
                            if (DEBUG_MODE) console.warn("slice_info.config file not found in 3MF");
                        }
                        
                        // Method 2: Check project_settings.config for A1/P1 references in profiles
                        if (!detectedPrinterModel) {
                            const projectSettingsFile = zip.file("Metadata/project_settings.config");
                            if (projectSettingsFile) {
                                try {
                                    const projectSettingsContent = await projectSettingsFile.async('string');
                                    if (DEBUG_MODE) console.log("Checking project_settings.config for printer model...");
                                    
                                    // Check for X1/X1C first (before P1 check)
                                    if (projectSettingsContent.includes('@BBL X1C') || 
                                        projectSettingsContent.includes('@BBL X1') ||
                                        projectSettingsContent.match(/["']([^"']*X1[^"']*)["']/)) {
                                        detectedPrinterModel = 'x1';
                                        if (DEBUG_MODE) console.log("Detected X1 from project_settings.config");
                                    } else if (projectSettingsContent.includes('@BBL A1') || 
                                        projectSettingsContent.match(/["']([^"']*A1[^"']*)["']/) ||
                                        projectSettingsContent.match(/;=====\s*A1\s*\d+/i)) {
                                        detectedPrinterModel = 'A1';
                                        if (DEBUG_MODE) console.log("Detected A1 from project_settings.config");
                                    } else if (projectSettingsContent.includes('@BBL P1P') || 
                                               projectSettingsContent.includes('@BBL P1S') ||
                                               projectSettingsContent.includes('@BBL P1') || 
                                               projectSettingsContent.match(/["']([^"']*P1[^"']*)["']/)) {
                                        detectedPrinterModel = 'P1';
                                        if (DEBUG_MODE) console.log("Detected P1 from project_settings.config");
                                    }
                                } catch (e) {
                                    if (DEBUG_MODE) console.warn("Could not read project_settings.config:", e);
                                }
                            } else {
                                if (DEBUG_MODE) console.warn("project_settings.config file not found in 3MF");
                            }
                        }
                        
                        // Method 3: Check G-code content for A1/P1/X1 markers (fallback)
                        if (!detectedPrinterModel) {
                            // Check for X1 first (before P1 check)
                            if (gcodeContent.includes(';===== machine: X1') || 
                                gcodeContent.includes('@BBL X1C') || 
                                gcodeContent.includes('@BBL X1')) {
                                detectedPrinterModel = 'x1';
                                if (DEBUG_MODE) console.log("Detected X1 from G-code content");
                            } else if (gcodeContent.includes(';===== A1') || gcodeContent.includes('@BBL A1')) {
                                detectedPrinterModel = 'A1';
                                if (DEBUG_MODE) console.log("Detected A1 from G-code content");
                            } else if (gcodeContent.includes('@BBL P1')) {
                                detectedPrinterModel = 'P1';
                                if (DEBUG_MODE) console.log("Detected P1 from G-code content");
                            }
                        }
                    } catch (detectionError) {
                        if (DEBUG_MODE) console.warn("Error detecting printer model:", detectionError);
                    }
                    
                    if (DEBUG_MODE) console.log("Final detectedPrinterModel:", detectedPrinterModel);
                    
                    // CRITICAL: Set currentPrinterModel BEFORE determineModelPlacement() so it uses correct bounds
                    if (detectedPrinterModel) {
                        if (DEBUG_MODE) console.log("Setting currentPrinterModel to:", detectedPrinterModel, "before determineModelPlacement()");
                        currentPrinterModel = detectedPrinterModel;
                    } else {
                        // If detection failed, keep default P1 but log warning
                        if (DEBUG_MODE) console.warn("Printer model detection failed, using default P1 bounds");
                        currentPrinterModel = "P1";
                    }
                    
                    // Valid 3MF file - now detect model placement (with correct printer model bounds)
                    updateProgress(75, "Detecting model placement...");
                    if (DEBUG_MODE) console.log("[DIAG] validateFileImmediate: About to call determineModelPlacement with currentPrinterModel:", currentPrinterModel);
                    try {
                        const placementResult = determineModelPlacement(gcodeContent);
                        if (DEBUG_MODE) console.log("[DIAG] validateFileImmediate: determineModelPlacement result:", placementResult);
                        autoDetectedDirection = placementResult.direction;
                        currentDirection = placementResult.direction;
                        lastDebugData = placementResult;
                        
                        // Update UI with detected placement
                        selectDirection(placementResult.direction, true, true);
                        
                        // Update push lane offset display with maximum possible offset
                        // Only if advanced settings are visible (input element exists)
                        try {
                            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                            if (pushLaneOffsetInput) {
                                updatePushLaneOffset();
                            }
                        } catch (offsetError) {
                            // Don't let offset update error prevent file upload
                            if (DEBUG_MODE) console.warn("Error updating push lane offset:", offsetError);
                        }
                        
                        // Show debug info if advanced settings are enabled
                        const isAdvanced = (DOM.showAdvancedSettings || document.getElementById("showAdvancedSettings")).checked;
                        if (isAdvanced && debugEl) {
                            renderDebugText();
                            debugEl.style.display = "block";
                        } else if (debugEl) {
                            debugEl.style.display = "none";
                        }
                        
                        // Lock bed preview in simple mode, unlock in advanced mode
                        if (isAdvanced) {
                            bedPreviewContainer.classList.remove('locked');
                            updateDirectionInfo();
                        } else {
                            bedPreviewContainer.classList.add('locked');
                            // Update direction info to show auto-detected message in simple mode
                            updateDirectionInfo();
                        }
                        
                        // Show test file button (works for 3MF too now that we have G-code content)
                        const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
                        if (testBtn) {
                            testBtn.style.display = "inline-block";
                            // Show sweep test button only if sweep is enabled
                            const enableSweep = document.getElementById("enableSweep");
                            const sweepTestBtn = document.getElementById("generateSweepTestBtn");
                            if (sweepTestBtn && enableSweep && enableSweep.checked) {
                                sweepTestBtn.style.display = "inline-block";
                            }
                        }
                    } catch (placementError) {
                        if (DEBUG_MODE) console.error("Error in determineModelPlacement for 3MF:", placementError);
                        // Default to center if placement detection fails
                        autoDetectedDirection = 'center';
                        currentDirection = 'center';
                        placementResult = { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
                        selectDirection('center', true, true);
                    }
                    
                    // Auto-select and lock detected model if found (detection already done above, before determineModelPlacement)
                    // Note: detectedPrinterModel was already set earlier in this function
                    try {
                        // Method 1: Check slice_info.config for printer_model_id (most reliable)
                        const sliceInfoFile = zip.file("Metadata/slice_info.config");
                        if (DEBUG_MODE) console.log("sliceInfoFile found:", !!sliceInfoFile);
                        if (sliceInfoFile) {
                            try {
                                const sliceInfoContent = await sliceInfoFile.async('string');
                                if (DEBUG_MODE) console.log("slice_info.config content preview:", sliceInfoContent.substring(0, 500));
                                
                                // Look for printer_model_id in XML: <metadata key="printer_model_id" value="N2S"/>
                                let modelIdMatch = sliceInfoContent.match(/key=["']printer_model_id["'][^>]*value=["']([^"']+)["']/i);
                                if (!modelIdMatch) {
                                    modelIdMatch = sliceInfoContent.match(/printer_model_id[^>]*value=["']([^"']+)["']/i);
                                }
                                if (!modelIdMatch) {
                                    const lines = sliceInfoContent.split('\n');
                                    for (const line of lines) {
                                        if (line.includes('printer_model_id')) {
                                            const valueMatch = line.match(/value=["']([^"']+)["']/i);
                                            if (valueMatch) {
                                                modelIdMatch = valueMatch;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (modelIdMatch) {
                                    const modelId = modelIdMatch[1].toUpperCase().trim();
                                    if (DEBUG_MODE) console.log("Found printer_model_id:", modelId);
                                    
                                    // Check for X1/X1C first (before P1 check, since X1 contains 'X1' which would match P1 check)
                                    // X1/X1C uses BL-P001 or BL-P002 as printer_model_id (found in actual X1.gcode.3mf files)
                                    if (modelId === 'BL-P001' || modelId === 'BL-P002' || modelId === 'C12' || modelId === 'X1' || modelId === 'X1C' || 
                                        (modelId.includes('X1') && !modelId.includes('P1'))) {
                                        detectedPrinterModel = 'x1';
                                        if (DEBUG_MODE) console.log("Detected X1 from printer_model_id");
                                    } else if (modelId === 'N1' || (modelId.includes('A1Mini') || modelId.includes('A1 Mini'))) {
                                        detectedPrinterModel = 'A1Mini';
                                    } else if (modelId === 'N2S' || modelId.includes('A1')) {
                                        detectedPrinterModel = 'A1';
                                        if (DEBUG_MODE) console.log("Detected A1 from printer_model_id");
                                    } else if (modelId === 'C11' || modelId.includes('P1')) {
                                        detectedPrinterModel = 'P1';
                                        if (DEBUG_MODE) console.log("Detected P1 from printer_model_id");
                                    }
                                } else {
                                    if (DEBUG_MODE) console.warn("No printer_model_id match found in slice_info.config");
                                }
                            } catch (e) {
                                if (DEBUG_MODE) console.warn("Could not read slice_info.config:", e);
                            }
                        } else {
                            if (DEBUG_MODE) console.warn("slice_info.config file not found in 3MF");
                        }
                        
                        // Method 2: Check project_settings.config for A1/P1 references in profiles
                        if (!detectedPrinterModel) {
                            const projectSettingsFile = zip.file("Metadata/project_settings.config");
                            if (projectSettingsFile) {
                                try {
                                    const projectSettingsContent = await projectSettingsFile.async('string');
                                    if (DEBUG_MODE) console.log("Checking project_settings.config for printer model...");
                                    
                                    // Check for X1/X1C first (before P1 check)
                                    if (projectSettingsContent.includes('@BBL X1C') || 
                                        projectSettingsContent.includes('@BBL X1') ||
                                        projectSettingsContent.match(/["']([^"']*X1[^"']*)["']/)) {
                                        detectedPrinterModel = 'x1';
                                        if (DEBUG_MODE) console.log("Detected X1 from project_settings.config");
                                    } else if (projectSettingsContent.includes('@BBL A1') || 
                                        projectSettingsContent.match(/["']([^"']*A1[^"']*)["']/) ||
                                        projectSettingsContent.match(/;=====\s*A1\s*\d+/i)) {
                                        detectedPrinterModel = 'A1';
                                        if (DEBUG_MODE) console.log("Detected A1 from project_settings.config");
                                    } else if (projectSettingsContent.includes('@BBL P1P') || 
                                               projectSettingsContent.includes('@BBL P1S') ||
                                               projectSettingsContent.includes('@BBL P1') || 
                                               projectSettingsContent.match(/["']([^"']*P1[^"']*)["']/)) {
                                        detectedPrinterModel = 'P1';
                                        if (DEBUG_MODE) console.log("Detected P1 from project_settings.config");
                                    }
                                } catch (e) {
                                    if (DEBUG_MODE) console.warn("Could not read project_settings.config:", e);
                                }
                            } else {
                                if (DEBUG_MODE) console.warn("project_settings.config file not found in 3MF");
                            }
                        }
                        
                        // Method 3: Fallback - Check G-code header
                        if (!detectedPrinterModel) {
                            const headerLines = gcodeContent.split('\n').slice(0, 100).join('\n');
                            if (headerLines.match(/;=====\s*A1\s*\d+/i) || 
                                (headerLines.includes('A1') && headerLines.match(/machine.*A1/i))) {
                                detectedPrinterModel = 'A1';
                                if (DEBUG_MODE) console.log("Detected A1 from G-code header");
                            } else if (headerLines.includes('P1') || headerLines.includes('X1') || 
                                       headerLines.match(/machine.*P1/i) || headerLines.match(/machine.*X1/i)) {
                                detectedPrinterModel = 'P1';
                                if (DEBUG_MODE) console.log("Detected P1 from G-code header");
                            }
                        }
                    } catch (e) {
                        if (DEBUG_MODE) console.warn("Could not detect printer model from 3MF:", e);
                    }
                    
                    if (DEBUG_MODE) console.log("Final detectedPrinterModel:", detectedPrinterModel);
                    
                    // Auto-select and lock detected model if found
                    if (detectedPrinterModel) {
                        if (DEBUG_MODE) console.log("Auto-selecting and locking printer model:", detectedPrinterModel);
                        const modelSelect = document.getElementById("printerModel");
                        const autoDetectedNote = document.getElementById("autoDetectedPrinterNote");
                        
                        if (modelSelect) {
                            // Store auto-detected model
                            autoDetectedPrinterModel = detectedPrinterModel;
                            
                            // Update currentPrinterModel BEFORE calling handlePrinterModelChange
                            currentPrinterModel = detectedPrinterModel;
                            
                            // Auto-select the detected model
                            modelSelect.value = detectedPrinterModel;
                            
                            // Call handlePrinterModelChange which will call updatePreview
                            handlePrinterModelChange();
                            
                            // Lock the select and show note
                            modelSelect.disabled = true;
                            if (autoDetectedNote) {
                                autoDetectedNote.style.display = 'block';
                            }
                            
                            // Force bed preview update after a short delay to ensure DOM is ready
                            setTimeout(() => {
                                updatePreview();
                            }, 100);
                            
                            // Show confirmation message
                            const detectedModelName = detectedPrinterModel === 'A1' ? 'Bambu Lab A1/A1 Mini' : (detectedPrinterModel === 'x1' ? 'Bambu Lab X1/X1C' : 'Bambu Lab P1/P1S');
                            showStatus("validationWarning", "success", `‚úì Printer model auto-detected: ${detectedModelName}. Selector locked to match file.`);
                        }
                    } else {
                        // No printer model detected - unlock selector and update preview to default (P1)
                        autoDetectedPrinterModel = null;
                        const modelSelect = document.getElementById("printerModel");
                        const autoDetectedNote = document.getElementById("autoDetectedPrinterNote");
                        if (modelSelect) {
                            modelSelect.disabled = false;
                            // Ensure currentPrinterModel matches the select value
                            currentPrinterModel = modelSelect.value || "P1";
                        }
                        if (autoDetectedNote) {
                            autoDetectedNote.style.display = 'none';
                        }
                        // Update preview to match current selection (defaults to P1)
                        handlePrinterModelChange();
                        setTimeout(() => {
                            updatePreview();
                        }, 100);
                    }
                    
                    statusEl.textContent = "File verified: Valid 3MF file detected. Start and end code will be added automatically.";
                    statusEl.style.color = "var(--accent)";
                    statusEl.style.display = "block";
                    // Ensure button is enabled - use setTimeout to ensure DOM updates are complete
                    setTimeout(() => {
                        genBtn.disabled = false;
                        if (DEBUG_MODE) console.log("3MF validation successful - Generate button enabled");
                    }, 0);
                    
                    // Update stats display (same as for G-code files)
                    const loopsForDisplay = parseInt(document.getElementById("loopCount").value, 10) || DEFAULT_LOOPS;
                    updateStatsDisplay(gcodeContent, loopsForDisplay);
                    
                    // Update file size estimate after validation
                    updateFileSizeEstimate();
                    
                    // Show output area
                    outputEl.style.display = "block";
                    
                    // Update footer text for 3MF files
                    updateFooterText(true);
                    
                    // Update start code textarea with variable replacement
                    updateStartCodeTextarea(gcodeContent);
                    
                    updateProgress(0);
                } catch (error) {
                    setLoadingState(false);
                    statusEl.textContent = `Error validating 3MF file: ${error.message || "Invalid 3MF structure"}`;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                    genBtn.disabled = true;
                    updateProgress(0);
                }
            }).catch((error) => {
                setLoadingState(false);
                statusEl.textContent = `Error reading 3MF file: ${error.message || "Could not read file"}`;
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
                genBtn.disabled = true;
                updateProgress(0);
            });
            
            return; // Exit early for 3MF files
        }
        
        // Handle G-code files (existing logic)
        const reader = new FileReader();
        
        // Show progress during file read
        updateProgress(10, "Reading file..."); 

        reader.onload = function(e) {
            try {
                updateProgress(30, "Validating file...");
                const content = e.target.result;
                
                // Check for tom fil
                if (!content || content.length === 0) {
                    throw new Error("File is empty");
                }
                
                let validationKey = null;
                let validationColor = null;

                // Check if already processed by Looprint
                // Check for both the signature and watermarks to ensure file hasn't been looped
                const hasLooprint = content.indexOf(LOOPRINT_SIGNATURE) !== -1 ||
                                   content.indexOf("Generated by Looprint") !== -1 ||
                                   content.indexOf("Contact: Nicki.Andersen@gmail.com") !== -1 ||
                                   content.indexOf("github.com/NickiAndersen/looprint") !== -1;

                if (hasLooprint) {
                    validationKey = "validationErrorLooprint";
                    validationColor = "var(--danger)";
                    bedPreviewContainer.classList.remove('locked');
                } else {
                    // G-code file is valid (no longer require Factorian signature - start/end code will be added automatically)
                    validationKey = "validationSuccess";
                    validationColor = "var(--accent)";
                    
                    updateProgress(60, "Analyzing model placement...");
                    
                    // Wrap placement detection in try-catch for better error handling
                    let placementResult;
                    try {
                        placementResult = determineModelPlacement(content);
                    } catch (placementError) {
                        if (DEBUG_MODE) console.error("Error in determineModelPlacement:", placementError);
                        // Fallback to center if placement detection fails
                        placementResult = { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
                    }
                    
                    updateProgress(90, "Finalizing...");
                    
                    // Set direction with auto-detected flag
                    selectDirection(placementResult.direction, true, true);
                    
                    // Update push lane offset display with maximum possible offset
                    // Only if advanced settings are visible (input element exists)
                    try {
                        const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                        if (pushLaneOffsetInput) {
                            updatePushLaneOffset();
                        }
                    } catch (offsetError) {
                        // Don't let offset update error prevent file upload
                        if (DEBUG_MODE) console.warn("Error updating push lane offset:", offsetError);
                    }
                    
                    // Ensure button is enabled - use setTimeout to ensure DOM updates are complete
                    setTimeout(() => {
                        genBtn.disabled = false;
                        if (DEBUG_MODE) console.log("G-code validation successful - Generate button enabled");
                    }, 0);
                    
                    // Show test file button when file is validated
                    const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
                    if (testBtn) {
                        testBtn.style.display = "inline-block";
                        // Show sweep test button only if sweep is enabled
                        const enableSweep = document.getElementById("enableSweep");
                        const sweepTestBtn = document.getElementById("generateSweepTestBtn");
                        if (sweepTestBtn && enableSweep && enableSweep.checked) {
                            sweepTestBtn.style.display = "inline-block";
                        }
                    }
                    
                    const loopsForDisplay = parseInt(document.getElementById("loopCount").value, 10) || DEFAULT_LOOPS; 
                    updateStatsDisplay(content, loopsForDisplay);
                    
                    lastDebugData = placementResult;
                    renderDebugText();

                    // Update file size estimate after validation
                    updateFileSizeEstimate();

                    outputEl.style.display = "block";
                    
                    // Show debug only if advanced settings are enabled
                    const isAdvanced = document.getElementById("showAdvancedSettings").checked;
                    if (debugEl) {
                        if (isAdvanced) {
                            debugEl.style.display = "block";
                        } else {
                            debugEl.style.display = "none";
                        }
                    }
                    
                    // Update footer text for G-code files
                    updateFooterText(false);
                    
                    // Update start code textarea with variable replacement
                    updateStartCodeTextarea(content);
                    
                    // Lock bed preview based on advanced mode
                    if (!isAdvanced) {
                        // Simple mode: always lock after file upload
                    bedPreviewContainer.classList.add('locked');
                    // Update direction info to show auto-detected message in simple mode
                    updateDirectionInfo();
                    } else {
                        // Advanced mode: unlock so user can change
                        bedPreviewContainer.classList.remove('locked');
                        updateDirectionInfo();
                    }
                    
                    updateProgress(100, "Ready!");
                    setTimeout(() => updateProgress(0), 500);
                }

                if (validationKey) {
                    lastValidationStatus = { key: validationKey, color: validationColor };
                    statusEl.textContent = dict[validationKey] || validationKey;
                    statusEl.style.color = validationColor;
                    statusEl.style.display = "block";

                    if (validationColor === "var(--danger)") {
                        genBtn.disabled = true;
                        outputEl.style.display = "none";
                        if (debugEl) debugEl.style.display = "none";
                        bedPreviewContainer.classList.remove('locked');
                    }
                }
                
            } catch (error) {
                const validationKey = "validationErrorParse";
                const validationColor = "var(--danger)";
                lastValidationStatus = { key: validationKey, color: validationColor };

                statusEl.textContent = dict[validationKey] || validationKey;
                statusEl.style.color = validationColor;
                statusEl.style.display = "block";
                genBtn.disabled = true;
                outputEl.style.display = "none";
                if (debugEl) debugEl.style.display = "none";
                bedPreviewContainer.classList.remove('locked');
                if (DEBUG_MODE) console.error("Critical error during file validation:", error);
            }
        };
        
        reader.onerror = function() {
            const validationKey = "validationErrorParse";
            const validationColor = "var(--danger)";
            lastValidationStatus = { key: validationKey, color: validationColor };
            
            statusEl.textContent = dict[validationKey] || validationKey;
            statusEl.style.color = validationColor;
            statusEl.style.display = "block";
            genBtn.disabled = true;
            outputEl.style.display = "none";
            if (debugEl) debugEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
        };
        
        reader.readAsText(file);
    }
    
    /**
     * Resets all settings to default values
     */
    function resetDefaults() {
        const defaultLoops = DEFAULT_LOOPS;
        const defaultTemp = DEFAULT_TEMP; 
        const defaultOffset = DEFAULT_OFFSET;
        const defaultPushLaneOffset = DEFAULT_PUSH_LANE_OFFSET;
        const defaultPushSpeed = DEFAULT_PUSH_SPEED;
        const defaultSweepSpeed = DEFAULT_SWEEP_SPEED;
        const defaultSweepZ = DEFAULT_SWEEP_Z;
        
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");

        loopCountEl.value = defaultLoops;
        document.getElementById("cooldownTempInput").value = defaultTemp;
        document.getElementById("zOffsetInput").value = defaultOffset;
        document.getElementById("skirtConfirmed").checked = false;
        
        // Reset Push Lane Offset to default
        const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
        if (pushLaneOffsetInput) {
            pushLaneOffsetInput.value = defaultPushLaneOffset;
        }
        
        // Reset Push-off Speed to default
        const pushSpeedInput = document.getElementById("pushSpeedInput");
        if (pushSpeedInput) {
            pushSpeedInput.value = defaultPushSpeed;
        }
        
        // Reset Full Bed Sweep settings to default
        const enableSweep = document.getElementById("enableSweep");
        if (enableSweep) {
            enableSweep.checked = false;
        }
        const sweepSpeedInput = document.getElementById("sweepSpeedInput");
        if (sweepSpeedInput) {
            sweepSpeedInput.value = defaultSweepSpeed;
        }
        const sweepZInput = document.getElementById("sweepZInput");
        if (sweepZInput) {
            sweepZInput.value = defaultSweepZ;
        }
        
        // Update sweep settings visibility
        toggleSweepSettings();
        
        document.getElementById("bedPreviewContainer").classList.remove('locked');

        currentOffset = defaultOffset;
        document.getElementById("bedOffsetDisplay").textContent = defaultOffset;
        
        try {
            localStorage.removeItem('looprint_loops');
            localStorage.removeItem('looprint_temp');
            localStorage.removeItem('looprint_offset');
            localStorage.removeItem('looprint_pushLaneOffset');
            localStorage.removeItem('looprint_pushSpeed');
            localStorage.removeItem('looprint_enableSweep');
            localStorage.removeItem('looprint_sweepSpeed');
            localStorage.removeItem('looprint_sweepZ');
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully
            if (DEBUG_MODE) console.warn("Could not clear settings from localStorage:", e);
        }
        
        checkCooldownWarning();
        updatePushLaneOffset(); // Update push lane offset display
        updateEndCodeTextareas();
        
        // Unlock printer model selector on reset
        autoDetectedPrinterModel = null;
        const modelSelect = document.getElementById("printerModel");
        const autoDetectedNote = document.getElementById("autoDetectedPrinterNote");
        if (modelSelect) {
            modelSelect.disabled = false;
        }
        if (autoDetectedNote) {
            autoDetectedNote.style.display = 'none';
        }
        
        if (fileInput.files.length > 0) {
            validateFileImmediate(); 
        } else {
            selectDirection('center', false);
            document.getElementById("output").style.display = "none";
            const placementDebugEl = document.getElementById("placementDebug");
            if (placementDebugEl) placementDebugEl.style.display = "none"; 
            document.getElementById("fileValidationStatus").style.display = "none";
            (DOM.generateBtn || document.getElementById("generateBtn")).disabled = true; 
        }
        
        clearStatus();
        document.getElementById("zOffsetStatus").style.display = "none";
        document.getElementById("pushLaneOffsetStatus").style.display = "none";
        document.getElementById("pushLaneOffsetMaxInfo").style.display = "none";
        autoDetectedDirection = null; // Reset auto-detected direction
        document.getElementById("directionWarning").style.display = "none";
        document.getElementById("directionInfo").style.display = "none";
        currentFileType = "gcode"; // Reset file type
    }

    /**
     * Processes the uploaded file (G-code or 3MF) and generates looped version
     * Includes progress tracking and error handling
     */
    async function processFiles() {
        clearStatus();
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) { showStatus("fileError", "error"); return; }

        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
        const loops = parseInt(loopCountEl.value, 10);
        if (isNaN(loops) || loops < 1) { 
            showStatus("loopsError", "error"); 
            return; 
        }
        
        // Warn about very high loop counts
        if (loops > 100) {
            if (!confirm(`Warning: ${loops} loops is a very high number. This may cause memory issues or browser crashes.\n\nRecommended maximum: 50 loops.\n\nContinue anyway?`)) {
                return;
            }
        }
        
        if (loops > MAX_LOOPS) {
            showStatus("loopsTooManyError", "error");
            return;
        }

        if (!document.getElementById("skirtConfirmed").checked) { showStatus("skirtError", "error"); return; }

        const file = fileInput.files[0];
        
        // Detect file type
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        // Estimate final file size and warn if too large
        const estimatedFinalSize = file.size * loops;
        const MAX_ESTIMATED_SIZE = 500 * 1024 * 1024; // 500MB
        
        if (estimatedFinalSize > MAX_ESTIMATED_SIZE) {
            const estimatedMB = (estimatedFinalSize / 1024 / 1024).toFixed(1);
            const maxMB = (MAX_ESTIMATED_SIZE / 1024 / 1024).toFixed(0);
            if (!confirm(`Warning: Estimated file size will be ${estimatedMB}MB (max recommended: ${maxMB}MB).\n\nThis may cause memory issues. Continue anyway?`)) {
                return;
            }
        }

        // Route to appropriate handler
        currentFileType = is3MF ? "3mf" : "gcode";
        if (is3MF) {
            await process3MFFile(file, loops);
        } else {
            await processGcodeFile(file, loops);
        }
    }
    
    /**
     * Processes a G-code file (existing functionality)
     * @param {File} file - The G-code file to process
     * @param {number} loops - Number of loops to generate
     */
    async function processGcodeFile(file, loops) {
        // Show loading state
        setLoadingState(true, "Generating looped G-code file...");
        updateProgress(10, "Reading file...");

        originalFilename = file.name.replace(/\.(gcode|gco|g|txt)$/i, "") || "looprint";

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                updateProgress(30, "Processing G-code...");
                const baseGcode = (e.target.result || "").trim();
                
                // Check for empty file (edge case #20)
                if (!baseGcode || baseGcode.length === 0) {
                    setLoadingState(false);
                    showStatus("fileEmptyError", "error");
                    return;
                }
                
                // Check if already processed by Looprint
                // Check for both the signature and watermarks to ensure file hasn't been looped
                const hasLooprint = baseGcode.includes(LOOPRINT_SIGNATURE) ||
                                   baseGcode.includes("Generated by Looprint") ||
                                   baseGcode.includes("Contact: Nicki.Andersen@gmail.com") ||
                                   baseGcode.includes("github.com/NickiAndersen/looprint");
                
                if (hasLooprint) {
                    setLoadingState(false);
                        showStatus("validationErrorLooprint", "error");
                    return;
                }

                updateProgress(50, "Building loop structure...");
                updateStatsDisplay(baseGcode, loops);

                // Extract max_z_height from G-code header for max_layer_z replacement
                const maxZMatch = baseGcode.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
                let maxZHeight = null;
                if (maxZMatch && maxZMatch[1]) {
                    maxZHeight = parseFloat(maxZMatch[1]);
                    // Validate extracted value (increased max to 1000mm for taller models)
                    if (isNaN(maxZHeight) || maxZHeight <= 0 || maxZHeight > MAX_Z_HEIGHT_MM) {
                        if (DEBUG_MODE) console.warn(`Invalid max_z_height value: ${maxZMatch[1]}`);
                        maxZHeight = null;
                    }
                }
                
                // Extract first_layer_center_no_wipe_tower for A1 push-off alignment
                // This is needed for A1 end code template variable replacement
                if (DEBUG_MODE) console.log("[DIAG] process3MFFile: Extracting variables for printer model:", currentPrinterModel);
                if (DEBUG_MODE) console.log("[DIAG] process3MFFile: lastDebugData available:", !!lastDebugData, lastDebugData ? {minX: lastDebugData.minX, maxX: lastDebugData.maxX, minY: lastDebugData.minY, maxY: lastDebugData.maxY} : 'N/A');
                
                const endCodeVariableValues = extractVariableValues(baseGcode, gcodeConfig);
                if (DEBUG_MODE) console.log("[DIAG] process3MFFile: Extracted variable values:", Object.keys(endCodeVariableValues));
                if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                    if (DEBUG_MODE) console.log("[DIAG] process3MFFile:", currentPrinterModel, "- endCodeVariableValues['first_layer_center_no_wipe_tower']:", endCodeVariableValues['first_layer_center_no_wipe_tower']);
                }
                
                let firstLayerCenterX = '128'; // Default to bed center
                let firstLayerCenterY = '128';
                if (endCodeVariableValues['first_layer_center_no_wipe_tower'] && Array.isArray(endCodeVariableValues['first_layer_center_no_wipe_tower'])) {
                    firstLayerCenterX = endCodeVariableValues['first_layer_center_no_wipe_tower'][0] || '128';
                    firstLayerCenterY = endCodeVariableValues['first_layer_center_no_wipe_tower'][1] || '128';
                    if (DEBUG_MODE) console.log("[DIAG] Using extracted array values - X:", firstLayerCenterX, "Y:", firstLayerCenterY);
                } else {
                    // Fallback: Calculate from model placement (lastDebugData)
                    if (lastDebugData && lastDebugData.minX !== undefined && lastDebugData.maxX !== undefined) {
                        firstLayerCenterX = ((parseFloat(lastDebugData.minX) + parseFloat(lastDebugData.maxX)) / 2).toFixed(2);
                        if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for X - calculated:", firstLayerCenterX);
                    }
                    if (lastDebugData && lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                        firstLayerCenterY = ((parseFloat(lastDebugData.minY) + parseFloat(lastDebugData.maxY)) / 2).toFixed(2);
                        if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for Y - calculated:", firstLayerCenterY);
                    } else {
                        if (DEBUG_MODE) console.log("[DIAG] WARNING: lastDebugData.minY/maxY not available, using default Y: 128");
                    }
                }
                
                if (DEBUG_MODE) console.log("[DIAG] Final values - firstLayerCenterX:", firstLayerCenterX, "firstLayerCenterY:", firstLayerCenterY);
                
                // Replace first_layer_center_no_wipe_tower in end code
                activeEndCode = activeEndCode.replace(/\{first_layer_center_no_wipe_tower\[0\]\}/g, firstLayerCenterX);
                activeEndCode = activeEndCode.replace(/\{first_layer_center_no_wipe_tower\[1\]\}/g, firstLayerCenterY);

                // LOGIC FIREWALL: Strict routing - A1/A1Mini and P1 use completely different end code elements
                let endCodeElement;
                if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                    FIREWALL_A1_A1MINI_ONLY('process3MFFile: end code selection');
                    endCodeElement = document.getElementById('endA1Code');
                } else {
                    // P1/X1: Use direction-based end code elements (both use same push system)
                    FIREWALL_P1_X1_ONLY('process3MFFile: end code selection');
                    endCodeElement = document.getElementById(`end${currentDirection.charAt(0).toUpperCase() + currentDirection.slice(1)}Code`);
                }
                if (!endCodeElement) {
                    setLoadingState(false);
                    showStatus("validationErrorParse", "error", "Error: Could not find end code element. Please refresh the page.");
                    return;
                }
                let activeEndCode = endCodeElement.value;
                
                if (DEBUG_MODE) {
                    console.log("[DIAG] process3MFFile: endCodeElement found:", !!endCodeElement);
                    console.log("[DIAG] process3MFFile: endCodeElement.value length:", activeEndCode ? activeEndCode.length : 0);
                    console.log("[DIAG] process3MFFile: currentPrinterModel:", currentPrinterModel);
                }
                
                // CRITICAL: If end code is empty, generate it now (for A1, P1, and X1)
                if (!activeEndCode || activeEndCode.trim().length === 0) {
                    if (DEBUG_MODE) console.warn("[DIAG] process3MFFile: End code is empty, generating now for model:", currentPrinterModel);
                    
                    if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                        // Generate A1/A1Mini end code using current settings
                        const temp = getCooldownTemp();
                        const offset = currentOffset;
                        const modelCenterY = calculateModelCenterY();
                        if (currentPrinterModel === 'A1Mini') {
                            activeEndCode = getA1MiniEndCode(temp, offset, modelCenterY);
                        } else {
                            activeEndCode = getA1EndCode(temp, offset, modelCenterY);
                        }
                        endCodeElement.value = activeEndCode;
                        if (DEBUG_MODE) console.log("[DIAG] process3MFFile: Generated", currentPrinterModel, "end code, length:", activeEndCode.length);
                    } else {
                        // P1/X1: Generate end code for current direction (X1 uses same push system as P1)
                        // First ensure all P1/X1 end codes are generated
                        updateEndCodeTextareas();
                        // Then get the code for current direction
                        activeEndCode = endCodeElement.value;
                        if (DEBUG_MODE) console.log("[DIAG] process3MFFile: Generated", currentPrinterModel, "end code for direction:", currentDirection, "length:", activeEndCode ? activeEndCode.length : 0);
                    }
                }
                
                if (!activeEndCode || activeEndCode.trim().length === 0) {
                    setLoadingState(false);
                    showStatus("validationErrorParse", "error", "Error: End code is empty. Please refresh the page.");
                    return;
                }
                
                // Replace {max_layer_z} with actual value and evaluate conditionals
                if (maxZHeight !== null && !isNaN(maxZHeight)) {
                    // CRITICAL: Replace conditional logic FIRST (before variable replacement) to ensure structure is intact
                    // Factorian uses {if (max_layer_z ) > 41} with space - handle both formats
                    activeEndCode = activeEndCode.replace(/\{if\s*\(?\s*max_layer_z\s*\)?\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                        const thresholdNum = parseFloat(threshold);
                        if (isNaN(thresholdNum)) {
                            if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                            return match;
                        }
                        if (maxZHeight > thresholdNum) {
                            return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                         .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                             const numVal = parseFloat(val);
                                             if (isNaN(numVal)) {
                                                 if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                 return m;
                                             }
                                             const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                             return result.toFixed(2);
                                         }).trim();
                        } else {
                            return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                          .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                              const numVal = parseFloat(val);
                                                              if (isNaN(numVal)) {
                                                                  if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                                  return m;
                                                              }
                                                              const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                              return result.toFixed(2);
                                                          }).trim() : '';
                        }
                    });
                    // Now replace remaining {max_layer_z} variables (outside conditionals)
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                        const numVal = parseFloat(val);
                        if (isNaN(numVal)) {
                            if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                            return match;
                        }
                        const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                        return result.toFixed(2);
                    });
                } else {
                    // Fallback: Use safe default (50mm) if max_z_height not found
                    if (DEBUG_MODE) console.warn("max_z_height not found in G-code header, using fallback 50mm");
                    maxZHeight = 50; // Safe fallback for template replacement
                    // Continue with template replacement using fallback value
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                        const numVal = parseFloat(val);
                        if (isNaN(numVal)) {
                            if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                            return match;
                        }
                        const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                        return result.toFixed(2);
                    });
                    // Evaluate conditionals with fallback value
                    activeEndCode = activeEndCode.replace(/\{if\s*\(?\s*max_layer_z\s*\)?\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                        const thresholdNum = parseFloat(threshold);
                        if (isNaN(thresholdNum)) {
                            if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                            return match;
                        }
                        if (maxZHeight > thresholdNum) {
                            return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                         .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                             const numVal = parseFloat(val);
                                             if (isNaN(numVal)) {
                                                 if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                 return m;
                                             }
                                             const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                             return result.toFixed(2);
                                         }).trim();
                        } else {
                            return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                          .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                              const numVal = parseFloat(val);
                                                              if (isNaN(numVal)) {
                                                                  if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                                  return m;
                                                              }
                                                              const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                              return result.toFixed(2);
                                                          }).trim() : '';
                        }
                    });
                    // Show warning to user
                    showStatus("validationWarning", "warning", 
                        "Warning: Could not extract model height (max_z_height) from G-code header. " +
                        "Using fallback value of 50mm. Please verify the generated G-code is correct.");
                }

                // Extract print G-code only (remove existing end code)
                const endCodeStartMarker = END_CODE_START_MARKER; 
                let printGcodeOnly = baseGcode;
                const endCodeIndex = baseGcode.lastIndexOf(endCodeStartMarker);
                if (endCodeIndex !== -1) {
                    printGcodeOnly = baseGcode.substring(0, endCodeIndex).trim();
                } else {
                    if (DEBUG_MODE) console.warn("Factorian End Code marker not found. Looping entire file without safely deleting end code.");
                }

                // Parse G-code structure (same logic as 3MF)
                const gcodeStructure = parseGcodeStructure(printGcodeOnly);
                const gcodeHeader = gcodeStructure.header;
                const gcodeConfig = gcodeStructure.config;
                const printGcodeExecutable = gcodeStructure.executable;
                
                updateProgress(60, `Generating ${loops} loops...`);
                
                // Extract variable values from CONFIG_BLOCK or G-code
                const variableValues = extractVariableValues(baseGcode, gcodeConfig);
                
                // Replace variables in start code template with actual values
                const startCodeTemplate = getStartCodeTemplate();
                const startCodeWithVars = replaceStartCodeVariables(startCodeTemplate, variableValues);
                
                // Build looped G-code with start code in each loop
                const parts = [];
                parts.push(`; ===== ${LOOPRINT_SIGNATURE} (Start) =====`);
                parts.push(`; Source: ${file.name}`);
                parts.push(`; Loops: ${loops}`);
                parts.push(`; Generated: ${new Date().toISOString()}`);
                parts.push(`; Generated by Looprint`);
                parts.push(`; Contact: Nicki.Andersen@gmail.com`);
                parts.push(`; GitHub: https://github.com/NickiAndersen/looprint`);
                parts.push(`\n`);
                
                for (let i = 1; i <= loops; i++) {
                    const loopProgress = 60 + (i / loops) * 30;
                        updateProgress(loopProgress, `Generating loop ${i} of ${loops}...`);
                        
                    parts.push(`; >>> LOOP ${i} / ${loops} <<<`);
                    
                    if (i === 1) {
                        // First loop: include header and config
                        if (gcodeHeader) {
                            parts.push(gcodeHeader);
                            parts.push('\n');
                        }
                        if (gcodeConfig) {
                            parts.push(gcodeConfig);
                            parts.push('\n');
                        }
                    } else {
                        // Subsequent loops: M400 safety wait
                        parts.push("M400 ; Looprint safety: Wait for buffer clear before next loop");
                        parts.push('\n');
                    }
                    
                    // Add setup part (EXECUTABLE_BLOCK_START, setup commands, FEATURE: Custom)
                    if (typeof printGcodeExecutable === 'object' && printGcodeExecutable.setup) {
                        parts.push(printGcodeExecutable.setup);
                        parts.push('\n');
                        
                        // Add start code for each loop (AFTER FEATURE: Custom, BEFORE print G-code)
                        parts.push(startCodeWithVars);
                        parts.push('\n');
                        
                        // Ensure temperature is set correctly after start code
                        if (printGcodeExecutable.print) {
                            const printStart = printGcodeExecutable.print.trim();
                            if (printStart.match(/^;LAYER_CHANGE|^; layer|^;LAYER/i)) {
                                // Print starts directly with layer marker - ensure temp is set
                                if (variableValues['nozzle_temperature_initial_layer']) {
                                    parts.push(`; Ensure nozzle temperature is set for printing\n`);
                                    parts.push(`M104 S${variableValues['nozzle_temperature_initial_layer']} ; Set nozzle temp for printing\n`);
                                    parts.push('\n');
                                }
                            }
                            parts.push(printGcodeExecutable.print);
                            parts.push('\n');
                        }
                    } else {
                        // Fallback: if structure is different, use as string
                        const printGcodeStr = typeof printGcodeExecutable === 'string' ? printGcodeExecutable : String(printGcodeExecutable);
                        if (!printGcodeStr.includes('machine: P1S') && !printGcodeStr.includes('FactorianDesigns')) {
                            // Original start code not found, safe to add
                            parts.push(startCodeWithVars);
                            parts.push('\n');
                        }
                        parts.push(printGcodeStr);
                        parts.push('\n');
                    }
                    
                    // Add end code after each loop
                    parts.push(activeEndCode);
                    parts.push('\n');
                }

                updateProgress(95, "Finalizing file...");
                parts.push(`; >>> END OF PRINT LOOPS <<<`);
                parts.push(`; ===== ${LOOPRINT_SIGNATURE} (End) =====`);

                // Build file efficiently - use Blob for large files to avoid string length limits
                try {
                    updateProgress(97, "Assembling final file...");
                    
                    // Estimate total size (optimized: only count strings, skip non-strings)
                    let estimatedSize = 0;
                    for (let i = 0; i < parts.length; i++) {
                        if (typeof parts[i] === 'string') {
                            estimatedSize += parts[i].length;
                        }
                    }
                    const MAX_STRING_SIZE = 200 * 1024 * 1024; // 200MB - safe limit for most browsers
                    
                    if (estimatedSize > MAX_STRING_SIZE) {
                        // For large files, build directly as Blob to avoid string length limits
                        updateProgress(98, "Building large file (using optimized method)...");
                        
                        // Convert all parts to strings and create Blob directly (optimized: only convert non-strings)
                        const blobParts = [];
                        for (let i = 0; i < parts.length; i++) {
                            blobParts.push(typeof parts[i] === 'string' ? parts[i] : String(parts[i]));
                        }
                        finalFileContent = new Blob(blobParts, { type: 'text/plain' });
                        
                        // Check blob size
                        if (finalFileContent.size > MAX_GENERATED_FILE_SIZE) {
                            throw new Error(`Generated file is too large (>${(MAX_GENERATED_FILE_SIZE / 1024 / 1024).toFixed(0)}MB). Please reduce number of loops.`);
                        }
                    } else {
                        // For smaller files, use string (faster and simpler)
                finalFileContent = parts.join("\n");
                    }
                } catch (joinError) {
                    setLoadingState(false);
                    if (joinError.message && (joinError.message.includes("too large") || joinError.message.includes("Invalid string length"))) {
                        showStatus("validationErrorParse", "error", 
                            `File too large for ${loops} loops. Try reducing to ${Math.max(1, Math.floor(loops * 0.7))} loops or less.`);
                    } else {
                        showStatus("validationErrorParse", "error", 
                            `Failed to generate file: ${joinError.message || "Out of memory. Try reducing number of loops."}`);
                    }
                    if (DEBUG_MODE) console.error("Error assembling file:", joinError);
                    return;
                }

                updateProgress(100, "Complete!");
                setLoadingState(false);
                
                const outputEl = DOM.output || document.getElementById("output");
                outputEl.style.display = "block";
                document.getElementById("statSourceName").textContent = file.name;
                showStatus("outputReady", "success");
                
                setTimeout(() => updateProgress(0), 500);
                // Scroll to output box after a short delay to ensure it's visible
                setTimeout(() => {
                    outputEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
                
            } catch (error) {
                setLoadingState(false);
                let errorMessage = LANG.en.validationErrorParse + ` (Generation Error)`;
                
                // Provide more specific error messages
                if (error instanceof RangeError || 
                    (error.message && (error.message.includes("memory") || error.message.includes("Invalid string length") || error.message.includes("string length")))) {
                    errorMessage = `File too large for ${loops} loops. JavaScript has a string length limit. Try reducing to ${Math.max(1, Math.floor(loops * 0.7))} loops or less.`;
                } else if (error.message) {
                    errorMessage = `Generation failed: ${error.message}`;
                }
                
                showStatus("validationErrorParse", "error", errorMessage);
                if (DEBUG_MODE) {
                    console.error("Critical error during file generation:", error);
                    console.error("Error details:", {
                        loops: loops,
                        fileSize: file.size,
                        estimatedSize: file.size * loops,
                        errorName: error.name,
                        errorMessage: error.message
                    });
                }
            }
        };
        
        reader.onerror = function() {
            setLoadingState(false);
            showStatus("validationErrorParse", "error");
        };
        
        reader.readAsText(file);
    }
    // --- SLUT P√Ö processGcodeFile() FUNKTION ---
    
    /**
     * Shared function to parse G-code structure (used by both G-code and 3MF processing)
     * Extracts header, config block, setup commands, and print G-code
     * @param {string} gcodeContent - Full G-code content (without end code)
     * @returns {Object} Object with header, config, setup, and print parts
     */
    function parseGcodeStructure(gcodeContent) {
        // Find where executable block starts (after CONFIG_BLOCK)
        const executableBlockStart = gcodeContent.indexOf('; EXECUTABLE_BLOCK_START');
        let gcodeHeader = '';
        let gcodeConfig = '';
        let printGcodeExecutable = gcodeContent;
        
        if (executableBlockStart !== -1) {
            // Split into header/config and executable parts
            gcodeHeader = gcodeContent.substring(0, executableBlockStart).trim();
            printGcodeExecutable = gcodeContent.substring(executableBlockStart).trim();
            
            // Find CONFIG_BLOCK
            const configStart = gcodeHeader.indexOf('; CONFIG_BLOCK_START');
            const configEnd = gcodeHeader.indexOf('; CONFIG_BLOCK_END');
            if (configStart !== -1 && configEnd !== -1) {
                gcodeConfig = gcodeHeader.substring(configStart, configEnd + '; CONFIG_BLOCK_END'.length);
                gcodeHeader = gcodeHeader.substring(0, configStart).trim() + '\n' + gcodeHeader.substring(configEnd + '; CONFIG_BLOCK_END'.length).trim();
            }
            
            // Extract setup commands (M73, M201, etc.) and FEATURE: Custom, but remove original start code
            // Structure: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> start code -> print G-code
            // We want: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> START_CODE -> print G-code
            
            // Split into: setup part (up to FEATURE: Custom) and print part (after original start code)
            let setupPart = '';
            let printPart = '';
            
                const featureIndex = printGcodeExecutable.indexOf('; FEATURE: Custom');
            if (featureIndex !== -1) {
                // Keep everything up to and including "FEATURE: Custom"
                setupPart = printGcodeExecutable.substring(0, featureIndex + '; FEATURE: Custom'.length);
                
                // After FEATURE: Custom, there's original start code, then print G-code
                const afterFeature = printGcodeExecutable.substring(featureIndex + '; FEATURE: Custom'.length);
                
                // First, try to find "Start Code End" marker (most reliable indicator)
                // This marker is added by Bambu Studio to mark the end of start code
                const startCodeEndMarker = /; =+.*Start Code End.*=+/i;
                const startCodeEndMatch = afterFeature.match(startCodeEndMarker);
                
                let printStartIndex = -1;
                
                if (startCodeEndMatch) {
                    // Found "Start Code End" marker - print starts after this marker
                    // CRITICAL: Everything between FEATURE: Custom and "Start Code End" is the original start code
                    // We need to skip it completely and start from after "Start Code End"
                    const afterMarker = afterFeature.substring(startCodeEndMatch.index + startCodeEndMatch[0].length);
                    // Find CHANGE_LAYER after marker (most reliable)
                    const changeLayerMatch = afterMarker.match(/; CHANGE_LAYER|;LAYER_CHANGE/i);
                    if (changeLayerMatch) {
                        printStartIndex = startCodeEndMatch.index + startCodeEndMatch[0].length + changeLayerMatch.index;
                    } else {
                        // Fallback: Find first non-empty, non-comment line after marker
                        const lines = afterMarker.split('\n');
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (line && !line.startsWith(';')) {
                                // Found first actual G-code command
                                printStartIndex = startCodeEndMatch.index + startCodeEndMatch[0].length + 
                                    lines.slice(0, i).join('\n').length + 1; // +1 for newline
                                break;
                            }
                        }
                    }
                }
                
                // ROBUST REGEX: Find standard Bambu/Orca layer change or Z-height markers
                // Prioritized list of markers that indicate start of actual print
                // CRITICAL: Layer markers must come FIRST - they are the most reliable indicators
                const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                
                // Find where original start code ends using robust regex
                // CRITICAL: We need to find the FIRST occurrence of the marker, not any occurrence
                const splitMatch = printStartIndex === -1 ? afterFeature.match(startCodeEndRegex) : null;
                
                if (printStartIndex !== -1) {
                    // Use "Start Code End" marker position
                    let layerStart = afterFeature.substring(printStartIndex);
                    
                    // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                    // These are remnants from the original start code that should be removed
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    
                    // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1; // +1 for newline
                            continue;
                        }
                        // Skip M104 S140 or M109 S140 commands
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        // Found first non-temp command - this is where print actually starts
                        break;
                    }
                    
                    printPart = layerStart.substring(startIndex).trim();
                } else if (!splitMatch) {
                    if (DEBUG_MODE) {
                        console.warn("WARNING: Could not find start point (Layer Change) in file. Start code may be duplicated!");
                        console.warn("Attempting fallback: Split after last M109 (Wait for temp)...");
                    }
                    
                    // Fallback: Try to find last M109 (Wait for temp) which marks the end of start code
                    const m109Matches = [...afterFeature.matchAll(/M109\s+S\d+/gi)];
                    if (m109Matches.length > 0) {
                        const lastM109 = m109Matches[m109Matches.length - 1];
                        const afterM109 = afterFeature.substring(lastM109.index + lastM109[0].length);
                        
                        // Try to find first print command after M109
                        const firstPrintMatch = afterM109.match(/(M73\s+P\d+|G1\s+X|G0\s+X|;LAYER|; layer)/i);
                        if (firstPrintMatch) {
                            printPart = afterM109.substring(firstPrintMatch.index).trim();
                        } else {
                            // Last fallback: use everything after last M109
                            printPart = afterM109.trim();
                            if (DEBUG_MODE) console.warn("Using everything after last M109 as fallback - start code may still be duplicated!");
                        }
                    } else {
                        // No M109 found - try to find first print command
                        const firstPrintMatch = afterFeature.match(/(M73\s+P\d+|G1\s+X|G0\s+X|G28|;LAYER|; layer)/i);
                        if (firstPrintMatch) {
                            printPart = afterFeature.substring(firstPrintMatch.index).trim();
                        } else {
                            // Last fallback: use everything after FEATURE: Custom (NOT IDEAL - start code may be duplicated)
                            printPart = afterFeature.trim();
                            if (DEBUG_MODE) console.error("CRITICAL: Could not find start point. Start code will likely be duplicated!");
                        }
                    }
                } else {
                    // Found a match - start from the matched position
                    // CRITICAL: splitMatch.index gives us the position of the marker in afterFeature
                    // We want everything AFTER the marker, not before it
                    let layerStart = afterFeature.substring(splitMatch.index);
                    
                    // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                    // These are remnants from the original start code that should be removed
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    
                    // Skip marker line and any following M104 S140 or M109 S140 commands
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1; // +1 for newline
                            continue;
                        }
                        // Skip M104 S140 or M109 S140 commands
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        // Found first non-temp command - this is where print actually starts
                        break;
                    }
                    
                    printPart = layerStart.substring(startIndex).trim();
                    
                    // Safety check: If printPart still contains old start code, try to find layer marker again
                    // Note: This is a conservative check - some valid G-code may match these patterns
                    const hasPotentialStartCode = printPart.includes('G1 Z5 F300') || 
                                                  printPart.includes('M17 X1.2 Y1.2 Z0.75') || 
                                                  printPart.includes('G90\nM17 X1.2');
                    if (hasPotentialStartCode) {
                        if (DEBUG_MODE) console.log('[DIAG] parseGcodeStructure: Potential start code detected, checking for layer markers...');
                        // Try to find where the actual print starts by looking for layer markers
                        const layerMarkerMatch = printPart.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i);
                        if (layerMarkerMatch) {
                            printPart = printPart.substring(layerMarkerMatch.index);
                            if (DEBUG_MODE) console.log('[DIAG] parseGcodeStructure: Found layer marker, trimmed printPart');
                        } else {
                            if (DEBUG_MODE) console.log('[DIAG] parseGcodeStructure: No layer marker found, keeping printPart as-is');
                        }
                    }
                }
            } else {
                // If no FEATURE: Custom, try to find layer marker directly
                const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                const splitMatch = printGcodeExecutable.match(startCodeEndRegex);
                
                if (splitMatch) {
                    setupPart = printGcodeExecutable.substring(0, splitMatch.index).trim();
                    let layerStart = printGcodeExecutable.substring(splitMatch.index);
                    
                    // Remove temperature commands after marker
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        break;
                    }
                    printPart = layerStart.substring(startIndex).trim();
                } else {
                    // No structure found - keep everything as setup (fallback)
                    setupPart = printGcodeExecutable;
                    printPart = '';
                }
            }
            
            // Store both parts separately so we can insert START_CODE between them
            printGcodeExecutable = { setup: setupPart, print: printPart };
        }
        
        return {
            header: gcodeHeader,
            config: gcodeConfig,
            executable: printGcodeExecutable
        };
    }
    
    /**
     * Processes a 3MF file: unzips, modifies G-code, and repacks
     * @param {File} file - The 3MF file to process
     * @param {number} loops - Number of loops to generate
     */
    /**
     * Parses entire CONFIG_BLOCK into a map/object
     * Handles lists (comma-separated values) and converts them to arrays
     * @param {string} gcodeConfig - CONFIG_BLOCK content
     * @returns {Object} Map of all config variables
     */
    function parseConfigBlock(gcodeConfig) {
        const configMap = {};
        
        if (!gcodeConfig) return configMap;
        
        if (DEBUG_MODE) console.log("[DIAG] parseConfigBlock: Parsing CONFIG_BLOCK, length:", gcodeConfig.length);
        
        // Split into lines and process each line
        const lines = gcodeConfig.split('\n');
        if (DEBUG_MODE) console.log("[DIAG] parseConfigBlock: Total lines:", lines.length);
        
        for (const line of lines) {
            // Match: ; variable_name = value
            // or: ; variable_name[index] = value
            // or: ; variable_name = "value"
            const match = line.match(/^;\s*([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?\s*=\s*(.+)$/);
            if (match) {
                const varName = match[1];
                const arrayIndex = match[2];
                let value = match[3].trim();
                
                // Log first_layer_center_no_wipe_tower specifically
                if (varName === 'first_layer_center_no_wipe_tower') {
                    if (DEBUG_MODE) console.log("[DIAG] parseConfigBlock: Found first_layer_center_no_wipe_tower - arrayIndex:", arrayIndex, "value:", value);
                }
                
                // Remove quotes if present
                if ((value.startsWith('"') && value.endsWith('"')) || 
                    (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }
                
                // Handle comma-separated lists (convert to array)
                if (value.includes(',') && !value.includes('"') && !value.includes("'")) {
                    const listValues = value.split(',').map(v => v.trim()).filter(v => v);
                    if (listValues.length > 1) {
                        // Store as array
                        if (!configMap[varName]) {
                            configMap[varName] = [];
                        }
                        if (arrayIndex !== undefined) {
                            // Array format: variable[index] = value
                            const idx = parseInt(arrayIndex, 10);
                            if (!Array.isArray(configMap[varName])) {
                                configMap[varName] = [];
                            }
                            configMap[varName][idx] = value; // Store single value at index
                        } else {
                            // List format: variable = value1,value2,value3
                            configMap[varName] = listValues;
                        }
                    } else {
                        // Single value despite comma
                        if (arrayIndex !== undefined) {
                            const idx = parseInt(arrayIndex, 10);
                            if (!configMap[varName]) {
                                configMap[varName] = [];
                            }
                            configMap[varName][idx] = value;
                        } else {
                            configMap[varName] = value;
                        }
                    }
                } else {
                    // Single value
                    if (arrayIndex !== undefined) {
                        const idx = parseInt(arrayIndex, 10);
                        if (!configMap[varName]) {
                            configMap[varName] = [];
                        }
                        configMap[varName][idx] = value;
                    } else {
                        configMap[varName] = value;
                    }
                }
            }
        }
        
        return configMap;
    }
    
    /**
     * Gets a variable value from configMap, handling arrays and indices
     * @param {Object} configMap - Parsed CONFIG_BLOCK map
     * @param {string} varName - Variable name
     * @param {number|string} index - Optional array index (defaults to 0 or uses initial_extruder)
     * @param {string} initialExtruder - Initial extruder index (defaults to '0')
     * @returns {string|null} Variable value or null if not found
     */
    function getConfigValue(configMap, varName, index = null, initialExtruder = '0') {
        if (!configMap[varName]) return null;
        
        const value = configMap[varName];
        if (Array.isArray(value)) {
            const idx = index !== null ? parseInt(index, 10) : parseInt(initialExtruder || '0', 10);
            return value[idx] || value[0] || null;
        }
        return value;
    }
    
    /**
     * Extracts variable values from G-code CONFIG_BLOCK or actual G-code commands
     * Uses parseConfigBlock for systematic parsing, then extracts specific needed variables
     * @param {string} gcodeContent - Full G-code content
     * @param {string} gcodeConfig - CONFIG_BLOCK content
     * @returns {Object} Object with variable names as keys and values as strings
     */
    function extractVariableValues(gcodeContent, gcodeConfig) {
        const vars = {};
        
        // Parse entire CONFIG_BLOCK into a map
        const configMap = parseConfigBlock(gcodeConfig);
        
        // Extract initial_extruder first (needed for array lookups)
        vars['initial_extruder'] = getConfigValue(configMap, 'initial_extruder') || '0';
        
        // Extract variables using getConfigValue (systematic approach - NO redundant code)
        if (gcodeConfig) {
            // Extract all variables using getConfigValue (clean, systematic)
            vars['nozzle_temperature_initial_layer'] = getConfigValue(configMap, 'nozzle_temperature_initial_layer', null, vars['initial_extruder']);
            vars['filament_type'] = getConfigValue(configMap, 'filament_type', null, vars['initial_extruder']);
            vars['curr_bed_type'] = getConfigValue(configMap, 'curr_bed_type');
            vars['hot_plate_temp_initial_layer'] = getConfigValue(configMap, 'hot_plate_temp_initial_layer');
            vars['cool_plate_temp_initial_layer'] = getConfigValue(configMap, 'cool_plate_temp_initial_layer');
            vars['filament_max_volumetric_speed'] = getConfigValue(configMap, 'filament_max_volumetric_speed', null, vars['initial_extruder']);
            vars['nozzle_temperature_range_high'] = getConfigValue(configMap, 'nozzle_temperature_range_high', null, vars['initial_extruder']);
            vars['bed_temperature'] = getConfigValue(configMap, 'bed_temperature', null, vars['initial_extruder']);
            vars['bed_temperature_initial_layer'] = getConfigValue(configMap, 'bed_temperature_initial_layer', null, vars['initial_extruder']);
            vars['bed_temperature_initial_layer_single'] = getConfigValue(configMap, 'bed_temperature_initial_layer_single');
            
            // Extract first_layer_center_no_wipe_tower array (for A1 push-off alignment)
            // This is a 2-element array: [0] = X coordinate, [1] = Y coordinate
            // CRITICAL: getConfigValue returns only a single element, not the whole array
            // We need to get the entire array directly from configMap
            if (DEBUG_MODE) console.log("[DIAG] Extracting first_layer_center_no_wipe_tower from configMap:", configMap['first_layer_center_no_wipe_tower']);
            
            if (configMap['first_layer_center_no_wipe_tower'] && Array.isArray(configMap['first_layer_center_no_wipe_tower'])) {
                // Direct array access - getConfigValue would only return one element
                vars['first_layer_center_no_wipe_tower'] = configMap['first_layer_center_no_wipe_tower'];
                if (DEBUG_MODE) console.log("[DIAG] Found first_layer_center_no_wipe_tower array:", vars['first_layer_center_no_wipe_tower']);
            } else {
                // Try to get individual elements [0] and [1] if array format is different
                const elem0 = getConfigValue(configMap, 'first_layer_center_no_wipe_tower', '0', vars['initial_extruder']);
                const elem1 = getConfigValue(configMap, 'first_layer_center_no_wipe_tower', '1', vars['initial_extruder']);
                if (DEBUG_MODE) console.log("[DIAG] Trying individual elements - [0]:", elem0, "[1]:", elem1);
                
                if (elem0 || elem1) {
                    vars['first_layer_center_no_wipe_tower'] = [elem0 || '128', elem1 || '128'];
                    if (DEBUG_MODE) console.log("[DIAG] Created array from individual elements:", vars['first_layer_center_no_wipe_tower']);
                } else {
                    // Fallback: Calculate from lastDebugData (model placement) if available
                    let fallbackX = '128';
                    let fallbackY = '128';
                    if (lastDebugData && lastDebugData.minX !== undefined && lastDebugData.maxX !== undefined) {
                        fallbackX = ((parseFloat(lastDebugData.minX) + parseFloat(lastDebugData.maxX)) / 2).toFixed(2);
                        if (DEBUG_MODE) console.log("[DIAG] Calculated X from lastDebugData:", fallbackX);
                    }
                    if (lastDebugData && lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                        fallbackY = ((parseFloat(lastDebugData.minY) + parseFloat(lastDebugData.maxY)) / 2).toFixed(2);
                        if (DEBUG_MODE) console.log("[DIAG] Calculated Y from lastDebugData:", fallbackY);
                    } else {
                        if (DEBUG_MODE) console.log("[DIAG] lastDebugData.minY/maxY not available, using default Y: 128");
                    }
                    vars['first_layer_center_no_wipe_tower'] = [fallbackX, fallbackY];
                    if (DEBUG_MODE) console.log("[DIAG] Using calculated fallback:", vars['first_layer_center_no_wipe_tower']);
                }
            }
            
            // Determine bed_temperature_initial_layer_single based on curr_bed_type (smart fallback)
            if (!vars['bed_temperature_initial_layer_single']) {
                if (vars['bed_temperature_initial_layer']) {
                    vars['bed_temperature_initial_layer_single'] = vars['bed_temperature_initial_layer'];
                } else if (vars['bed_temperature']) {
                    vars['bed_temperature_initial_layer_single'] = vars['bed_temperature'];
                } else if (vars['curr_bed_type']) {
                    const bedType = vars['curr_bed_type'].toLowerCase();
                    if ((bedType.includes('textured') || bedType.includes('pei') || bedType.includes('hot')) && vars['hot_plate_temp_initial_layer']) {
                        vars['bed_temperature_initial_layer_single'] = vars['hot_plate_temp_initial_layer'];
                    } else if (bedType.includes('cool') && vars['cool_plate_temp_initial_layer']) {
                        vars['bed_temperature_initial_layer_single'] = vars['cool_plate_temp_initial_layer'];
                    }
                }
            }
            
            // CRITICAL: Ensure bed_temperature and bed_temperature_initial_layer have fallback values for conditional evaluation
            // These are needed for conditional statements even if not used directly in [brackets]
            if (!vars['bed_temperature'] && vars['bed_temperature_initial_layer_single']) {
                vars['bed_temperature'] = vars['bed_temperature_initial_layer_single'];
            }
            if (!vars['bed_temperature_initial_layer'] && vars['bed_temperature_initial_layer_single']) {
                vars['bed_temperature_initial_layer'] = vars['bed_temperature_initial_layer_single'];
            }
        }
        
        // Fallback: Extract from actual G-code commands if not found in CONFIG_BLOCK
        if (!vars['nozzle_temperature_initial_layer']) {
            const m104Match = gcodeContent.match(/M104\s+S(\d+)\s*;.*nozzle.*temp/i);
            if (m104Match) vars['nozzle_temperature_initial_layer'] = m104Match[1];
        }
        
        if (!vars['bed_temperature_initial_layer_single']) {
            const m140Match = gcodeContent.match(/M140\s+S(\d+)/i);
            if (m140Match) vars['bed_temperature_initial_layer_single'] = m140Match[1];
        }
        
        if (!vars['initial_extruder'] || vars['initial_extruder'] === '0') {
            const tMatch = gcodeContent.match(/T(\d+)/);
            if (tMatch) vars['initial_extruder'] = tMatch[1];
        }
        
        // CRITICAL: Ensure bed_temperature and bed_temperature_initial_layer have values for conditional evaluation
        // These must be set BEFORE defaults are applied, so conditionals can use them
        if (!vars['bed_temperature'] && vars['bed_temperature_initial_layer_single']) {
            vars['bed_temperature'] = vars['bed_temperature_initial_layer_single'];
        }
        if (!vars['bed_temperature_initial_layer'] && vars['bed_temperature_initial_layer_single']) {
            vars['bed_temperature_initial_layer'] = vars['bed_temperature_initial_layer_single'];
        }
        
        // Apply safe fallback defaults (CRITICAL: prevents "140¬∞C" error)
        const DEFAULTS = {
            'nozzle_temperature_initial_layer': '220',
            'bed_temperature_initial_layer_single': '60',
            'bed_temperature': '60', // Also set default for conditional evaluation
            'bed_temperature_initial_layer': '60', // Also set default for conditional evaluation
            'filament_max_volumetric_speed': '12',
            'nozzle_temperature_range_high': '240', // Default: nozzle_temp + 20
            'initial_extruder': '0'
        };
        
        for (const [key, defaultValue] of Object.entries(DEFAULTS)) {
            if (!vars[key]) {
                vars[key] = defaultValue;
            }
        }
        
        // Calculate nozzle_temperature_range_high from nozzle_temperature_initial_layer if not found
        if (!vars['nozzle_temperature_range_high'] || vars['nozzle_temperature_range_high'] === '240') {
            if (vars['nozzle_temperature_initial_layer']) {
                const nozzleTemp = parseInt(vars['nozzle_temperature_initial_layer'], 10);
                if (!isNaN(nozzleTemp)) {
                    vars['nozzle_temperature_range_high'] = (nozzleTemp + 20).toString();
                }
            }
        }
        
        return vars;
    }
    
    /**
     * Replaces variables in START_CODE_3MF with actual values
     * @param {string} startCode - START_CODE_3MF template
     * @param {Object} vars - Variable values object
     * @returns {string} Start code with variables replaced
     */
    function replaceStartCodeVariables(startCode, vars) {
        let result = startCode;
        const initialExtruder = vars['initial_extruder'] || '0';
        
        // STEP 1: Replace conditional {if} statements FIRST (before replacing [initial_extruder] in conditionals)
        // CRITICAL: Must evaluate ALL nested conditionals BEFORE replacing [initial_extruder] to avoid "bed_temperature255" issue
        // Replace conditional {if} statements for PLA fan
        // Pattern: {if filament_type[initial_extruder]=="PLA"} ... {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)} ... {endif} ... {endif}
        // We need to process nested conditionals from innermost to outermost
        
        // FIRST: Process the innermost conditional (bed_temperature check) - this must happen BEFORE [initial_extruder] replacement
        const innerBedTempPattern = /\{if\s+\(bed_temperature\[initial_extruder\]\s*>\s*45\)\|\|\(bed_temperature_initial_layer\[initial_extruder\]\s*>\s*45\)\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(innerBedTempPattern, (innerMatch, innerContent) => {
            // Use bed_temperature_initial_layer_single as fallback if bed_temperature or bed_temperature_initial_layer not found
            let bedTemp = parseFloat(vars['bed_temperature'] || vars['bed_temperature_initial_layer_single'] || '0');
            let bedTempInit = parseFloat(vars['bed_temperature_initial_layer'] || vars['bed_temperature_initial_layer_single'] || '0');
            
            // Also try hot_plate_temp_initial_layer or cool_plate_temp_initial_layer as fallback
            if (bedTemp === 0 && vars['hot_plate_temp_initial_layer']) {
                bedTemp = parseFloat(vars['hot_plate_temp_initial_layer']);
            }
            if (bedTempInit === 0 && vars['hot_plate_temp_initial_layer']) {
                bedTempInit = parseFloat(vars['hot_plate_temp_initial_layer']);
            }
            if (bedTemp === 0 && vars['cool_plate_temp_initial_layer']) {
                bedTemp = parseFloat(vars['cool_plate_temp_initial_layer']);
            }
            if (bedTempInit === 0 && vars['cool_plate_temp_initial_layer']) {
                bedTempInit = parseFloat(vars['cool_plate_temp_initial_layer']);
            }
            
            if (bedTemp > 45 || bedTempInit > 45) {
                // Return the content (M106 line) - [initial_extruder] will be replaced later in STEP 3
                return innerContent.trim();
            } else {
                return ''; // Remove content if condition is false
            }
        });
        
        // SECOND: Process the outer conditional (filament_type check)
        const plaFanPattern = /\{if\s+filament_type\[initial_extruder\]=="PLA"\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(plaFanPattern, (match, content) => {
            if (vars['filament_type'] && vars['filament_type'].toUpperCase() === 'PLA') {
                // Content already has inner conditionals processed, just return it
                // [initial_extruder] will be replaced later in STEP 3
                return content;
            } else {
                return ''; // Remove entire PLA fan block if not PLA
            }
        });
        
        // Replace curr_bed_type conditional
        const bedTypePattern = /\{if\s+curr_bed_type=="Textured PEI Plate"\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(bedTypePattern, (match, content) => {
            if (vars['curr_bed_type'] && vars['curr_bed_type'].includes('Textured PEI')) {
                return content; // Keep content for Textured PEI
            } else {
                return ''; // Remove content for other bed types
            }
        });
        
        // STEP 2: Replace {braces} variables (expressions) - AFTER conditionals but BEFORE [brackets]
        // Use default if not found (should not happen due to DEFAULTS, but safety check)
        const nozzleTemp = parseFloat(vars['nozzle_temperature_initial_layer'] || '220');
        if (!isNaN(nozzleTemp)) {
            // {nozzle_temperature_initial_layer[initial_extruder]-20}
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_extruder\]-20\}/g, (nozzleTemp - 20).toString());
            // {nozzle_temperature_initial_layer[initial_no_support_extruder]-20}
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_no_support_extruder\]-20\}/g, (nozzleTemp - 20).toString());
            // {nozzle_temperature_initial_layer[initial_extruder]} (without -20)
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_extruder\]\}/g, nozzleTemp.toString());
        }
        
        // Replace filament_max_volumetric_speed expression
        // Pattern: {filament_max_volumetric_speed[initial_extruder]/2.4053*60}
        if (vars['filament_max_volumetric_speed']) {
            const volumetricSpeed = parseFloat(vars['filament_max_volumetric_speed']);
            if (!isNaN(volumetricSpeed)) {
                // Calculate: volumetricSpeed / 2.4053 * 60
                const calculatedValue = Math.round((volumetricSpeed / 2.4053) * 60);
                result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, calculatedValue.toString());
                // Also handle without [initial_extruder] if present
                result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, calculatedValue.toString());
            } else {
                // Fallback: use safe default speed F1200
                result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, '1200');
                result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, '1200');
            }
        } else {
            // Fallback: use safe default speed F1200
            result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, '1200');
            result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, '1200');
        }
        
        // Handle other mathematical expressions in {braces}
        // Pattern: {expression} where expression can contain variables and math
        // Example: {outer_wall_volumetric_speed/(0.3*0.5) * 60}
        // For safety, we'll use a fixed value F1200 for complex speed calculations
        result = result.replace(/\{outer_wall_volumetric_speed[^}]*\}/g, '1200'); // Replace with safe default
        
        // Replace nozzle_temperature_range_high
        if (vars['nozzle_temperature_range_high']) {
            result = result.replace(/\{nozzle_temperature_range_high\[initial_extruder\]\}/g, vars['nozzle_temperature_range_high']);
        } else {
            // Fallback: use nozzle_temperature_initial_layer + 20 as safe default
            const defaultRangeHigh = vars['nozzle_temperature_initial_layer'] ? (parseInt(vars['nozzle_temperature_initial_layer'], 10) + 20).toString() : '240';
            result = result.replace(/\{nozzle_temperature_range_high\[initial_extruder\]\}/g, defaultRangeHigh);
        }
        
        // Replace {+0.0} constant (not a variable, but ensure it's handled)
        result = result.replace(/\{\+0\.0\}/g, '0.0');
        
        // STEP 3: Replace [brackets] variables LAST (simple replacements)
        // Use defaults if not found (should not happen due to DEFAULTS, but safety check)
        const nozzleTempFinal = vars['nozzle_temperature_initial_layer'] || '220';
        result = result.replace(/\[nozzle_temperature_initial_layer\]/g, nozzleTempFinal);
        
        // Replace first_layer_center_no_wipe_tower array (for A1 push-off alignment)
        if (DEBUG_MODE) console.log("[DIAG] replaceStartCodeVariables: Replacing first_layer_center_no_wipe_tower");
        if (DEBUG_MODE) console.log("[DIAG] vars['first_layer_center_no_wipe_tower']:", vars['first_layer_center_no_wipe_tower']);
        if (DEBUG_MODE) console.log("[DIAG] lastDebugData:", lastDebugData ? {minX: lastDebugData.minX, maxX: lastDebugData.maxX, minY: lastDebugData.minY, maxY: lastDebugData.maxY} : 'N/A');
        
        if (vars['first_layer_center_no_wipe_tower'] && Array.isArray(vars['first_layer_center_no_wipe_tower'])) {
            const centerX = vars['first_layer_center_no_wipe_tower'][0] || '128';
            const centerY = vars['first_layer_center_no_wipe_tower'][1] || '128';
            if (DEBUG_MODE) console.log("[DIAG] Using extracted array - X:", centerX, "Y:", centerY);
            result = result.replace(/\{first_layer_center_no_wipe_tower\[0\]\}/g, centerX);
            result = result.replace(/\{first_layer_center_no_wipe_tower\[1\]\}/g, centerY);
        } else {
            // Fallback: use bed center (128, 128) or model center from placement detection
            let fallbackX = '128';
            let fallbackY = '128';
            if (lastDebugData && lastDebugData.minX !== undefined && lastDebugData.maxX !== undefined) {
                fallbackX = ((parseFloat(lastDebugData.minX) + parseFloat(lastDebugData.maxX)) / 2).toFixed(2);
                if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for X fallback:", fallbackX);
            }
            if (lastDebugData && lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                fallbackY = ((parseFloat(lastDebugData.minY) + parseFloat(lastDebugData.maxY)) / 2).toFixed(2);
                if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for Y fallback:", fallbackY);
            } else {
                if (DEBUG_MODE) console.log("[DIAG] WARNING: lastDebugData.minY/maxY not available, using default Y: 128");
            }
            if (DEBUG_MODE) console.log("[DIAG] Using fallback values - X:", fallbackX, "Y:", fallbackY);
            result = result.replace(/\{first_layer_center_no_wipe_tower\[0\]\}/g, fallbackX);
            result = result.replace(/\{first_layer_center_no_wipe_tower\[1\]\}/g, fallbackY);
        }
        
        const bedTempFinal = vars['bed_temperature_initial_layer_single'] || '60';
        result = result.replace(/\[bed_temperature_initial_layer_single\]/g, bedTempFinal);
        
        const initialExtruderFinal = vars['initial_extruder'] || '0';
        result = result.replace(/\[initial_extruder\]/g, initialExtruderFinal);
        
        // A1-specific: Replace [initial_no_support_extruder] (maps to initial_extruder)
        result = result.replace(/\[initial_no_support_extruder\]/g, initialExtruderFinal);
        
        // A1-specific: Replace {nozzle_temperature_initial_layer[initial_no_support_extruder]} expressions
        if (!isNaN(nozzleTemp)) {
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_no_support_extruder\]\}/g, nozzleTemp.toString());
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_no_support_extruder\]-20\}/g, (nozzleTemp - 20).toString());
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_no_support_extruder\]-50\}/g, (nozzleTemp - 50).toString());
        }
        
        // A1-specific: Replace {filament_type[initial_no_support_extruder]} and {filament_max_volumetric_speed[initial_no_support_extruder]}
        if (vars['filament_type']) {
            result = result.replace(/\{filament_type\[initial_no_support_extruder\]\}/g, vars['filament_type']);
        }
        if (vars['filament_max_volumetric_speed']) {
            const volumetricSpeed = parseFloat(vars['filament_max_volumetric_speed']);
            if (!isNaN(volumetricSpeed)) {
                const calculatedValue = Math.round((volumetricSpeed / 2.4053) * 60);
                result = result.replace(/\{filament_max_volumetric_speed\[initial_no_support_extruder\]\/2\.4053\*60\}/g, calculatedValue.toString());
            }
        }
        
        // Remove any remaining unmatched variables (leave them as-is for printer to evaluate)
        // This is safer than removing them completely
        
        return result;
    }

    async function process3MFFile(file, loops) {
        // Show loading state
        setLoadingState(true, "Processing 3MF file...");
        updateProgress(10, "Reading 3MF file...");
        
        // Remove file extension (only the last one to handle cases like "file.gcode.3mf")
        originalFilename = file.name.replace(/\.[^.]*$/, "") || "looprint_factorian";
        
        try {
            updateProgress(10, "Reading 3MF file...");
            
            // Check if JSZip is available
            if (typeof JSZip === 'undefined') {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: JSZip library not loaded. Please refresh the page.");
                return;
            }
            
            // Read file as array buffer
            const arrayBuffer = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            updateProgress(25, "Detecting printer model from 3MF metadata...");
            
            // Detect printer model from 3MF metadata
            let detectedPrinterModel = null;
            try {
                // Method 1: Check slice_info.config for printer_model_id (most reliable)
                // A1 uses "N2S" as printer_model_id
                const sliceInfoFile = zip.file("Metadata/slice_info.config");
                if (DEBUG_MODE) console.log("sliceInfoFile found:", !!sliceInfoFile);
                if (sliceInfoFile) {
                    try {
                        const sliceInfoContent = await sliceInfoFile.async('string');
                        if (DEBUG_MODE) console.log("slice_info.config content preview:", sliceInfoContent.substring(0, 500));
                        
                        // Look for printer_model_id in XML: <metadata key="printer_model_id" value="N2S"/>
                        // Try multiple regex patterns to catch different XML formats
                        // Pattern 1: key="printer_model_id" value="N2S" (most common - matches <metadata key="printer_model_id" value="N2S"/>)
                        let modelIdMatch = sliceInfoContent.match(/key=["']printer_model_id["'][^>]*value=["']([^"']+)["']/i);
                        if (!modelIdMatch) {
                            // Pattern 2: printer_model_id followed by value="N2S" anywhere in the line
                            modelIdMatch = sliceInfoContent.match(/printer_model_id[^>]*value=["']([^"']+)["']/i);
                        }
                        if (!modelIdMatch) {
                            // Pattern 3: Find the line containing printer_model_id and extract value
                            const lines = sliceInfoContent.split('\n');
                            for (const line of lines) {
                                if (line.includes('printer_model_id')) {
                                    const valueMatch = line.match(/value=["']([^"']+)["']/i);
                                    if (valueMatch) {
                                        modelIdMatch = valueMatch;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (modelIdMatch) {
                            const modelId = modelIdMatch[1].toUpperCase().trim();
                            if (DEBUG_MODE) console.log("Found printer_model_id:", modelId);
                            
                            // Check for X1/X1C first (before P1 check, since X1 contains 'X1' which would match P1 check)
                            // X1/X1C uses BL-P001 as printer_model_id (found in actual X1.gcode.3mf file)
                            if (modelId === 'BL-P001' || modelId === 'BL-P002' || modelId === 'C12' || modelId === 'X1' || modelId === 'X1C' || 
                                (modelId.includes('X1') && !modelId.includes('P1'))) {
                                detectedPrinterModel = 'x1';
                                if (DEBUG_MODE) console.log("Detected X1 from printer_model_id");
                            } else if (modelId === 'N1' || (modelId.includes('A1Mini') || modelId.includes('A1 Mini'))) {
                                // A1 Mini uses N1 as printer_model_id (verified from actual A1 mini center test.gcode.3mf file)
                                detectedPrinterModel = 'A1Mini';
                                if (DEBUG_MODE) console.log("Detected A1 Mini from printer_model_id");
                            } else if (modelId === 'N2S' || modelId.includes('A1')) {
                                detectedPrinterModel = 'A1';
                                if (DEBUG_MODE) console.log("Detected A1 from printer_model_id");
                            } else if (modelId === 'C11' || modelId.includes('P1')) {
                                detectedPrinterModel = 'P1';
                                if (DEBUG_MODE) console.log("Detected P1 from printer_model_id");
                            }
                        } else {
                            if (DEBUG_MODE) console.warn("No printer_model_id match found in slice_info.config");
                        }
                    } catch (e) {
                        if (DEBUG_MODE) console.warn("Could not read slice_info.config:", e);
                    }
                } else {
                    if (DEBUG_MODE) console.warn("slice_info.config file not found in 3MF");
                }
                
                // Method 2: Check project_settings.config for A1/P1 references in profiles
                if (!detectedPrinterModel) {
                    const projectSettingsFile = zip.file("Metadata/project_settings.config");
                    if (projectSettingsFile) {
                        try {
                            const projectSettingsContent = await projectSettingsFile.async('string');
                            if (DEBUG_MODE) console.log("Checking project_settings.config for printer model...");
                            
                            // Check for X1/X1C first (before P1 check)
                            if (projectSettingsContent.includes('@BBL X1C') || 
                                projectSettingsContent.includes('@BBL X1') ||
                                projectSettingsContent.match(/["']([^"']*X1[^"']*)["']/)) {
                                detectedPrinterModel = 'x1';
                                if (DEBUG_MODE) console.log("Detected X1 from project_settings.config");
                            } else if (projectSettingsContent.includes('@BBL A1 Mini') || 
                                projectSettingsContent.match(/["']([^"']*A1Mini[^"']*)["']/) ||
                                projectSettingsContent.match(/["']([^"']*A1 Mini[^"']*)["']/)) {
                                detectedPrinterModel = 'A1Mini';
                                if (DEBUG_MODE) console.log("Detected A1 Mini from project_settings.config");
                            } else if (projectSettingsContent.includes('@BBL A1') || 
                                projectSettingsContent.match(/["']([^"']*A1[^"']*)["']/) ||
                                projectSettingsContent.match(/;=====\s*A1\s*\d+/i)) {
                                detectedPrinterModel = 'A1';
                                if (DEBUG_MODE) console.log("Detected A1 from project_settings.config");
                            } else if (projectSettingsContent.includes('@BBL P1P') || 
                                       projectSettingsContent.includes('@BBL P1S') ||
                                       projectSettingsContent.includes('@BBL P1') || 
                                       projectSettingsContent.match(/["']([^"']*P1[^"']*)["']/)) {
                                detectedPrinterModel = 'P1';
                                if (DEBUG_MODE) console.log("Detected P1 from project_settings.config");
                            }
                        } catch (e) {
                            if (DEBUG_MODE) console.warn("Could not read project_settings.config:", e);
                        }
                    } else {
                        if (DEBUG_MODE) console.warn("project_settings.config file not found in 3MF");
                    }
                }
                
                // Method 3: Fallback - Check G-code header if available
                if (!detectedPrinterModel) {
                    const gcodeFiles = [];
                    zip.forEach((relativePath, file) => {
                        if (relativePath.match(GCODE_FILE_IN_3MF_REGEX)) {
                            gcodeFiles.push(relativePath);
                        }
                    });
                    if (gcodeFiles.length > 0) {
                        try {
                            const gcodePreview = await zip.file(gcodeFiles[0]).async('string');
                            // Check G-code header for printer model
                            const headerLines = gcodePreview.split('\n').slice(0, 100).join('\n');
                            // Look for printer model markers in G-code header
                            // Check for X1 first (before P1 check)
                            if (headerLines.includes(';===== machine: X1') || 
                                headerLines.includes('@BBL X1C') || 
                                headerLines.includes('@BBL X1') ||
                                headerLines.match(/machine.*X1/i)) {
                                detectedPrinterModel = 'x1';
                                if (DEBUG_MODE) console.log("Detected X1 from G-code header");
                            } else if (headerLines.match(/;=====\s*A1\s*mini\s*\d+/i) || 
                                (headerLines.includes('A1 mini') || headerLines.includes('A1Mini'))) {
                                detectedPrinterModel = 'A1Mini';
                                if (DEBUG_MODE) console.log("Detected A1 Mini from G-code header");
                            } else if (headerLines.match(/;=====\s*A1\s*\d+/i) || 
                                (headerLines.includes('A1') && headerLines.match(/machine.*A1/i))) {
                                detectedPrinterModel = 'A1';
                                if (DEBUG_MODE) console.log("Detected A1 from G-code header");
                            } else if (headerLines.includes('P1') || 
                                       headerLines.match(/machine.*P1/i)) {
                                detectedPrinterModel = 'P1';
                                if (DEBUG_MODE) console.log("Detected P1 from G-code header");
                            }
                        } catch (e) {
                            if (DEBUG_MODE) console.warn("Could not read G-code file:", e);
                        }
                    }
                }
            } catch (e) {
                if (DEBUG_MODE) console.warn("Could not detect printer model from 3MF:", e);
            }
            
            if (DEBUG_MODE) console.log("Final detectedPrinterModel:", detectedPrinterModel);
            
            // Auto-select and lock detected model if found
            if (detectedPrinterModel) {
                if (DEBUG_MODE) console.log("Auto-selecting and locking printer model:", detectedPrinterModel);
                const modelSelect = document.getElementById("printerModel");
                const autoDetectedNote = document.getElementById("autoDetectedPrinterNote");
                
                if (modelSelect) {
                    // Store auto-detected model
                    autoDetectedPrinterModel = detectedPrinterModel;
                    
                    // Auto-select the detected model
                    modelSelect.value = detectedPrinterModel;
                    handlePrinterModelChange();
                    
                    // Lock the select and show note
                    modelSelect.disabled = true;
                    if (autoDetectedNote) {
                        autoDetectedNote.style.display = 'block';
                    }
                    
                    // Show confirmation message
                    const detectedModelName = detectedPrinterModel === 'A1' ? 'Bambu Lab A1/A1 Mini' : (detectedPrinterModel === 'x1' ? 'Bambu Lab X1/X1C' : 'Bambu Lab P1/P1S');
                    showStatus("validationWarning", "success", `‚úì Printer model auto-detected: ${detectedModelName}. Selector locked to match file.`);
                }
            }
            
            updateProgress(30, "Finding G-code file...");
            
            // Find G-code file(s) in Metadata folder
            const gcodeFiles = [];
            zip.forEach((relativePath, file) => {
                if (relativePath.match(GCODE_FILE_IN_3MF_REGEX)) {
                    gcodeFiles.push(relativePath);
                }
            });
            
            if (gcodeFiles.length === 0) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: No G-code file found in 3MF structure. Expected: Metadata/plate_*.gcode");
                return;
            }
            
            // Process first G-code file (support multiple plates later if needed)
            const gcodePath = gcodeFiles[0];
            const gcodeContent = await zip.file(gcodePath).async('string');
            
            updateProgress(40, "Processing G-code...");
            
            // Validate G-code (already validated in validateFileImmediate, but double-check)
            // Check for both the signature and watermarks to ensure file hasn't been looped
            const hasLooprint = gcodeContent.includes(LOOPRINT_SIGNATURE) ||
                               gcodeContent.includes("Generated by Looprint") ||
                               gcodeContent.includes("Contact: Nicki.Andersen@gmail.com") ||
                               gcodeContent.includes("github.com/NickiAndersen/looprint");
            
            if (hasLooprint) {
                setLoadingState(false);
                showStatus("validationErrorLooprint", "error");
                return;
            }
            
            updateProgress(50, "Building loop structure...");
            updateStatsDisplay(gcodeContent, loops);
            
            // Extract max_z_height from G-code header
            const maxZMatch = gcodeContent.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let maxZHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                maxZHeight = parseFloat(maxZMatch[1]);
                if (isNaN(maxZHeight) || maxZHeight <= 0 || maxZHeight > MAX_Z_HEIGHT_MM) {
                    if (DEBUG_MODE) console.warn(`Invalid max_z_height value: ${maxZMatch[1]}`);
                    maxZHeight = null;
                }
            }
            
            // Extract first_layer_center_no_wipe_tower for A1 push-off alignment
            // This is needed for A1 end code template variable replacement
            if (DEBUG_MODE) console.log("[DIAG] processGcodeFile: Extracting variables for printer model:", currentPrinterModel);
            if (DEBUG_MODE) console.log("[DIAG] processGcodeFile: lastDebugData available:", !!lastDebugData, lastDebugData ? {minX: lastDebugData.minX, maxX: lastDebugData.maxX, minY: lastDebugData.minY, maxY: lastDebugData.maxY} : 'N/A');
            
            const gcodeStructure = parseGcodeStructure(gcodeContent);
            const gcodeConfigForEnd = gcodeStructure.config || '';
            const endCodeVars = extractVariableValues(gcodeContent, gcodeConfigForEnd);
            if (DEBUG_MODE) console.log("[DIAG] processGcodeFile: Extracted variable values:", Object.keys(endCodeVars));
            if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                if (DEBUG_MODE) console.log("[DIAG] processGcodeFile:", currentPrinterModel, "- endCodeVars['first_layer_center_no_wipe_tower']:", endCodeVars['first_layer_center_no_wipe_tower']);
            }
            
            let firstLayerCenterX = '128'; // Default to bed center
            let firstLayerCenterY = '128';
            if (endCodeVars['first_layer_center_no_wipe_tower'] && Array.isArray(endCodeVars['first_layer_center_no_wipe_tower'])) {
                firstLayerCenterX = endCodeVars['first_layer_center_no_wipe_tower'][0] || '128';
                firstLayerCenterY = endCodeVars['first_layer_center_no_wipe_tower'][1] || '128';
                if (DEBUG_MODE) console.log("[DIAG] Using extracted array values - X:", firstLayerCenterX, "Y:", firstLayerCenterY);
            } else {
                // Fallback: Calculate from model placement (lastDebugData)
                if (lastDebugData && lastDebugData.minX !== undefined && lastDebugData.maxX !== undefined) {
                    firstLayerCenterX = ((parseFloat(lastDebugData.minX) + parseFloat(lastDebugData.maxX)) / 2).toFixed(2);
                    if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for X - calculated:", firstLayerCenterX);
                }
                if (lastDebugData && lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                    firstLayerCenterY = ((parseFloat(lastDebugData.minY) + parseFloat(lastDebugData.maxY)) / 2).toFixed(2);
                    if (DEBUG_MODE) console.log("[DIAG] Using lastDebugData for Y - calculated:", firstLayerCenterY);
                } else {
                    if (DEBUG_MODE) console.log("[DIAG] WARNING: lastDebugData.minY/maxY not available, using default Y: 128");
                }
            }
            
            if (DEBUG_MODE) console.log("[DIAG] Final values - firstLayerCenterX:", firstLayerCenterX, "firstLayerCenterY:", firstLayerCenterY);
            
            // Get end code - A1 uses different element
            let endCodeElement;
            if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                endCodeElement = document.getElementById('endA1Code');
            } else {
                endCodeElement = document.getElementById(`end${currentDirection.charAt(0).toUpperCase() + currentDirection.slice(1)}Code`);
            }
            if (!endCodeElement) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: Could not find end code element. Please refresh the page.");
                return;
            }
            let activeEndCode = endCodeElement.value;
            
            if (DEBUG_MODE) {
                console.log("[DIAG] processGcodeFile: endCodeElement found:", !!endCodeElement);
                console.log("[DIAG] processGcodeFile: endCodeElement.value length:", activeEndCode ? activeEndCode.length : 0);
                console.log("[DIAG] processGcodeFile: currentPrinterModel:", currentPrinterModel);
            }
            
            // CRITICAL: If end code is empty, generate it now (for A1, P1, and X1)
            if (!activeEndCode || activeEndCode.trim().length === 0) {
                if (DEBUG_MODE) console.warn("[DIAG] processGcodeFile: End code is empty, generating now for model:", currentPrinterModel);
                
                if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                    // Generate A1/A1Mini end code using current settings
                    const temp = getCooldownTemp();
                    const offset = currentOffset;
                    const modelCenterY = calculateModelCenterY();
                    if (currentPrinterModel === 'A1Mini') {
                        activeEndCode = getA1MiniEndCode(temp, offset, modelCenterY);
                    } else {
                        activeEndCode = getA1EndCode(temp, offset, modelCenterY);
                    }
                    endCodeElement.value = activeEndCode;
                    if (DEBUG_MODE) console.log("[DIAG] processGcodeFile: Generated", currentPrinterModel, "end code, length:", activeEndCode.length);
                } else {
                    // P1/X1: Generate end code for current direction (X1 uses same push system as P1)
                    // First ensure all P1/X1 end codes are generated
                    updateEndCodeTextareas();
                    // Then get the code for current direction
                    activeEndCode = endCodeElement.value;
                    if (DEBUG_MODE) console.log("[DIAG] processGcodeFile: Generated", currentPrinterModel, "end code for direction:", currentDirection, "length:", activeEndCode ? activeEndCode.length : 0);
                }
            }
            
            if (!activeEndCode || activeEndCode.trim().length === 0) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: End code is empty. Please refresh the page.");
                return;
            }
            
            // Replace first_layer_center_no_wipe_tower in end code (before max_layer_z replacement)
            activeEndCode = activeEndCode.replace(/\{first_layer_center_no_wipe_tower\[0\]\}/g, firstLayerCenterX);
            activeEndCode = activeEndCode.replace(/\{first_layer_center_no_wipe_tower\[1\]\}/g, firstLayerCenterY);
            
            // Replace {max_layer_z} with actual value and evaluate conditionals
            if (maxZHeight !== null && !isNaN(maxZHeight)) {
                // CRITICAL: Replace conditional logic FIRST (before variable replacement) to ensure structure is intact
                // Factorian uses {if (max_layer_z ) > 41} with space - handle both formats
                activeEndCode = activeEndCode.replace(/\{if\s*\(?\s*max_layer_z\s*\)?\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                    const thresholdNum = parseFloat(threshold);
                    if (isNaN(thresholdNum)) {
                        if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                        return match;
                    }
                    if (maxZHeight > thresholdNum) {
                        return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                     .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                         const numVal = parseFloat(val);
                                         if (isNaN(numVal)) {
                                             if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                             return m;
                                         }
                                         const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                         return result.toFixed(2);
                                     }).trim();
                    } else {
                        return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                  .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                      const numVal = parseFloat(val);
                                                      if (isNaN(numVal)) {
                                                          if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                          return m;
                                                      }
                                                      const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                      return result.toFixed(2);
                                                  }).trim() : '';
                    }
                });
                // Now replace remaining {max_layer_z} variables (outside conditionals)
                activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                    const numVal = parseFloat(val);
                    if (isNaN(numVal)) {
                        if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                        return match;
                    }
                    const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                    return result.toFixed(2);
                });
            } else {
                // Fallback: Use safe default (50mm) if max_z_height not found
                if (DEBUG_MODE) console.warn("max_z_height not found in G-code header, using fallback 50mm");
                maxZHeight = 50; // Safe fallback for template replacement
                // Continue with template replacement using fallback value
                activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                    const numVal = parseFloat(val);
                    if (isNaN(numVal)) {
                        if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                        return match;
                    }
                    const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                    return result.toFixed(2);
                });
                // Evaluate conditionals with fallback value
                // Factorian uses {if (max_layer_z ) > 41} with space - handle both formats
                activeEndCode = activeEndCode.replace(/\{if\s*\(?\s*max_layer_z\s*\)?\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                    const thresholdNum = parseFloat(threshold);
                    if (isNaN(thresholdNum)) {
                        if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                        return match;
                    }
                    if (maxZHeight > thresholdNum) {
                        return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                     .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                         const numVal = parseFloat(val);
                                         if (isNaN(numVal)) {
                                             if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                             return m;
                                         }
                                         const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                         return result.toFixed(2);
                                     }).trim();
                    } else {
                        return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                  .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                      const numVal = parseFloat(val);
                                                      if (isNaN(numVal)) {
                                                          if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                          return m;
                                                      }
                                                      const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                      return result.toFixed(2);
                                                  }).trim() : '';
                    }
                });
                // Show warning to user
                showStatus("validationWarning", "warning", 
                    "Warning: Could not extract model height (max_z_height) from G-code header. " +
                    "Using fallback value of 50mm. Please verify the generated G-code is correct.");
            }
            
            // Extract print G-code only (remove existing end code)
            const endCodeStartMarker = END_CODE_START_MARKER;
            let printGcodeOnly = gcodeContent;
            const endCodeIndex = gcodeContent.lastIndexOf(endCodeStartMarker);
            if (endCodeIndex !== -1) {
                printGcodeOnly = gcodeContent.substring(0, endCodeIndex).trim();
            } else {
                if (DEBUG_MODE) console.warn("Factorian End Code marker not found. Looping entire file without safely deleting end code.");
            }
            
            // Find where executable block starts (after CONFIG_BLOCK)
            const executableBlockStart = printGcodeOnly.indexOf('; EXECUTABLE_BLOCK_START');
            let gcodeHeader = '';
            let gcodeConfig = '';
            let printGcodeExecutable = printGcodeOnly;
            
            if (executableBlockStart !== -1) {
                // Split into header/config and executable parts
                gcodeHeader = printGcodeOnly.substring(0, executableBlockStart).trim();
                printGcodeExecutable = printGcodeOnly.substring(executableBlockStart).trim();
                
                // Find CONFIG_BLOCK
                const configStart = gcodeHeader.indexOf('; CONFIG_BLOCK_START');
                const configEnd = gcodeHeader.indexOf('; CONFIG_BLOCK_END');
                if (configStart !== -1 && configEnd !== -1) {
                    gcodeConfig = gcodeHeader.substring(configStart, configEnd + '; CONFIG_BLOCK_END'.length);
                    gcodeHeader = gcodeHeader.substring(0, configStart).trim() + '\n' + gcodeHeader.substring(configEnd + '; CONFIG_BLOCK_END'.length).trim();
                }
                
                // Extract setup commands (M73, M201, etc.) and FEATURE: Custom, but remove original start code
                // Structure: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> start code -> print G-code
                // We want: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> START_CODE_3MF -> print G-code
                
                // Split into: setup part (up to FEATURE: Custom) and print part (after original start code)
                let setupPart = '';
                let printPart = '';
                
                const featureIndex = printGcodeExecutable.indexOf('; FEATURE: Custom');
                if (featureIndex !== -1) {
                    // Keep everything up to and including "FEATURE: Custom"
                    setupPart = printGcodeExecutable.substring(0, featureIndex + '; FEATURE: Custom'.length);
                    
                    // After FEATURE: Custom, there's original start code, then print G-code
                    const afterFeature = printGcodeExecutable.substring(featureIndex + '; FEATURE: Custom'.length);
                    
                    // ROBUST REGEX: Leder efter standard Bambu/Orca lag-skift eller Z-h√∏jde mark√∏rer
                    // Prioriteret liste af mark√∏rer der indikerer starten af faktisk print
                    // CRITICAL: Layer markers must come FIRST - they are the most reliable indicators
                    // G1 Z commands are removed because they match too early (in old start code)
                    const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                    
                    // Find where original start code ends using robust regex
                    // CRITICAL: We need to find the FIRST occurrence of the marker, not any occurrence
                    const splitMatch = afterFeature.match(startCodeEndRegex);
                    
                    if (!splitMatch) {
                        if (DEBUG_MODE) {
                            console.warn("WARNING: Could not find start point (Layer Change) in file. Start code may be duplicated!");
                            console.warn("Attempting fallback: Split after last M109 (Wait for temp)...");
                        }
                        
                        // Fallback: Try to find last M109 (Wait for temp) which marks the end of start code
                        const m109Matches = [...afterFeature.matchAll(/M109\s+S\d+/gi)];
                        if (m109Matches.length > 0) {
                            const lastM109 = m109Matches[m109Matches.length - 1];
                            const afterM109 = afterFeature.substring(lastM109.index + lastM109[0].length);
                            
                            // Try to find first print command after M109
                            const firstPrintMatch = afterM109.match(/(M73\s+P\d+|G1\s+X|G0\s+X|;LAYER|; layer)/i);
                            if (firstPrintMatch) {
                                printPart = afterM109.substring(firstPrintMatch.index).trim();
                            } else {
                                // Last fallback: use everything after last M109
                                printPart = afterM109.trim();
                                if (DEBUG_MODE) console.warn("Using everything after last M109 as fallback - start code may still be duplicated!");
                            }
                        } else {
                            // No M109 found - try to find first print command
                            const firstPrintMatch = afterFeature.match(/(M73\s+P\d+|G1\s+X|G0\s+X|G28|;LAYER|; layer)/i);
                            if (firstPrintMatch) {
                                printPart = afterFeature.substring(firstPrintMatch.index).trim();
                            } else {
                                // Last fallback: use everything after FEATURE: Custom (NOT IDEAL - start code may be duplicated)
                                printPart = afterFeature.trim();
                                if (DEBUG_MODE) console.error("CRITICAL: Could not find start point. Start code will likely be duplicated!");
                            }
                        }
                    } else {
                        // Found a match - start from the matched position
                        // CRITICAL: splitMatch.index gives us the position of the marker in afterFeature
                        // We want everything AFTER the marker, not before it
                        let layerStart = afterFeature.substring(splitMatch.index);
                        
                        // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                        // These are remnants from the original start code that should be removed
                        const lines = layerStart.split('\n');
                        let startIndex = 0;
                        
                        // Skip marker line and any following M104 S140 or M109 S140 commands
                        for (let i = 0; i < Math.min(lines.length, 20); i++) {
                            const line = lines[i].trim();
                            // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                            if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                                startIndex += lines[i].length + 1; // +1 for newline
                                continue;
                            }
                            // Skip M104 S140 or M109 S140 commands
                            if (line.match(/^M(104|109)\s+S140/i)) {
                                startIndex += lines[i].length + 1;
                                continue;
                            }
                            // Found first non-temp command - this is where print actually starts
                            break;
                        }
                        
                        printPart = layerStart.substring(startIndex).trim();
                        
                        // Safety check: If printPart still contains old start code, try to find layer marker again
                        // Note: This is a conservative check - some valid G-code may match these patterns
                        const hasPotentialStartCode = printPart.includes('G1 Z5 F300') || 
                                                      printPart.includes('M17 X1.2 Y1.2 Z0.75') || 
                                                      printPart.includes('G90\nM17 X1.2');
                        if (hasPotentialStartCode) {
                            if (DEBUG_MODE) console.log('[DIAG] process3MFFile: Potential start code detected, checking for layer markers...');
                            // Try to find where the actual print starts by looking for layer markers
                            const layerMarkerMatch = printPart.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i);
                            if (layerMarkerMatch) {
                                printPart = printPart.substring(layerMarkerMatch.index);
                                if (DEBUG_MODE) console.log('[DIAG] process3MFFile: Found layer marker, trimmed printPart');
                            } else {
                                if (DEBUG_MODE) console.log('[DIAG] process3MFFile: No layer marker found, keeping printPart as-is');
                            }
                        }
                    }
                } else {
                    // If no FEATURE: Custom, keep everything as is
                    setupPart = printGcodeExecutable;
                }
                
                // Store both parts separately so we can insert START_CODE_3MF between them
                printGcodeExecutable = { setup: setupPart, print: printPart };
            }
            
            updateProgress(60, `Generating ${loops} loops...`);
            
            // Extract variable values from CONFIG_BLOCK or G-code
            const variableValues = extractVariableValues(gcodeContent, gcodeConfig);
            
            // Replace variables in start code template with actual values
            const startCodeTemplate = getStartCodeTemplate();
            const startCodeWithVars = replaceStartCodeVariables(startCodeTemplate, variableValues);
            
            // Build looped G-code with start code in each loop
            const parts = [];
            parts.push(`; ===== ${LOOPRINT_SIGNATURE} (Start) =====`);
            parts.push(`; Source: ${file.name}`);
            parts.push(`; Loops: ${loops}`);
            parts.push(`; Generated: ${new Date().toISOString()}`);
            parts.push(`; Generated by Looprint`);
            parts.push(`; Contact: Nicki.Andersen@gmail.com`);
            parts.push(`; GitHub: https://github.com/NickiAndersen/looprint`);
            parts.push(`\n`);
            
            for (let i = 1; i <= loops; i++) {
                const loopProgress = 60 + (i / loops) * 30;
                updateProgress(loopProgress, `Generating loop ${i} of ${loops}...`);
                
                parts.push(`; >>> LOOP ${i} / ${loops} <<<`);
                
                if (i === 1) {
                    // First loop: include header and config
                    if (gcodeHeader) {
                        parts.push(gcodeHeader);
                        parts.push('\n');
                    }
                    if (gcodeConfig) {
                        parts.push(gcodeConfig);
                        parts.push('\n');
                    }
                } else {
                    // Subsequent loops: M400 safety wait
                    parts.push("M400 ; Looprint safety: Wait for buffer clear before next loop");
                    parts.push('\n');
                }
                
                // Add setup part (EXECUTABLE_BLOCK_START, setup commands, FEATURE: Custom)
                if (typeof printGcodeExecutable === 'object' && printGcodeExecutable.setup) {
                    parts.push(printGcodeExecutable.setup);
                    parts.push('\n');
                    
                    // Add start code for each loop (AFTER FEATURE: Custom, BEFORE print G-code)
                    // Use startCodeWithVars which has variables replaced with actual values
                    parts.push(startCodeWithVars);
                    parts.push('\n');
                    
                    // Ensure temperature is set correctly after start code
                    // startCodeWithVars should already have correct temperature, but add safety check
                    if (printGcodeExecutable.print) {
                        // Check if print G-code starts with layer marker (no temp commands)
                        const printStart = printGcodeExecutable.print.trim();
                        if (printStart.match(/^;LAYER_CHANGE|^; layer|^;LAYER/i)) {
                            // Print starts directly with layer marker - ensure temp is set
                            // startCodeWithVars should already set temp, but add explicit command if we have the value
                            if (variableValues['nozzle_temperature_initial_layer']) {
                                parts.push(`; Ensure nozzle temperature is set for printing\n`);
                                parts.push(`M104 S${variableValues['nozzle_temperature_initial_layer']} ; Set nozzle temp for printing\n`);
                                parts.push('\n');
                            }
                        }
                        parts.push(printGcodeExecutable.print);
                        parts.push('\n');
                    }
                } else {
                    // Fallback: if structure is different, use as string
                    // Check if START_CODE_3MF already exists to prevent duplication
                    const printGcodeStr = typeof printGcodeExecutable === 'string' ? printGcodeExecutable : String(printGcodeExecutable);
                    if (!printGcodeStr.includes('machine: P1S') && !printGcodeStr.includes('FactorianDesigns')) {
                        // Original start code not found, safe to add
                        parts.push(printGcodeExecutable);
                        parts.push('\n');
                        parts.push(startCodeWithVars);
                        parts.push('\n');
                    } else {
                        // Start code already present, don't duplicate
                        parts.push(printGcodeExecutable);
                        parts.push('\n');
                    }
                }
                
                // Add end code (push-off)
                parts.push(activeEndCode);
                parts.push('\n');
            }
            
            parts.push(`; >>> END OF PRINT LOOPS <<<`);
            parts.push(`; ===== ${LOOPRINT_SIGNATURE} (End) =====`);
            
            updateProgress(95, "Repacking 3MF file...");
            
            // Replace G-code in zip
            const modifiedGcode = parts.join('\n');
            zip.file(gcodePath, modifiedGcode);
            
            // Generate new 3MF file
            updateProgress(97, "Generating final 3MF file...");
            const blob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 }
            });
            
            finalFileContent = blob;
            
            updateProgress(100, "Complete!");
            setLoadingState(false);
            
            const outputEl = DOM.output || document.getElementById("output");
            outputEl.style.display = "block";
            document.getElementById("statSourceName").textContent = file.name;
            showStatus("outputReady", "success");
            
            setTimeout(() => updateProgress(0), 500);
            // Scroll to output box after a short delay to ensure it's visible
            setTimeout(() => {
                outputEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
            
        } catch (error) {
            setLoadingState(false);
            let errorMessage = "Error processing 3MF file: " + (error.message || "Unknown error");
            
            if (error.message && error.message.includes("JSZip")) {
                errorMessage = "Error: JSZip library failed to load. Please refresh the page.";
            }
            
            showStatus("validationErrorParse", "error", errorMessage);
            if (DEBUG_MODE) console.error("Critical error during 3MF file processing:", error);
        }
    }
    // --- SLUT P√Ö process3MFFile() FUNKTION ---
    
    /**
     * Sanitizes filename to prevent security issues
     * @param {string} filename - Original filename
     * @returns {string} Sanitized filename
     */
    function sanitizeFilename(filename) {
        // Remove or replace dangerous characters
        return filename
            .replace(/[<>:"/\\|?*]/g, '_')  // Replace dangerous chars with underscore
            .replace(/\.\./g, '_')           // Remove parent directory references
            .replace(/^\.+|\.+$/g, '')       // Remove leading/trailing dots
            .trim()
            .substring(0, 200);              // Limit length
    }

    /**
     * Downloads the generated looped file (G-code or 3MF)
     * Filename is sanitized for security
     * Handles both string and Blob content
     * Uses try/finally to ensure URL cleanup (prevents memory leaks)
     */
    async function downloadFile() {
        if (!finalFileContent) return;
        
        let blob;
        
        if (currentFileType === "3mf") {
            // For 3MF files, ensure correct MIME type to prevent browser from auto-unzipping
            if (finalFileContent instanceof Blob) {
                // Recreate blob with correct MIME type
                const arrayBuffer = await finalFileContent.arrayBuffer();
                blob = new Blob([arrayBuffer], { type: "model/3mf" });
            } else {
                // Should not happen for 3MF, but handle it
                blob = new Blob([finalFileContent], { type: "model/3mf" });
            }
        } else {
            // For G-code files
            blob = finalFileContent instanceof Blob 
                ? finalFileContent 
                : new Blob([finalFileContent], { type: "text/plain" });
        }
        
        let url = null;
        try {
            url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        
            // Use cached DOM element if available, otherwise query
            const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
            let filename = `${originalFilename}_Looprint_x${loopCountEl.value}`;
        
        if (currentFilamentUsage) {
            filename += `_${currentFilamentUsage}g`;
        }
        
            filename += currentFileType === "3mf" ? ".3mf" : ".gcode";
        
            // Sanitize filename before download to prevent security issues
            a.download = sanitizeFilename(filename);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        } finally {
            // Always revoke URL to prevent memory leaks
            if (url) {
        URL.revokeObjectURL(url);
            }
        }
    }

    /**
     * Copies code to clipboard using modern Clipboard API
     * Falls back to execCommand for older browsers
     * @param {string} id - ID of textarea element to copy from
     */
    async function copyCode(id) {
        const el = document.getElementById(id);
        const textToCopy = el.value;
        
        try {
            // Try modern Clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(textToCopy);
            showStatus('copySuccess', 'success');
            } else {
                // Fallback to execCommand for older browsers
                el.select();
                el.setSelectionRange(0, 99999); // For mobile devices
                const successful = document.execCommand("copy");
                if (successful) {
                    showStatus('copySuccess', 'success');
                } else {
                    throw new Error('execCommand failed');
                }
            }
        } catch (err) {
            if (DEBUG_MODE) console.error('Failed to copy:', err);
            showStatus('copyError', 'error');
        }
    }

    /**
     * Applies Z offset value with validation
     */
    /**
     * Updates push lane offset and validates against model placement
     * Shows warning if offset is auto-adjusted and displays maximum possible offset
     */
    function updatePushLaneOffset() {
        try {
            const inputEl = document.getElementById("pushLaneOffsetInput");
            if (!inputEl) {
                if (DEBUG_MODE) console.warn("pushLaneOffsetInput element not found");
                return;
            }
            
            const val = parseFloat(inputEl.value);
            const statusEl = document.getElementById("pushLaneOffsetStatus");
            const maxInfoEl = document.getElementById("pushLaneOffsetMaxInfo");
            
            // Validate input range
            if (isNaN(val) || val < MIN_PUSH_LANE_OFFSET || val > MAX_PUSH_LANE_OFFSET) {
                if (statusEl) {
                    statusEl.textContent = `Invalid range. Must be between ${MIN_PUSH_LANE_OFFSET}mm and ${MAX_PUSH_LANE_OFFSET}mm.`;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.style.display = "none";
                }
                return;
            }
            
            // CRITICAL: Only calculate dynamic coordinates for P1/X1 (A1 doesn't use push lane offset)
            // Ensure currentPrinterModel is set correctly
            const modelSelect = document.getElementById("printerModel");
            if (modelSelect && modelSelect.value) {
                currentPrinterModel = modelSelect.value;
            }
            
            let dynamicCoords = null;
            if (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') {
                // Calculate dynamic coordinates to check for warnings (P1/X1 only)
                try {
                    dynamicCoords = calculateDynamicPushCoordinates(val);
                } catch (e) {
                    if (DEBUG_MODE) console.warn("Error calculating dynamic coordinates:", e);
                    dynamicCoords = null;
                }
            } else if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                // A1/A1Mini don't use push lane offset - just show a message
                const modelName = (currentPrinterModel === 'A1Mini') ? 'A1 Mini' : 'A1';
                if (statusEl) {
                    statusEl.textContent = `${modelName} uses automatic Y-axis push-off. Push lane offset is not applicable.`;
                    statusEl.style.color = "var(--muted)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.style.display = "none";
                }
            }
            
            if (dynamicCoords) {
                // Show maximum possible offset info
                if (maxInfoEl) {
                    maxInfoEl.textContent = `Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm`;
                    maxInfoEl.style.display = "block";
                }
                
                // Show warning if offset was auto-adjusted
                if (statusEl) {
                    if (dynamicCoords.warning) {
                        statusEl.textContent = dynamicCoords.warning;
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                    } else {
                        statusEl.textContent = `Offset set to ${val}mm. Left lane: X${dynamicCoords.leftX}, Right lane: X${dynamicCoords.rightX}`;
                        statusEl.style.color = "var(--accent)";
                        statusEl.style.display = "block";
                    }
                }
            } else {
                // No model data available yet
                if (statusEl) {
                    statusEl.textContent = `Offset set to ${val}mm. Will be validated when file is uploaded.`;
                    statusEl.style.color = "var(--accent)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.style.display = "none";
                }
            }
            
            // Update end code textareas
            updateEndCodeTextareas();
            saveSettings();
            
            // Clear status after 5 seconds
            setTimeout(() => {
                if (statusEl && !dynamicCoords?.warning) {
                    statusEl.style.display = "none";
                }
            }, 5000);
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in updatePushLaneOffset:", error);
            const statusEl = document.getElementById("pushLaneOffsetStatus");
            if (statusEl) {
                statusEl.textContent = "Error updating offset. Please try again.";
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
            }
        }
    }
    
    function applyOffset() {
        const val = parseFloat(document.getElementById("zOffsetInput").value);
        const statusEl = document.getElementById("zOffsetStatus"); 
        const dict = LANG.en;

        if (isNaN(val) || val < MIN_OFFSET || val > MAX_OFFSET) {
            statusEl.textContent = dict.zOffsetErrorRange;
            statusEl.style.color = "var(--danger)";
            statusEl.style.display = "block";
            return;
        }

        currentOffset = val;
        document.getElementById("bedOffsetDisplay").textContent = val;
        updateEndCodeTextareas();
        saveSettings();
        
        statusEl.textContent = dict.zOffsetApplied;
        statusEl.style.color = "var(--accent)";
        statusEl.style.display = "block";
        setTimeout(() => { 
            if (statusEl.textContent === dict.zOffsetApplied) statusEl.style.display = 'none'; 
        }, 3000);
    }

    /**
     * Gets cooldown temperature from input, with validation
     * @returns {number} Validated temperature value
     */
    function getCooldownTemp() {
        let val = parseInt(document.getElementById("cooldownTempInput").value, 10);
        return (isNaN(val) || val < MIN_TEMP) ? DEFAULT_TEMP : val;
    }

    /**
     * Checks and displays warning if cooldown temperature is too high
     */
    function checkCooldownWarning() {
        const val = parseInt(document.getElementById("cooldownTempInput").value, 10);
        const el = document.getElementById("cooldownWarningMessage");
        const dict = LANG.en;
        
        if (!isNaN(val) && val >= COOLDOWN_WARNING_THRESHOLD) {
            el.textContent = dict.cooldownRiskWarning;
            el.style.display = "block";
        } else {
            el.style.display = "none";
        }
    }
    
    /**
     * Shows status message to user
     * @param {string} key - Language key for message
     * @param {string} type - Message type: 'error' or 'success'
     * @param {string} directMsg - Optional direct message (overrides key)
     */
    function showStatus(key, type = "error", directMsg = null) {
        const el = document.getElementById("statusMessage");
        const dict = LANG.en;
        const msg = directMsg || dict[key] || key;
        
        el.style.display = "block";
        el.textContent = msg;
        el.style.color = (type === "error") ? "var(--danger)" : "var(--accent)";
    }

    function clearStatus() {
        document.getElementById("statusMessage").style.display = "none";
    }
    
    /**
     * Sets loading state for file processing
     * @param {boolean} isLoading - Whether loading is active
     * @param {string} message - Optional loading message
     */
    function setLoadingState(isLoading, message = "Processing file, please wait...") {
        const generateBtn = DOM.generateBtn || document.getElementById("generateBtn");
        const statusEl = document.getElementById("statusMessage");
        const loadingContainer = document.getElementById("loadingContainer");
        const progressText = document.getElementById("progressText");
        
        if (isLoading) {
            generateBtn.disabled = true;
            const originalText = generateBtn.textContent;
            generateBtn.setAttribute('data-original-text', originalText);
            generateBtn.textContent = "Generating...";
            statusEl.textContent = message;
            statusEl.style.display = "block";
            statusEl.style.color = "var(--accent)";
            loadingContainer.classList.add('active');
            progressText.textContent = message;
        } else {
            generateBtn.disabled = false;
            const originalText = generateBtn.getAttribute('data-original-text') || LANG.en.generateBtn;
            generateBtn.textContent = originalText;
            loadingContainer.classList.remove('active');
            document.getElementById("progressBar").style.width = "0%";
        }
    }
    
    /**
     * Updates progress bar during file processing
     * @param {number} percent - Progress percentage (0-100)
     * @param {string} message - Optional progress message
     */
    function updateProgress(percent, message = null) {
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + "%";
        if (message) {
            progressText.textContent = message;
        }
    }

    const RAW_P1_END_CODE_TEMPLATE = `;===== date: 20230428 ===================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
M400 ; wait for buffer to clear
G92 E0 ; zero the extruder
G1 E-0.8 F1800 ; retract
G1 Z{max_layer_z + 0.5} F900 ; lower z a little
G1 X65 Y245 F12000 ; move to safe pos
G1 Y265 F3000

G1 X65 Y245 F12000
G1 Y265 F3000
M140 S0 ; turn off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan

G1 X100 F12000 ; wipe
; pull back filament to AMS
M620 S255
G1 X20 Y50 F12000
G1 Y-3
T255
G1 X65 F12000
G1 Y265
G1 X100 F12000 ; wipe
M621 S255
M104 S0 ; turn off hotend

M622.1 S1 ; for prev firware, default turned on
M1002 judge_flag timelapse_record_flag
M622 J1
    M400 ; wait all motion done
    M991 S0 P-1 ;end smooth timelapse at safe pos
    M400 S3 ;wait for last picture to be taken
M623; end of "timelapse_record_flag"

M400 ; wait all motion done
M17 S
;M17 Z0.4 ; lower z motor current to reduce impact if there is something in the bottom
;{if (max_layer_z + 100.0) < 250}
;    G1 Z{max_layer_z + 100.0} F600
;    G1 Z{max_layer_z +98.0}
;{else}
;    G1 Z250 F600
;    G1 Z248
;{endif}
;M400 P100
;M17 R ; restore z current
                                
; ====== Cool Down =====
M400 				;wait for all print moves to be done											 
M17 Z0.4 			;lower z motor current to reduce impact if there is something in the top																					
G1 Z1 F600 			;move nozzle up, BE VERY CAREFUL this can hit the top of your print, extruder or AMS
M400				;wait all motion done
M106 P2 S255 		;turn Aux fan on
M106 P3 S200 		;turn on chamber cooling fan

M190 S18 ; wait for bed temp, Enter your own target cooldown temperatur here (-3 ¬∞C because printer stops cooling down earlier at low temps, here the target temp is 23 ¬∞C)
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp, total max wait time of all lines = 60 min 
                            
M106 P2 S0 					;turn off Aux fan 
M106 P3 S0					;turn off chamber cooling fan 
                            
;=== Cool Down Done, Start Push Off ===  !!! CAREFUL !!! You have to enter your own print specific coordinates here, or this will damage your printer !!!  
;!!! CAREFUL !!! You have to enter your own print specific coordinates below, or this will damage your printer !!!
; if you push off multiple objects then always start from right to left so you don't hit your LIDAR, this only works with small objects 
; The following lines lower the bed to initiate the push off
; Bed is lowered by 110mm from model height to ensure model top has adequate clearance from printer edge
; This ensures front shield can push model while preventing model top from hitting printer edge

M400
{if (max_layer_z ) > 31}
    G1 Z{max_layer_z - 30} F600
{else}
    G1 Z1 F600
{endif}
M400 P100

;G1 Z1 F600 			; Alternative to z moves lines above

G1 X170 Y254 F600		; move nozzle a little to the side for safety
M400				; Wait all motion done
G1 X120 Y230 F1200 		; take start middle push off position, -8mm in x from center of the print is the center of the toolhead  
G1 X120 Y25 F300		; Very slowly push off

;====Push off complete, start safety clear ==== You can enter your own specific coordinates here as well or erase this part if not wanted

;G1 z1 F600			;uncomment this if you want to do the safety clear at a different height
G1 X120 Y200 F2000 	;take start push off position at back
G1 X180 Y200 F2000 	;move to the right
G1 X180 Y25 F2000 	;push off at right position

G1 X180 Y200 F2000 	;take start push off position at back
G1 X60 Y200 F2000 	;move to the left
G1 X60 Y25 F2000 	;push off at left position

;==== safety clear complete ====
                    
M220 S100  ; Reset feedrate magnitude
M201.2 K1.0 ; Reset acc magnitude
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 0

M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power
`;

    // A1 End Code Template (from End_A1.txt) - will be added inline in getA1EndCode function
    // Template stored as string constant for reference, but actual generation happens in getA1EndCode()

    /**
     * Uses Factorian's original method for Z-offset calculation
     * Simple and proven method from Factorian Designs
     * 
     * Factorian's original method:
     * - If max_layer_z > 31mm: G1 Z{max_layer_z - 30}
     * - Else: G1 Z1
     * 
     * @returns {Object} { zOffset: number, threshold: number, method: string }
     */
    function calculateOptimalZOffset() {
        // Factorian's original method - simple and proven
        const FACTORIAN_THRESHOLD = 31; // mm - Factorian's threshold
        const FACTORIAN_OFFSET = 30; // mm - Factorian's offset for models > 31mm
        
        return {
            zOffset: FACTORIAN_OFFSET,
            threshold: FACTORIAN_THRESHOLD,
            method: "Factorian original"
        };
    }

    /**
     * Generates end G-code with push-off sequence
     * @param {number} offset - Z push offset in mm (legacy parameter, now calculated automatically)
     * @param {number} temp - Target bed temperature
     * @param {number} xStart - Starting X position
     * @param {number} xLane1 - First push lane X position
     * @param {number} xLane2 - Second push lane X position
     * @returns {string} Generated end G-code
     */
    /**
     * Generates end code with dynamic multi-lane push-off system
     * @param {number} offset - Z offset for bed lowering
     * @param {number} temp - Cooldown temperature
     * @param {number} xStart - Safe X position (to the side)
     * @param {number} xLeft - Left push lane X coordinate (center - 30mm)
     * @param {number} xCenter - Center push lane X coordinate (model center)
     * @param {number} xRight - Right push lane X coordinate (center + 30mm)
     * @returns {string} Generated end code
     */
    /**
     * Calculates model center Y coordinate from G-code (for A1/A1Mini push-off)
     * @returns {number} Model center Y coordinate
     */
    function calculateModelCenterY() {
        // LOGIC FIREWALL: This function is A1/A1Mini-only (Y-axis push, bed slinger)
        FIREWALL_A1_A1MINI_ONLY('calculateModelCenterY');
        
        try {
            if (!lastDebugData) {
                return 128; // Default to bed center
            }
            
            // Try to get Y coordinates from lastDebugData
            if (lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                const minY = parseFloat(lastDebugData.minY);
                const maxY = parseFloat(lastDebugData.maxY);
                if (!isNaN(minY) && !isNaN(maxY)) {
                    return (minY + maxY) / 2;
                }
            }
            
            return 128; // Default to bed center
        } catch (error) {
            if (DEBUG_MODE) console.error("Error calculating model center Y:", error);
            return 128; // Default to bed center
        }
    }

    /**
     * Generates A1-specific push-off G-code (Y-axis based, bed moves)
     * Matches End_A1.txt exactly: 41mm rule, F300 fixed speed
     * CRITICAL: Aligns nozzle X-position with model center before push
     * @param {number} modelCenterX - Model center X coordinate (default: 128 = bed center)
     * @returns {string} A1 push-off G-code
     */
    /**
     * Generates A1-specific push-off G-code (Y-axis based, bed moves)
     * 100% Factorian Compliance - Matches End_A1.txt exactly
     * Note: modelCenterX parameter is not used - template variable {first_layer_center_no_wipe_tower[0]} is used directly
     * @returns {string} A1 push-off G-code
     */
    function generateA1PushGcode() {
        // LOGIC FIREWALL: This function is A1/A1Mini-only (Y-axis push, bed moves)
        FIREWALL_A1_A1MINI_ONLY('generateA1PushGcode');
        
        // Factorian's exact logic from End_A1.txt (lines 175-182):
        // 1. Auto-Center X: Move nozzle to model center before push (CRITICAL: toolhead at X-48/X-13 after cooldown)
        //    Note: This alignment is not in End_A1.txt but is necessary to ensure push connects with model
        // 2. Z-Drop Logic (41mm Rule): IF (max_layer_z > 41) THEN Z = max_layer_z - 40 ELSE Z = 1.0
        // 3. M400 P100 wait
        // 4. Factorian Speed: F300 for push (very slow to prevent tipping on moving bed)
        // Note: Pre-Push Wipe happens earlier during filament retraction (End_A1.txt lines 90-94)
        //       and is already included in getA1EndCode() before cooldown sequence
        
        return `;===== CRITICAL: Align nozzle X-position with model center before push =====
; After cooldown sequence, toolhead is at X-48 (A1) or X-13 (A1 Mini). We must move it to model center
; before the bed moves forward (Y-0.5), otherwise the push will miss the model.
; (This alignment move is not in End_A1.txt but is critical for push accuracy)
G0 X{first_layer_center_no_wipe_tower[0]} F12000 ; Align nozzle with model center for push

;===== Z-Drop Logic (41mm Rule) =====
; Factorian's exact conditional from End_A1.txt lines 175-179: IF (max_layer_z ) > 41 THEN Z = max_layer_z - 40 ELSE Z = 1.0
; Note: Factorian uses {if (max_layer_z ) > 41} with space - our regex handles both formats
{if (max_layer_z ) > 41}
    G1 Z{max_layer_z - 40} F600
{else}
    G1 Z1 F600
{endif}

M400 P100											

;===== Main Push Movement (Y-axis, bed moves) =====
; Factorian Speed: F300 (very slow to prevent tipping on moving bed) - End_A1.txt line 182, End_A1_Mini.txt line 186
G1 Y-0.5 F300		; very slow push off using the x gantry
; Note: Factorian's End_A1.txt line 182 has no M400 after push, but we add it for safety
M400 ; Wait for push to complete before next move

;======== Push off complete, start safety clear / side push off ======
G1 Y${(currentPrinterModel === 'A1Mini') ? 180 : 262} F800	;move bed forward again (A1: Y262, A1 Mini: Y180)
G1 Z1 F600		;move nozzle closer to the bed when using tall parts`;
    }

    /**
     * Generates A1-specific wiggle sweep pattern
     * Matches End_A1.txt lines 189-213 exactly
     * Note: This happens AFTER push-off is complete
     * Note: Z height is set to Z1 in generateA1PushGcode() before this function is called (End_A1.txt line 187)
     * @param {number} zHeight - Z height for sweep (NOT USED - Z1 is hardcoded in generateA1PushGcode per End_A1.txt)
     * @param {number} speed - Speed of sweep motion (mm/min) - F2000 for X-48 movement per End_A1.txt line 191
     * @returns {string} Generated A1 wiggle sweep G-code
     */
    function generateA1WiggleSweep(zHeight = DEFAULT_SWEEP_Z, speed = DEFAULT_SWEEP_SPEED) {
        // LOGIC FIREWALL: This function is A1-only (wiggle sweep uses X-48 to X256)
        FIREWALL_A1_ONLY('generateA1WiggleSweep');
        
        // From End_A1.txt: Z1 is set before sweep (line 187) in generateA1PushGcode(), then sweep happens at different Y positions
        // Factorian uses Z1 F600 (hardcoded), then the sweep pattern
        // Note: zHeight parameter is kept for API compatibility but not used (Z1 is always used per End_A1.txt)
        const yPositions = [210, 165, 120, 75, 30, 0]; // From End_A1.txt lines 189-211
        
        let sweepCode = ``;

        for (let i = 0; i < yPositions.length; i++) {
            const yPos = yPositions[i];
            sweepCode += `G1 Y${yPos} F2000	;move bed back a little
G1 X256 F800	;move to the right
G1 X-48	F${speed}	;move back to the left
`;
        }
        
        sweepCode += `G1 Y262 F2000	;push bed forward one last time
`;

        return sweepCode;
    }

    /**
     * Generates A1 Mini-specific wiggle sweep pattern
     * Matches End_A1_Mini.txt lines 192-208 exactly
     * A1 Mini uses X-13 to X180 (not X-48 to X256 like A1)
     * @param {number} zHeight - Z height for sweep (NOT USED - Z1 is hardcoded per End_A1_Mini.txt)
     * @param {number} speed - Speed of sweep motion (mm/min) - F2000 for X-13 movement per End_A1_Mini.txt
     * @returns {string} Generated A1 Mini wiggle sweep G-code
     */
    function generateA1MiniWiggleSweep(zHeight = DEFAULT_SWEEP_Z, speed = DEFAULT_SWEEP_SPEED) {
        // LOGIC FIREWALL: This function is A1Mini-only (wiggle sweep uses X-13 to X180)
        FIREWALL_A1_A1MINI_ONLY('generateA1MiniWiggleSweep');
        
        // From End_A1_Mini.txt: Z1 is set before sweep (line 190) in generateA1PushGcode(), then sweep happens at different Y positions
        // Factorian uses Z1 F600 (hardcoded), then the sweep pattern
        // Note: zHeight parameter is kept for API compatibility but not used (Z1 is always used per End_A1_Mini.txt)
        const yPositions = [135, 90, 45, 0]; // From End_A1_Mini.txt lines 192-206 (4 positions, not 6 like A1)
        
        let sweepCode = ``;

        for (let i = 0; i < yPositions.length; i++) {
            const yPos = yPositions[i];
            sweepCode += `G1 Y${yPos} F2000	;move bed back a little
G1 X180 F800	;move to the right
G1 X-13	F${speed}	;move back to the left
`;
        }
        
        sweepCode += `G1 Y185 F2000 ;move bed forward one last time
`;

        return sweepCode;
    }

    /**
     * Generates A1 negative Z push-off sequence (advanced feature)
     * Based on Factorian Designs custom end code from FrilledLizard_single.3mf
     * Only works when nozzle head is at X-48 (far left)
     * WARNING: Only for A1 without Z-axis stiffener mod
     * @returns {string} Negative Z push-off G-code sequence
     */
    function generateA1NegativeZSequence() {
        // LOGIC FIREWALL: This function is A1-only (NOT A1 Mini)
        FIREWALL_A1_ONLY('generateA1NegativeZSequence');
        
        // Factorian's exact sequence from FrilledLizard_single.3mf (lines 208-216):
        // G1 Z1 F600 ;travel to safe z
        // G4 S1 ;wait 1 second
        // G1 Z-17 F600 ;go into negative z be very careful here
        // M400 P100
        // G1 Y200 F100 ; part release using the x gantry
        // G1 Y262 F2000 ; reset position
        // G1 Z{max_layer_z +5} ; lift Z into positive again
        return `;===== Negative Z Push-Off Sequence (Advanced - A1 Only) =====
; WARNING: This uses negative Z values. Only use if you do NOT have Z-axis stiffener mod installed.
; Nozzle head must be at X-48 (far left) for this to work safely.
G1 Z1 F600 ;travel to safe z
G4 S1		;wait 1 second
G1 Z-17 F600 ;go into negative z be very careful here
M400 P100											
G1 Y200 F100			; part release using the x gantry
G1 Y262 F2000			; reset position
G1 Z{max_layer_z +5}	; lift Z into positive again dont erase`;
    }
    
    /**
     * Generates A1-specific end code with Y-axis push-off
     */
    function getA1EndCode(temp, offset, modelCenterY) {
        // LOGIC FIREWALL: This function is A1-only (Y-axis push, bed slinger)
        FIREWALL_A1_ONLY('getA1EndCode');
        
        const actualTemp = applyTempOffset(temp);
        const m190Loop = generateM190Command(temp);
        
        let code = `;===== date: 20231229 =====================
;Made by FactorianDesigns, please completely watch the related Youtube video before you try this out

G392 S0 ;turn off nozzle clog detect

M400 ; wait for buffer to clear
G92 E0 ; zero the extruder
G1 E-0.8 F1800 ; retract
G1 Z{max_layer_z + 0.5} F900 ; lower z a little
G1 X0 Y{first_layer_center_no_wipe_tower[1]} F18000 ; move to safe pos
G1 X-13.0 F3000 ; move to safe pos

M140 S0 ; turn off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan

; pull back filament to AMS
M620 S255
G1 X267 F15000
T255
G1 X-28.5 F18000
G1 X-48.2 F3000
G1 X-28.5 F18000
G1 X-48.2 F3000
M621 S255

M104 S0 ; turn off hotend

M400 ; wait all motion done
M17 S
M17 Z0.4 ; lower z motor current to reduce impact if there is something in the bottom (End_A1.txt line 100)

M400				;wait for all print moves to be done

;===== Cool Down =======
G90   
G1 X-48 Y262 F3600 ; move to safe limit position on the left
			  
${m190Loop}

M140 S0 ; turn off bed

				
;======= Cool Down Done, Start Push Off =============
; calculate a good z-pushoff height, BE CAREFUL this could be a little different for parts
; that are fragile in the top, parts below 32 mm heigth can't be pushed off using the gantry
; if your part is too small then use the extruder head for push off and comment out the line "G1 Y1 F300"
; Use the safety clear part as pushoff template and adjust the coordinates as you see fit for you part 

; Enable travel moves and look at the last layer to see what your printer is doing using this code
; YOU NEVER want any -Z values in this or the resulting sliced g-code
${generateA1PushGcode()}`;

        // Wiggle sweep happens AFTER push-off is complete (End_A1.txt lines 185-213)
        // A1 wiggle sweep is ALWAYS active (not optional like P1's Full Bed Sweep)
        // Use Factorian's exact values: Z1 (set before sweep), speed F2000 for X-48 movement (End_A1.txt line 191)
        const sweepZInput = document.getElementById("sweepZInput");
        const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
        // A1 wiggle sweep uses fixed speed F2000 for X-48 movement (not configurable, per End_A1.txt)
        code += '\n' + generateA1WiggleSweep(zHeight, 2000);
        
        // Negative Z sequence (advanced feature - optional)
        // Based on Factorian Designs custom end code from FrilledLizard_single.3mf
        // Only add if enabled by user (checkbox)
        const enableNegativeZCheckbox = document.getElementById('enableA1NegativeZ');
        if (enableNegativeZCheckbox && enableNegativeZCheckbox.checked) {
            code += '\n\n' + generateA1NegativeZSequence();
        }
        
        code += `;====== Safety clear complete =======
M17 R ; restore z current
M220 S100  ; Reset feedrate magnitude
M201.2 K1.0 ; Reset acc magnitude
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 0

;=====printer finish  sound=========
M17
M400 S1
M1006 S1
M1006 A0 B20 L100 C37 D20 M40 E42 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C46 D10 M80 E46 F10 N80
M1006 A44 B20 L100 C39 D20 M60 E48 F20 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C44 D10 M60 E44 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C39 D10 M60 E39 F10 N60
M1006 A0 B10 L100 C0 D10 M60 E0 F10 N60
M1006 A0 B10 L100 C48 D10 M60 E44 F10 N80
M1006 A0 B10 L100 C0 D10 M60 E0 F10  N80
M1006 A44 B20 L100 C49 D20 M80 E41 F20 N80
M1006 A0 B20 L100 C0 D20 M60 E0 F20 N80
M1006 A0 B20 L100 C37 D20 M30 E37 F20 N60
M1006 W
;=====printer finish  sound=========

;M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power (End_A1.txt line 250 - commented out in Factorian's template)
M400
M18 X Y Z
`;

        return `;===== A1 PRESET (Temp: ${temp}¬∞C actual: ${actualTemp}¬∞C, Y-axis push-off) =====\n` + code;
    }

    /**
     * Generates A1 Mini end code with Y-axis push-off and wiggle sweep
     * A1 Mini uses same push logic as A1 but different bed bounds and wiggle sweep range
     */
    function getA1MiniEndCode(temp, offset, modelCenterY) {
        // LOGIC FIREWALL: This function is A1Mini-only (Y-axis push, bed slinger)
        FIREWALL_A1_A1MINI_ONLY('getA1MiniEndCode');
        
        const actualTemp = applyTempOffset(temp);
        const m190Loop = generateM190Command(temp);
        
        let code = `;===== date: 20231229 =====================
;Made by FactorianDesigns, please completely watch the related Youtube video before you try this out

;turn off nozzle clog detect
G392 S0

M400 ; wait for buffer to clear
G92 E0 ; zero the extruder
G1 E-0.8 F1800 ; retract
G1 Z{max_layer_z + 0.5} F900 ; lower z a little
G1 X0 Y{first_layer_center_no_wipe_tower[1]} F18000 ; move to safe pos
G1 X-13.0 F3000 ; move to safe pos

M140 S0 ; turn off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan

; pull back filament to AMS
M620 S255
G1 X181 F12000
T255
G1 X0 F18000
G1 X-13.0 F3000
G1 X0 F18000 ; wipe
M621 S255

M104 S0 ; turn off hotend

M400 ; wait all motion done
M17 S
M17 Z0.4 ; lower z motor current to reduce impact if there is something in the bottom

G90
G1 X-13 Y185 F3600 ; move to safe limit position on the left

;======= Start Cool Down =============

${m190Loop}

M140 S0 ; turn off bed
				
;======= Cool Down Done, Start Push Off =============
; calculate a good z-pushoff height, BE CAREFUL this could be a little different for parts
; that are fragile in the top, parts below 32 mm heigth can't be pushed off using the gantry
; if your part is too small then use the extruder head for push off and comment out the line "G1 Y1 F300"
; Use the safety clear part as pushoff template and adjust the coordinates as you see fit for you part 

; Enable travel moves and look at the last layer to see what your printer is doing using this code
; YOU NEVER want any -Z values in this or the resulting sliced g-code

${generateA1PushGcode()}`;

        // Wiggle sweep happens AFTER push-off is complete (End_A1_Mini.txt lines 188-208)
        // A1 Mini wiggle sweep is ALWAYS active (not optional like P1's Full Bed Sweep)
        // Use Factorian's exact values: Z1 (set before sweep), speed F2000 for X-13 movement (End_A1_Mini.txt line 194)
        const sweepZInput = document.getElementById("sweepZInput");
        const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
        // A1 Mini wiggle sweep uses fixed speed F2000 for X-13 movement (not configurable, per End_A1_Mini.txt)
        code += '\n' + generateA1MiniWiggleSweep(zHeight, 2000);
        
        code += `;====== Safety clear complete =======
M17 R ; restore z current
M220 S100  ; Reset feedrate magnitude
M201.2 K1.0 ; Reset acc magnitude
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 0

;=====printer finish  sound=========
M17
M400 S1
M1006 S1
M1006 A0 B20 L100 C37 D20 M100 E42 F20 N100
M1006 A0 B10 L100 C44 D10 M100 E44 F10 N100
M1006 A0 B10 L100 C46 D10 M100 E46 F10 N100
M1006 A44 B20 L100 C39 D20 M100 E48 F20 N100
M1006 A0 B10 L100 C44 D10 M100 E44 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B10 L100 C39 D10 M100 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B10 L100 C44 D10 M100 E44 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A0 B10 L100 C39 D10 M100 E39 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A44 B10 L100 C0 D10 M100 E48 F10 N100
M1006 A0 B10 L100 C0 D10 M100 E0 F10 N100
M1006 A44 B20 L100 C41 D20 M100 E49 F20 N100
M1006 A0 B20 L100 C0 D20 M100 E0 F20 N100
M1006 A0 B20 L100 C37 D20 M100 E37 F20 N100
M1006 W
;=====printer finish  sound=========
M400 S1
M18 X Y Z`;

        return `;===== A1 Mini PRESET (Temp: ${temp}¬∞C actual: ${actualTemp}¬∞C, Y-axis push-off) =====\n` + code;
    }

    /**
     * Generates reusable push G-code for P1/X1 (X-axis multi-lane push)
     * Three push lanes: Center (model center), Left (center - 30mm), Right (center + 30mm)
     */
    function generatePushGcode(xStart, xLeft, xCenter, xRight) {
        // LOGIC FIREWALL: This function is P1/X1-only (X-axis multi-lane push, not Y-axis bed slinger)
        FIREWALL_P1_X1_ONLY('generatePushGcode');
        
        const pushSpeedInput = document.getElementById("pushSpeedInput");
        const pushSpeed = pushSpeedInput ? (parseFloat(pushSpeedInput.value) || DEFAULT_PUSH_SPEED) : DEFAULT_PUSH_SPEED;
        const validatedPushSpeed = Math.max(MIN_PUSH_SPEED, Math.min(MAX_PUSH_SPEED, pushSpeed));

        return `G1 X${xStart} Y254 F600		; move nozzle a little to the side for safety
M400				; Wait all motion done
; --- DYNAMIC MULTI-LANE PUSH SYSTEM (Looprint) ---
; Model center calculated from G-code: X${xCenter}
; Left lane: X${xLeft} (center - 30mm), Right lane: X${xRight} (center + 30mm)
; Push-off speed: ${validatedPushSpeed}mm/min

; --- PUSH LANE 1: CENTER (Primary push force at model center) ---
G1 X${xCenter} Y230 F1200 	; take start position at model center
G1 X${xCenter} Y5 F${validatedPushSpeed}		; Push center lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety

; --- PUSH LANE 2: LEFT (30mm left of center for stability) ---
G1 X${xLeft} Y230 F1200 	; take start position at left lane
G1 X${xLeft} Y5 F${validatedPushSpeed}		; Push left lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety

; --- PUSH LANE 3: RIGHT (30mm right of center for stability) ---
G1 X${xRight} Y230 F1200 	; take start position at right lane
G1 X${xRight} Y5 F${validatedPushSpeed}		; Push right lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety
`;
    }

    /**
     * Generates X1 end code with cutter sequence, dynamic push, and end sound
     * X1 uses same push logic as P1 (X-axis multi-lane push) but different end code structure
     */
    function getX1EndCode(offset, temp, xStart, xLeft, xCenter, xRight) {
        // LOGIC FIREWALL: This function is X1-only
        FIREWALL_X1_ONLY('getX1EndCode');
        
        const actualTemp = applyTempOffset(temp);
        
        // Follow Factorian's exact sequence for X1 end code:
        // 1. Retract & move to safe position + Filament retraction & cutter sequence (F√òR cooldown)
        // 2. Timelapse end (if active)
        // 3. Motor setup
        // 4. Cool Down (M190 S18 x30)
        // 5. Z-offset calculation
        // 6. Push-off
        // 7. End sound
        // 8. Motor disable
        
        let code = '';
        
        // Step 1: Retract, move to safe position, and cutter sequence (F√òR cooldown)
        code += X1_END_CUTTER_SEQUENCE;
        
        // Step 2: Timelapse end (if active) - from Factorian's template
        code += `\nM622.1 S1 ; for prev firware, default turned on
M1002 judge_flag timelapse_record_flag
M622 J1
    M400 ; wait all motion done
    M991 S0 P-1 ;end smooth timelapse at safe pos
    M400 S3 ;wait for last picture to be taken
M623; end of "timelapse_record_flag"
`;
        
        // Step 3: Motor setup
        code += `\nM400 ; wait all motion done
M17 S
`;
        
        // Step 4: Cool Down (following Factorian's exact structure)
        code += `\n; ====== Cool Down =====
M400 				;wait for all print moves to be done											 
M17 Z0.4 			;lower z motor current to reduce impact if there is something in the top																					
G1 Z1 F600 			;move nozzle up, BE VERY CAREFUL this can hit the top of your print, extruder or AMS
M400				;wait all motion done
M106 P2 S255 		;turn Aux fan on
M106 P3 S200 		;turn on chamber cooling fan
`;
        
        // Add M190 cooldown loop (30 commands as per Factorian's template)
        const m190Loop = generateM190Command(temp);
        code += m190Loop + '\n';
        
        code += `\nM106 P2 S0 					;turn off Aux fan 
M106 P3 S0					;turn off chamber cooling fan 
M400
`;
        
        // Step 5: Z-offset calculation before push-off
        code += `\n;=== Cool Down Done, Start Push Off ===  
;!!! CAREFUl !!! You have to enter your own print specific coordinates below, or this will damage your printer !!!
; if you push of multiple objects then always start from right to left so you don't hit your LIDAR, this only works with small objects 
; The following lines raise the bed to initiate the push off, your model height -30 mm is often a good pushoff point for you extruder head not to hit any fans or the nozzle
; I have updated the automatic z calculation so if your print is over 31 mm tall the nozzle doesn't hit your bed but feel free to enter your own z height if necessary

; Auto calculation to raise bed

M400
{if (max_layer_z ) > 31}
    G1 Z{max_layer_z - 30} F600
{else}
    G1 Z1 F600
{endif}
M400 P100
`;
        
        // Step 6: Dynamic multi-lane push (same as P1)
        code += generatePushGcode(xStart, xLeft, xCenter, xRight);
        
        // Add full bed sweep if enabled (same as P1)
        const enableSweep = document.getElementById("enableSweep");
        if (enableSweep && enableSweep.checked) {
            const sweepSpeedInput = document.getElementById("sweepSpeedInput");
            const sweepZInput = document.getElementById("sweepZInput");
            const speed = sweepSpeedInput ? (parseFloat(sweepSpeedInput.value) || DEFAULT_SWEEP_SPEED) : DEFAULT_SWEEP_SPEED;
            const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
            code += '\n' + generateSweepGcode(zHeight, speed);
        }
        
        // Step 7: End sound (already includes M17 X0.8 Y0.8 Z0.5 and M960 S5 P0)
        code += '\n' + X1_END_SOUND;
        
        // Step 8: Motor disable (M18 X Y Z) - M17 X0.8 Y0.8 Z0.5 is already in X1_END_SOUND
        code += `\nM400\nM18 X Y Z ; Disable all motors`;
        
        return `;===== X1 PRESET (Offset: ${offset}mm, Temp: ${temp}¬∞C actual: ${actualTemp}¬∞C, DYNAMIC MULTI-LANE PUSH: Center=${xCenter}, Left=${xLeft}, Right=${xRight}) =====\n` + code;
    }

    function getEndCode(offset, temp, xStart, xLeft, xCenter, xRight) {
        try {
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: Called for printer model:", currentPrinterModel);
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: Input parameters:", { offset, temp, xStart, xLeft, xCenter, xRight });
            
            // LOGIC FIREWALL: Strict routing - A1/A1Mini must use getA1EndCode/getA1MiniEndCode, never fall through to P1 logic
            if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                if (DEBUG_MODE) console.log(`[DIAG] getEndCode: ${currentPrinterModel} detected, delegating to getA1EndCode() or getA1MiniEndCode()`);
                const modelCenterY = calculateModelCenterY();
                if (DEBUG_MODE) console.log(`[DIAG] getEndCode: ${currentPrinterModel} modelCenterY:`, modelCenterY);
                if (currentPrinterModel === 'A1Mini') {
                    return getA1MiniEndCode(temp, offset, modelCenterY);
                } else {
                    return getA1EndCode(temp, offset, modelCenterY);
                }
            }
            
            // X1 uses same push logic as P1 but different end code structure
            if (currentPrinterModel === 'x1') {
                if (DEBUG_MODE) console.log("[DIAG] getEndCode: X1 detected, delegating to getX1EndCode()");
                return getX1EndCode(offset, temp, xStart, xLeft, xCenter, xRight);
            }
            
            // LOGIC FIREWALL: P1-only path - validate we're actually P1
            FIREWALL_P1_ONLY('getEndCode');
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: P1 path - processing P1 end code");
            
            // Validate inputs
            offset = parseFloat(offset) || DEFAULT_OFFSET;
            temp = parseFloat(temp) || DEFAULT_TEMP;
            xStart = parseFloat(xStart);
            xLeft = parseFloat(xLeft);
            xCenter = parseFloat(xCenter);
            xRight = parseFloat(xRight);
            
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: Parsed parameters:", { offset, temp, xStart, xLeft, xCenter, xRight });
            
            if (isNaN(offset) || isNaN(temp) || isNaN(xStart) || isNaN(xLeft) || isNaN(xCenter) || isNaN(xRight)) {
                if (DEBUG_MODE) console.error("[DIAG] getEndCode: Invalid parameters detected, using safe defaults");
                // Use safe defaults
                offset = DEFAULT_OFFSET;
                temp = DEFAULT_TEMP;
                xStart = 128;
                xLeft = 98;
                xCenter = 128;
                xRight = 158;
                if (DEBUG_MODE) console.log("[DIAG] getEndCode: Using safe defaults:", { offset, temp, xStart, xLeft, xCenter, xRight });
            }
            
            // Use Factorian's original method - template already has correct logic
            // No need to call calculateOptimalZOffset() as template is unchanged
            let code = RAW_P1_END_CODE_TEMPLATE;

            const targetActualTemp = temp + 5;
            code = code.replace(/M190 S18/g, `M190 S${temp}`);
            
            // Replace temperature placeholder in end code template
            code = code.replace(
                /(here the target temp is )[^)]*( ¬∞C)/, 
                `here the target temp is ${targetActualTemp} ¬∞C`
            );

            // Use Factorian's original method - no changes needed
            // Template already has: {if (max_layer_z ) > 31}
            //                    G1 Z{max_layer_z - 30} F600
            //                    {else}
            //                    G1 Z1 F600
            //                    {endif}
            // We keep this exactly as Factorian designed it
            
            const PUSH_BLOCK_START = "G1 X170 Y254 F600		; move nozzle a little to the side for safety";
            const SAFETY_CLEAR_START = ";====Push off complete, start safety clear ====";
            const SAFETY_CLEAR_END = ";==== safety clear complete ====";
            
            const startIdx = code.indexOf(PUSH_BLOCK_START);
            const safetyClearStartIdx = code.indexOf(SAFETY_CLEAR_START);
            const safetyClearEndIdx = code.indexOf(SAFETY_CLEAR_END);
            
            // Replace original Push/Clear block with Dynamic Multi-Lane Push system
            // Three push lanes: Center (model center), Left (center - 30mm), Right (center + 30mm)
            // Push order: Center first (main force), then Left, then Right (for stability)
            
            // Get push-off speed from input
            const pushSpeedInput = document.getElementById("pushSpeedInput");
            const pushSpeed = pushSpeedInput ? (parseFloat(pushSpeedInput.value) || DEFAULT_PUSH_SPEED) : DEFAULT_PUSH_SPEED;
            const validatedPushSpeed = Math.max(MIN_PUSH_SPEED, Math.min(MAX_PUSH_SPEED, pushSpeed));
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: Push speed - input:", pushSpeed, "validated:", validatedPushSpeed);
            
            // Use generatePushGcode for consistency (reusable push logic)
            const MULTI_LANE_PUSH_REPLACEMENT = generatePushGcode(xStart, xLeft, xCenter, xRight); 

            if (startIdx !== -1 && safetyClearStartIdx !== -1) {
                 const prePush = code.substring(0, startIdx);
                 // Skip safety clear sequence - start after it ends (removes extra push to right and left)
                 const postSafetyClear = safetyClearEndIdx !== -1 
                     ? code.substring(safetyClearEndIdx + SAFETY_CLEAR_END.length)
                     : code.substring(safetyClearStartIdx + SAFETY_CLEAR_START.length); 
                 
                 code = prePush + MULTI_LANE_PUSH_REPLACEMENT + postSafetyClear;
            }

            // Add full bed sweep if enabled
            const enableSweep = document.getElementById("enableSweep");
            if (enableSweep && enableSweep.checked) {
                if (DEBUG_MODE) console.log("[DIAG] getEndCode: Full bed sweep is enabled");
                const sweepSpeedInput = document.getElementById("sweepSpeedInput");
                const sweepZInput = document.getElementById("sweepZInput");
                const speed = sweepSpeedInput ? (parseFloat(sweepSpeedInput.value) || DEFAULT_SWEEP_SPEED) : DEFAULT_SWEEP_SPEED;
                const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
                if (DEBUG_MODE) console.log("[DIAG] getEndCode: Sweep parameters - zHeight:", zHeight, "speed:", speed);
                
                // Insert sweep after push-off, before final reset parameters
                // Find the position after the multi-lane push (after "Retract back for safety" from right lane)
                const sweepGcode = generateSweepGcode(zHeight, speed);
                if (DEBUG_MODE) console.log("[DIAG] getEndCode: Generated sweep G-code length:", sweepGcode.length);
                
                // Insert sweep after the push system
                // Look for the end of the right lane push (last "Retract back for safety")
                const rightLaneEnd = code.indexOf("; Retract back for safety", code.indexOf("; --- PUSH LANE 3: RIGHT"));
                if (rightLaneEnd !== -1) {
                    // Find the end of that line
                    const lineEnd = code.indexOf('\n', rightLaneEnd);
                    if (lineEnd !== -1) {
                        // Insert sweep after the push system
                        code = code.substring(0, lineEnd + 1) + '\n' + sweepGcode + code.substring(lineEnd + 1);
                    } else {
                        // Fallback: append at end before final reset
                        code = code + '\n' + sweepGcode;
                    }
                } else {
                    // Fallback: append at end before final reset
                    code = code + '\n' + sweepGcode;
                }
            }

            // Add end sound before final motor disable (P1 supports M1006 since it shares firmware with X1)
            // Replace M17 X0.8 Y0.8 Z0.5 with end sound + motor disable
            const motorDisableMarker = "M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power";
            const motorDisableIndex = code.lastIndexOf(motorDisableMarker);
            if (motorDisableIndex !== -1) {
                // Insert end sound before motor disable
                const beforeMotorDisable = code.substring(0, motorDisableIndex);
                const afterMotorDisable = code.substring(motorDisableIndex + motorDisableMarker.length);
                code = beforeMotorDisable + P1_END_SOUND + afterMotorDisable;
            } else {
                // Fallback: append end sound at the end
                code = code + '\n' + P1_END_SOUND;
            }

            code = `;===== ${currentDirection.toUpperCase()} PRESET (Offset: ${offset}mm, Temp: ${temp}C, DYNAMIC MULTI-LANE PUSH: Center=${xCenter}, Left=${xLeft}, Right=${xRight}) =====\n` + code;
            
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: P1 end code generated successfully, length:", code.length);
            if (DEBUG_MODE) console.log("[DIAG] getEndCode: Final parameters:", { direction: currentDirection, offset, temp, xStart, xLeft, xCenter, xRight });
            
            return code;
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in getEndCode:", error);
            // Return a safe fallback end code
            return RAW_P1_END_CODE_TEMPLATE;
        }
    }

    /**
     * Calculates dynamic push-off coordinates based on model placement
     * @param {number} [offset] - Offset from model center for left/right lanes (default: from input)
     * @returns {Object|null} { centerX, leftX, rightX, safeX, adjustedOffset, maxPossibleOffset, warning } or null if no model data
     */
    function calculateDynamicPushCoordinates(offset = null) {
        try {
            // LOGIC FIREWALL: This function is P1/X1-only (A1 uses Y-axis push, not multi-lane X-axis push)
            FIREWALL_P1_X1_ONLY('calculateDynamicPushCoordinates');
            
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Called with offset:", offset);
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: lastDebugData available:", !!lastDebugData);
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: lastDebugData content:", lastDebugData);
            
            // Check if we have model placement data
            if (!lastDebugData || !lastDebugData.minX || !lastDebugData.maxX) {
                if (DEBUG_MODE) console.warn("[DIAG] calculateDynamicPushCoordinates: No model placement data available, returning null");
                return null;
            }
            
            // Validate model data
            const minX = parseFloat(lastDebugData.minX);
            const maxX = parseFloat(lastDebugData.maxX);
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Parsed model bounds - minX:", minX, "maxX:", maxX);
            
            if (isNaN(minX) || isNaN(maxX) || minX < 0 || maxX < 0 || minX >= maxX) {
                if (DEBUG_MODE) console.warn("[DIAG] calculateDynamicPushCoordinates: Invalid model placement data:", { minX, maxX });
                return null;
            }
            
            // Get offset from input if not provided
            if (offset === null) {
                const offsetInput = document.getElementById("pushLaneOffsetInput");
                if (offsetInput) {
                    offset = parseFloat(offsetInput.value);
                    if (isNaN(offset) || offset < MIN_PUSH_LANE_OFFSET || offset > MAX_PUSH_LANE_OFFSET) {
                        offset = DEFAULT_PUSH_LANE_OFFSET;
                    }
                } else {
                    offset = DEFAULT_PUSH_LANE_OFFSET;
                }
            }
            
            // Validate provided offset
            if (isNaN(offset) || offset < MIN_PUSH_LANE_OFFSET || offset > MAX_PUSH_LANE_OFFSET) {
                offset = DEFAULT_PUSH_LANE_OFFSET;
            }
            
            // Calculate model center
            const centerX = (minX + maxX) / 2;
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Calculated centerX:", centerX);
            
            // Validate and clamp offset to safe range
            let safeOffset = Math.max(MIN_PUSH_LANE_OFFSET, Math.min(MAX_PUSH_LANE_OFFSET, offset));
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Input offset:", offset, "safeOffset:", safeOffset);
            
            // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
            const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
            const bedMinX = bedBounds.minX || 10;
            const bedMaxX = bedBounds.maxX || 246;
            const bedCenterX = (bedMinX + bedMaxX) / 2;
            
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Using bed bounds for", currentPrinterModel, "- minX:", bedMinX, "maxX:", bedMaxX, "centerX:", bedCenterX);
            
            // Calculate maximum possible offset based on model placement
            const maxOffsetLeft = centerX - bedMinX;   // How far left we can go from center
            const maxOffsetRight = bedMaxX - centerX; // How far right we can go from center
            const maxPossibleOffset = Math.min(maxOffsetLeft, maxOffsetRight);
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Offset limits - maxOffsetLeft:", maxOffsetLeft, "maxOffsetRight:", maxOffsetRight, "maxPossibleOffset:", maxPossibleOffset);
            
            // Auto-adjust if offset is too large for this model placement
            let adjustedOffset = safeOffset;
            let warning = null;
            if (safeOffset > maxPossibleOffset) {
                adjustedOffset = maxPossibleOffset;
                warning = `Offset auto-adjusted from ${safeOffset.toFixed(1)}mm to ${adjustedOffset.toFixed(1)}mm to prevent collision. Maximum safe offset for this model: ${maxPossibleOffset.toFixed(1)}mm.`;
                if (DEBUG_MODE) console.warn("[DIAG] calculateDynamicPushCoordinates: Offset auto-adjusted:", warning);
            }
            
            // Calculate three push lanes: center, left (center - offset), right (center + offset)
            const leftX = Math.max(bedMinX, centerX - adjustedOffset);  // Ensure minimum from left edge
            const rightX = Math.min(bedMaxX, centerX + adjustedOffset); // Ensure maximum from left edge
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Calculated push lanes - leftX:", leftX, "centerX:", centerX, "rightX:", rightX);
            
            // Calculate safe position based on model placement (most reliable approach)
            // Safety position should always be AWAY from the model to prevent collisions
            
            let safeX;
            if (centerX < bedCenterX) {
                // Model is on left side of bed - place safety position to the LEFT of model
                safeX = Math.max(bedMinX, minX - 20);
                if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Model on left side, safeX:", safeX);
            } else {
                // Model is on right side or center of bed - place safety position to the RIGHT of model
                safeX = Math.min(bedMaxX, maxX + 20);
                if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Model on right/center, safeX:", safeX);
            }
            
            // Additional safety check: Ensure safeX is not too close to any push lane
            // Minimum 10mm clearance from push lanes
            const minSafeDistance = 10;
            if (Math.abs(safeX - leftX) < minSafeDistance || 
                Math.abs(safeX - centerX) < minSafeDistance || 
                Math.abs(safeX - rightX) < minSafeDistance) {
                // If too close, move further away (use already-defined bedCenterX, bedMinX, bedMaxX)
                if (centerX < bedCenterX) {
                    safeX = Math.max(bedMinX, minX - 30);
                } else {
                    safeX = Math.min(bedMaxX, maxX + 30);
                }
            }
            
            const result = {
                centerX: centerX.toFixed(1),
                leftX: leftX.toFixed(1),
                rightX: rightX.toFixed(1),
                safeX: safeX.toFixed(1),
                adjustedOffset: adjustedOffset.toFixed(1),
                maxPossibleOffset: maxPossibleOffset.toFixed(1),
                warning: warning
            };
            
            if (DEBUG_MODE) console.log("[DIAG] calculateDynamicPushCoordinates: Final result:", result);
            
            return result;
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in calculateDynamicPushCoordinates:", error);
            return null;
        }
    }

    /**
     * Handles printer model change
     */
    function handlePrinterModelChange() {
        const modelSelect = document.getElementById("printerModel");
        if (modelSelect) {
            // Prevent change if model is auto-detected and locked
            if (autoDetectedPrinterModel && modelSelect.disabled) {
                // Revert to auto-detected value
                modelSelect.value = autoDetectedPrinterModel;
                return;
            }
            
            const previousModel = currentPrinterModel;
            currentPrinterModel = modelSelect.value || null; // Set to null if empty
            
            // If no printer model selected, hide all printer-specific UI elements
            if (!currentPrinterModel) {
                // Hide all printer-specific controls
                
                const purgeContainer = document.getElementById("purgeContainer");
                if (purgeContainer) purgeContainer.style.display = 'none';
                
                const pushDirectionContainer = document.getElementById("pushDirectionContainer");
                if (pushDirectionContainer) pushDirectionContainer.style.display = 'none';
                
                const pushLaneOffsetContainer = document.getElementById("pushLaneOffsetContainer");
                if (pushLaneOffsetContainer) pushLaneOffsetContainer.style.display = 'none';
                
                const pushSelectorLabel = document.querySelector('.push-selector-label');
                const pushSelector = document.querySelector('.push-selector');
                const blockLeft = document.getElementById('block-left');
                const blockCenter = document.getElementById('block-center');
                const blockRight = document.getElementById('block-right');
                const blockA1 = document.getElementById('block-a1');
                if (pushSelectorLabel) pushSelectorLabel.style.display = 'none';
                if (pushSelector) pushSelector.style.display = 'none';
                if (blockLeft) blockLeft.style.display = 'none';
                if (blockCenter) blockCenter.style.display = 'none';
                if (blockRight) blockRight.style.display = 'none';
                if (blockA1) blockA1.style.display = 'none';
                
                const bedPreviewP1 = document.getElementById('bedPreviewP1');
                const bedPreviewCanvas = document.getElementById('bedPreviewCanvas');
                if (bedPreviewP1) bedPreviewP1.style.display = 'none';
                if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'none';
                
                updatePreview();
                return; // Exit early if no printer model selected
            }
            
            // CRITICAL: Clear lastDebugData when switching printer models to prevent coordinate mixing
            // Different printer models have different bed bounds, so old coordinates are invalid
            if (previousModel && previousModel !== currentPrinterModel && lastDebugData) {
                if (DEBUG_MODE) console.log("[DIAG] handlePrinterModelChange: Printer model changed from", previousModel, "to", currentPrinterModel, "- clearing lastDebugData to prevent coordinate mixing");
                lastDebugData = null;
            }
            
            // X1-specific controls
            // Show purge checkbox for P1 and X1 (both support optional flush)
            const purgeContainer = document.getElementById("purgeContainer");
            if (purgeContainer) {
                purgeContainer.style.display = (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') ? 'block' : 'none';
            }
            
            // Show/hide push direction and lane offset for P1 and X1 (both use X-axis push)
            const pushDirectionContainer = document.getElementById("pushDirectionContainer");
            const pushLaneOffsetContainer = document.getElementById("pushLaneOffsetContainer");
            if (pushDirectionContainer) {
                pushDirectionContainer.style.display = (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') ? 'block' : 'none';
            }
            if (pushLaneOffsetContainer) {
                pushLaneOffsetContainer.style.display = (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') ? 'block' : 'none';
            }
            
            // Show/hide P1/X1-specific controls (A1 uses automatic Y-axis push only)
            const pushSelectorLabel = document.querySelector('.push-selector-label');
            const pushSelector = document.querySelector('.push-selector');
            const blockLeft = document.getElementById('block-left');
            const blockCenter = document.getElementById('block-center');
            const blockRight = document.getElementById('block-right');
            
            // Push Lane Offset (P1/X1 specific - not used in A1)
            // Find the column container that contains the Push Lane Offset input (not the entire row, as it also contains Push-off Speed)
            const pushLaneOffsetInput = document.getElementById('pushLaneOffsetInput');
            const pushLaneOffsetCol = pushLaneOffsetInput ? pushLaneOffsetInput.closest('.col') : null;
            const pushLaneOffsetStatus = document.getElementById('pushLaneOffsetStatus');
            const pushLaneOffsetMaxInfo = document.getElementById('pushLaneOffsetMaxInfo');
            
            // Push Speed (P1/X1 specific - A1/A1Mini uses hardcoded F300 per Factorian's template)
            const pushSpeedInput = document.getElementById('pushSpeedInput');
            const pushSpeedCol = pushSpeedInput ? pushSpeedInput.closest('.col') : null;
            
            // Z Push Offset (P1/X1 specific - A1/A1Mini uses 41mm rule with hardcoded 40mm offset)
            const zOffsetInput = document.getElementById('zOffsetInput');
            const zOffsetCol = zOffsetInput ? zOffsetInput.closest('.col') : null;
            
            // Enable Full Bed Sweep (P1/X1 specific - A1 uses Wiggle Sweep which is always active)
            const enableSweepCheckbox = document.getElementById('enableSweep');
            const enableSweepContainer = enableSweepCheckbox ? enableSweepCheckbox.closest('.setting-block') : null;
            const sweepSettings = document.getElementById('sweepSettings');
            
            // A1 Negative Z (A1 only - NOT A1 Mini)
            const a1NegativeZContainer = document.getElementById('a1NegativeZContainer');
            
            // Bed Preview P1/X1 Zones (P1/X1 specific - replaced by Canvas in A1 mode)
            const bedPreviewP1 = document.getElementById('bedPreviewP1');
            const bedPreviewCanvas = document.getElementById('bedPreviewCanvas');
            
            if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                // Hide P1/X1 push direction controls (A1/A1Mini uses automatic Y-axis push only)
                if (pushSelectorLabel) pushSelectorLabel.style.display = 'none';
                if (pushSelector) pushSelector.style.display = 'none';
                if (blockLeft) blockLeft.style.display = 'none';
                if (blockCenter) blockCenter.style.display = 'none';
                if (blockRight) blockRight.style.display = 'none';
                
                // Show A1 end G-code section
                const blockA1 = document.getElementById('block-a1');
                if (blockA1) blockA1.style.display = 'block';
                
                // Hide Push Lane Offset column (A1/A1Mini uses single centered Y-axis push, not multi-lane X-axis push)
                if (pushLaneOffsetCol) pushLaneOffsetCol.style.display = 'none';
                if (pushLaneOffsetStatus) pushLaneOffsetStatus.style.display = 'none';
                if (pushLaneOffsetMaxInfo) pushLaneOffsetMaxInfo.style.display = 'none';
                
                // Hide Push Speed column (A1/A1Mini uses hardcoded F300 per Factorian's template - End_A1.txt line 182, End_A1_Mini.txt line 186)
                if (pushSpeedCol) pushSpeedCol.style.display = 'none';
                
                // Hide Z Push Offset column (A1/A1Mini uses 41mm rule with hardcoded 40mm offset - End_A1.txt lines 175-179, End_A1_Mini.txt lines 179-183)
                if (zOffsetCol) zOffsetCol.style.display = 'none';
                
                // Hide Full Bed Sweep checkbox (A1/A1Mini uses Wiggle Sweep which is always active in end code)
                if (enableSweepContainer) enableSweepContainer.style.display = 'none';
                if (sweepSettings) sweepSettings.style.display = 'none';
                
                // Show/hide A1 Negative Z checkbox (A1 ONLY, not A1 Mini)
                if (a1NegativeZContainer) {
                    a1NegativeZContainer.style.display = (currentPrinterModel === 'A1') ? 'block' : 'none';
                }
                
                // Hide P1 bed preview zones, show Canvas (handled in updatePreview, but ensure here too)
                if (bedPreviewP1) bedPreviewP1.style.display = 'none';
                if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'block';
            } else {
                // Show P1/X1 push direction controls (both use same push system)
                if (pushSelectorLabel) pushSelectorLabel.style.display = '';
                if (pushSelector) pushSelector.style.display = '';
                if (blockLeft) blockLeft.style.display = '';
                if (blockCenter) blockCenter.style.display = '';
                if (blockRight) blockRight.style.display = '';
                
                // Hide A1 end G-code section
                const blockA1 = document.getElementById('block-a1');
                if (blockA1) blockA1.style.display = 'none';
                
                // Show Push Lane Offset column (P1 and X1 both use multi-lane X-axis push)
                if (pushLaneOffsetCol) pushLaneOffsetCol.style.display = '';
                
                // Show Push Speed column (P1 and X1 both use configurable push speed)
                if (pushSpeedCol) pushSpeedCol.style.display = '';
                
                // Show Z Push Offset column (P1 and X1 both use configurable Z offset - default 30mm)
                if (zOffsetCol) zOffsetCol.style.display = '';
                
                // Show Full Bed Sweep checkbox (P1 and X1 both support full bed sweep)
                if (enableSweepContainer) enableSweepContainer.style.display = '';
                // sweepSettings visibility is controlled by toggleSweepSettings()
                
                // Hide A1 Negative Z checkbox (P1/X1 don't support this)
                if (a1NegativeZContainer) a1NegativeZContainer.style.display = 'none';
                
                // Show P1/X1 bed preview zones, hide Canvas (handled in updatePreview, but ensure here too)
                if (bedPreviewP1) bedPreviewP1.style.display = '';
                if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'none';
            }
            
            // Update bed preview visualization
            updatePreview();
            
            // Update all code displays
            updateStartCodeTextarea();
            updateEndCodeTextareas();
            
            // Update endSectionHelp text based on printer model
            const endSectionHelp = document.querySelector('[data-lang="endSectionHelp"]');
            if (endSectionHelp) {
                if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                    const modelName = (currentPrinterModel === 'A1Mini') ? 'A1 Mini' : 'A1';
                    endSectionHelp.innerHTML = `${modelName} uses <strong>automatic Y-axis push-off</strong> (bed moves forward). Push direction is not configurable.<br><span style="font-size: 0.85em; color: var(--muted);">The sweep sequence is always active and runs automatically after each push-off.</span>`;
                } else {
                    endSectionHelp.innerHTML = 'Push direction is automatically detected from your file. <strong>You can click the zones in the bed preview above to change it manually.</strong><br><span style="font-size: 0.85em; color: var(--muted);">Note: In simple mode, push direction is locked to the auto-detected value. In advanced mode, you can change it but will see a warning if it differs from the auto-detected direction.</span>';
                }
            }
            
            // Update Factorian Designs links based on printer model
            updateFactorianLinks();
            
            // Save to localStorage
            try {
                localStorage.setItem('looprint_printerModel', currentPrinterModel);
            } catch (e) {
                if (DEBUG_MODE) console.warn("Could not save printer model:", e);
            }
        }
    }

    /**
     * Updates Factorian Designs links based on printer model
     * A1 uses different video link than P1/X1
     */
    function updateFactorianLinks() {
        // Note: All Factorian Designs links are now static (both A1 and P1/X1 links are shown)
        // No dynamic updates needed - links are hardcoded in HTML
        // This function is kept for potential future use but currently does nothing
    }

    /**
     * Updates bed preview visualization based on printer model
     */
    function updatePreview() {
        const bedPreviewP1 = document.getElementById("bedPreviewP1");
        const bedPreviewCanvas = document.getElementById("bedPreviewCanvas");
        const bedPreviewModeText = document.getElementById("bedPreviewModeText");
        const sweepModeText = document.getElementById("sweepModeText");
        
        if (DEBUG_MODE) console.log("updatePreview called, currentPrinterModel:", currentPrinterModel);
        
        // If no printer model selected, hide all previews
        if (!currentPrinterModel) {
            if (bedPreviewP1) bedPreviewP1.style.display = 'none';
            if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'none';
            if (bedPreviewModeText) {
                bedPreviewModeText.innerHTML = 'Select a printer model and upload a file to see bed preview.';
            }
            if (sweepModeText) {
                sweepModeText.textContent = '';
            }
            return;
        }
        
        if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
            // Show canvas, hide P1 zones
            if (bedPreviewP1) bedPreviewP1.style.display = 'none';
            if (bedPreviewCanvas) {
                bedPreviewCanvas.style.display = 'block';
                drawBedPreview();
            }
            // Update text
            if (bedPreviewModeText) {
                if (currentPrinterModel === 'A1Mini') {
                    bedPreviewModeText.innerHTML = 'The <strong style="color: var(--accent);">green border</strong> shows the active print area (X0 to X180). Print head parks at X-13 after each print (parking position). Wiggle sweep extends to X-13.<br><span style="font-size: 0.85em; color: var(--danger);">‚ö†Ô∏è A1 Mini requires 50mm+ clearance to the left of the printer for wiggle sweep (shown in red zone).</span>';
                } else {
                    bedPreviewModeText.innerHTML = 'The <strong style="color: var(--accent);">green border</strong> shows the active print area (X0 to X256). Print head parks at X-48 after each print (parking position). Wiggle sweep extends to X-48.<br><span style="font-size: 0.85em; color: var(--muted);">‚ÑπÔ∏è A1 print head is parked at X-48 (no clearance needed). A1 Mini users should ensure 50mm+ clearance to the left.</span>';
                }
            }
            if (sweepModeText) {
                if (currentPrinterModel === 'A1Mini') {
                    sweepModeText.textContent = '(Full-width wiggle sweep: X180 ‚Üí X-13)';
                } else {
                    sweepModeText.textContent = '(Full-width wiggle sweep: X256 ‚Üí X-48)';
                }
            }
        } else {
            // Show P1/X1 zones (both use same push system), hide canvas
            if (bedPreviewP1) bedPreviewP1.style.display = 'block';
            if (bedPreviewCanvas) bedPreviewCanvas.style.display = 'none';
            // Update text to match P1/X1's default text
            if (bedPreviewModeText) {
                bedPreviewModeText.innerHTML = 'The zone with the <strong style="color: var(--accent);">green border</strong> is the selected push direction.<br><span style="font-size: 0.85em;">In advanced mode, you can click any zone to change it after file upload.</span>';
            }
            // Show sweep indicator for P1/X1 if enabled
            const sweepIndicator = document.getElementById('sweepIndicator');
            const enableSweep = document.getElementById('enableSweep');
            if (sweepIndicator && enableSweep) {
                sweepIndicator.style.display = enableSweep.checked ? 'block' : 'none';
            }
            if (sweepModeText) {
                sweepModeText.textContent = '(7 passes after each loop)';
            }
        }
    }

    /**
     * Draws A1 bed preview on canvas with extended X-range and warning zones
     * Clean, modern design matching P1/X1/A1 aesthetic
     */
    function drawBedPreview() {
        const canvas = document.getElementById("bedPreviewCanvas");
        if (!canvas) return;
        
        const container = document.getElementById("bedPreviewContainer");
        if (!container) return;
        
        // Get device pixel ratio for crisp rendering on high-DPI displays
        const dpr = window.devicePixelRatio || 1;
        
        // Get container dimensions
        const rect = container.getBoundingClientRect();
        const displayWidth = rect.width;
        const displayHeight = rect.height;
        
        // Set canvas internal resolution (actual pixels) - scaled by devicePixelRatio for sharpness
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        
        // Set canvas display size (CSS pixels) - matches container
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        
        const ctx = canvas.getContext('2d');
        
        // Scale context to handle devicePixelRatio
        ctx.scale(dpr, dpr);
        
        // Use display dimensions for drawing (not internal resolution)
        const width = displayWidth;
        const height = displayHeight;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Clip to border-radius (10px) to match container styling
        const borderRadius = 10;
        ctx.beginPath();
        if (ctx.roundRect) {
            // Modern browsers support roundRect
            ctx.roundRect(0, 0, width, height, borderRadius);
        } else {
            // Fallback for older browsers
            ctx.moveTo(borderRadius, 0);
            ctx.lineTo(width - borderRadius, 0);
            ctx.quadraticCurveTo(width, 0, width, borderRadius);
            ctx.lineTo(width, height - borderRadius);
            ctx.quadraticCurveTo(width, height, width - borderRadius, height);
            ctx.lineTo(borderRadius, height);
            ctx.quadraticCurveTo(0, height, 0, height - borderRadius);
            ctx.lineTo(0, borderRadius);
            ctx.quadraticCurveTo(0, 0, borderRadius, 0);
        }
        ctx.clip();
        
        // Coordinate system: Get bed bounds from PRINTER_MODELS
        const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.A1.bedBounds;
        const bedMinX = bedBounds.minX || -48; // A1: -48, A1 Mini: -13
        const bedMaxX = bedBounds.maxX || 256; // A1: 256, A1 Mini: 180
        const bedMaxY = bedBounds.maxY || 262; // A1: 262, A1 Mini: 185
        
        // Visual representation: Show extended range
        // For A1 Mini: Show 50mm clearance zone (not just 13mm to X0)
        // For A1: Show 48mm info zone (parking position)
        const requiresClearance = PRINTER_MODELS[currentPrinterModel]?.requiresClearance || false;
        const clearanceZoneWidth = requiresClearance ? 50 : Math.abs(bedMinX); // A1 Mini: 50mm, A1: 48mm
        const totalVisualWidth = bedMaxX + clearanceZoneWidth; // Total visual width (A1 Mini: 180+50=230, A1: 256+48=304)
        const warningZoneWidth = Math.floor((clearanceZoneWidth / totalVisualWidth) * width); // Left portion for warning/info zone
        
        if (DEBUG_MODE && requiresClearance) {
            console.log(`[DIAG] drawBedPreview A1 Mini: clearanceZoneWidth=${clearanceZoneWidth}mm, bedMaxX=${bedMaxX}mm, totalVisualWidth=${totalVisualWidth}mm, warningZoneWidth=${warningZoneWidth}px (${(warningZoneWidth/width*100).toFixed(1)}% of ${width}px)`);
        }
        const activePlateWidth = Math.floor((bedMaxX / totalVisualWidth) * width); // Right portion for active plate
        const activePlateStartX = warningZoneWidth;
        
        // Ensure all coordinates are within bounds (with padding for borders)
        const padding = 2; // Padding to keep borders inside
        const safeWidth = width - (padding * 2);
        const safeHeight = height - (padding * 2);
        const safeX = padding;
        const safeY = padding;
        
        // Draw subtle background grid - match P1's 20px grid size exactly (within safe bounds)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        const gridSize = 20; // Match P1's background-size: 20px 20px
        // Start grid from safeX, safeY to stay within bounds
        const startX = Math.ceil(safeX / gridSize) * gridSize;
        const startY = Math.ceil(safeY / gridSize) * gridSize;
        for (let x = startX; x < safeX + safeWidth; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, safeY);
            ctx.lineTo(x, safeY + safeHeight);
            ctx.stroke();
        }
        for (let y = startY; y < safeY + safeHeight; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(safeX, y);
            ctx.lineTo(safeX + safeWidth, y);
            ctx.stroke();
        }
        
        // Draw CLEARANCE/INFO AREA - Warning zone for A1 Mini (50mm), Info zone for A1 (48mm)
        // A1 Mini requires 50mm clearance to the left of the bed (red warning zone)
        // A1 print head is parked at X-48 (gray info zone, no clearance needed)
        // Ensure area stays within bounds
        const extendedAreaSafeWidth = Math.min(warningZoneWidth, safeWidth);
        if (requiresClearance) {
            // A1 Mini: Red warning zone (requires 50mm clearance to the left of the bed)
            // Make it more visible than A1's gray info zone
            ctx.fillStyle = 'rgba(255, 50, 50, 0.25)'; // More visible red (increased from 0.15)
            ctx.fillRect(safeX, safeY, extendedAreaSafeWidth, safeHeight);
            
            // Draw warning zone border - thicker, more visible red line
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)'; // More visible red (increased from 0.6)
            ctx.lineWidth = 2; // Thicker border (increased from 1)
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(safeX + 0.5, safeY + 0.5, extendedAreaSafeWidth - 1, safeHeight - 1);
            ctx.setLineDash([]);
            
            // Draw warning label (show clearance requirement, not X coordinate)
            ctx.save();
            ctx.translate(safeX + extendedAreaSafeWidth / 2, safeY + safeHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
            ctx.font = '11px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('50mm+ Clearance', 0, 0);
            ctx.restore();
        } else {
            // A1: Gray info zone (no clearance needed)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very subtle gray for info zone
            ctx.fillRect(safeX, safeY, extendedAreaSafeWidth, safeHeight);
            
            // Draw extended area border - thin dashed gray line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(safeX + 0.5, safeY + 0.5, extendedAreaSafeWidth - 1, safeHeight - 1);
            ctx.setLineDash([]);
            
            // Draw info label
            ctx.save();
            ctx.translate(safeX + extendedAreaSafeWidth / 2, safeY + safeHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '11px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`X${bedMinX} (Park)`, 0, 0);
            ctx.restore();
        }
        
        // Draw ACTIVE PLATE (X0 to X256/X180) - Neon green with glow
        // Reset shadow for border
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#2ecc71';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw active plate border - bright neon green (inset to stay within bounds)
        ctx.strokeStyle = '#2ecc71';
        ctx.lineWidth = 2;
        // Calculate safe plate position (ensure it starts after warning/info zone and stays within bounds)
        const plateX = Math.max(safeX + extendedAreaSafeWidth, safeX);
        const plateW = Math.min(activePlateWidth, safeWidth - (plateX - safeX));
        ctx.strokeRect(plateX, safeY, plateW, safeHeight);
        
        // Reset shadow
        ctx.shadowBlur = 0;
        
        // Draw active plate label - top center, slightly transparent white (within safe bounds)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Active Plate', plateX + plateW / 2, safeY + 8);
        
        // Draw sweep path (if enabled) - simple dashed line spanning full width
        const enableSweep = document.getElementById("enableSweep");
        if (enableSweep && enableSweep.checked) {
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            // Draw sweep path from X-48/X-13 to X256/X180 (full width, inset to stay within bounds)
            const sweepY = safeY + safeHeight / 2;
            const margin = 4; // Margin from edges
            ctx.beginPath();
            ctx.moveTo(safeX + margin, sweepY);
            ctx.lineTo(safeX + safeWidth - margin, sweepY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw arrow head at the end (pointing right, inset to stay within bounds)
            const arrowSize = 6;
            const arrowX = safeX + safeWidth - margin - arrowSize;
            ctx.fillStyle = 'rgba(46, 204, 113, 0.8)';
            ctx.beginPath();
            ctx.moveTo(arrowX, sweepY - arrowSize / 2);
            ctx.lineTo(safeX + safeWidth - margin, sweepY);
            ctx.lineTo(arrowX, sweepY + arrowSize / 2);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw axis labels - subtle (within safe bounds)
        ctx.fillStyle = 'rgba(139, 148, 158, 0.7)';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('FRONT', safeX + safeWidth / 2 - 18, safeY + safeHeight - 12);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('BACK', safeX + safeWidth / 2, safeY + 10);
        ctx.save();
        ctx.translate(safeX + 8, safeY + safeHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('LEFT', 0, 0);
        ctx.restore();
        ctx.save();
        ctx.translate(safeX + safeWidth - 8, safeY + safeHeight / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('RIGHT', 0, 0);
        ctx.restore();
        
        // Draw coordinate markers - subtle (within safe bounds)
        ctx.fillStyle = 'rgba(139, 148, 158, 0.6)';
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        // X0 marker (boundary between warning/info zone and active plate - start of print bed)
        ctx.fillText('X0', safeX + extendedAreaSafeWidth, safeY + safeHeight - 10);
        // X marker (end of active plate)
        ctx.fillText(`X${bedMaxX}`, safeX + safeWidth - 6, safeY + safeHeight - 10);
        // For A1 Mini: Show X-13 marker (wiggle sweep extends to here) at appropriate position
        if (requiresClearance) {
            // Calculate position for X-13 marker (13mm into the 50mm clearance zone from X0)
            const x13PositionRatio = 13 / clearanceZoneWidth; // Position of X-13 within clearance zone
            const x13MarkerX = safeX + (extendedAreaSafeWidth * (1 - x13PositionRatio));
            ctx.fillText('X-13', x13MarkerX, safeY + safeHeight - 10);
        } else {
            // A1: Show X-48 marker (parking position)
            ctx.fillText(`X${bedMinX}`, safeX + extendedAreaSafeWidth / 2, safeY + safeHeight - 10);
        }
    }

    /**
     * Gets the appropriate start code template based on printer model
     * @returns {string} Start code template
     */
    function getStartCodeTemplate() {
        if (!currentPrinterModel) {
            return START_CODE_3MF; // Default to P1 template if no printer model selected
        }
        if (currentPrinterModel === 'A1') {
            return START_CODE_A1;
        } else if (currentPrinterModel === 'A1Mini') {
            return START_CODE_A1_MINI;
        } else if (currentPrinterModel === 'x1') {
            // X1: Select template based on purge checkbox
            const purgeEnabled = document.getElementById("purgeEnabled");
            if (purgeEnabled && purgeEnabled.checked) {
                return X1_START_FLUSH;
            } else {
                return X1_START_NO_FLUSH;
            }
        } else if (currentPrinterModel === 'P1') {
            // P1: Select template based on purge checkbox
            const purgeEnabled = document.getElementById("purgeEnabled");
            if (purgeEnabled && purgeEnabled.checked) {
                return START_CODE_3MF; // P1 with flush (original template)
            } else {
                return P1_START_NO_FLUSH; // P1 without flush
            }
        } else {
            return START_CODE_3MF; // P1 template (fallback)
        }
    }

    /**
     * Applies printer-specific temperature offset
     * A1 has +4¬∞C sensor offset, so we subtract 4¬∞C from user input
     * @param {number} userTemp - User's target temperature
     * @returns {number} Actual temperature to write in G-code
     */
    function applyTempOffset(userTemp) {
        if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
            const model = PRINTER_MODELS[currentPrinterModel];
            return Math.max(15, userTemp + model.tempOffset); // tempOffset is -4 for both A1 and A1Mini
        }
        return userTemp;
    }

    /**
     * Generates M190 wait command(s) with printer-specific handling
     * A1 requires multiple M190 commands due to 90-second timeout
     * @param {number} temp - Target temperature
     * @returns {string} M190 command(s)
     */
    function generateM190Command(temp) {
        const actualTemp = applyTempOffset(temp);
        
        if (currentPrinterModel === 'A1') {
            // A1: Generate 45 M190 commands to prevent timeout (Factorian's End_A1.txt lines 117-161: 45 commands)
            const count = 45;
            return Array(count).fill(`M190 S${actualTemp}`).join('\n');
        } else if (currentPrinterModel === 'A1Mini') {
            // A1 Mini: Generate 50 M190 commands to prevent timeout (Factorian's End_A1_Mini.txt lines 116-165: 50 commands)
            const count = 50;
            return Array(count).fill(`M190 S${actualTemp}`).join('\n');
        } else if (currentPrinterModel === 'x1') {
            // X1: Generate 30 M190 commands (matching Factorian's X1 template exactly - lines 58-97: 30 commands)
            const count = 30;
            return Array(count).fill(`M190 S${actualTemp}`).join('\n');
        } else if (currentPrinterModel === 'P1') {
            // P1: Generate 30 M190 commands (matching Factorian's P1 template exactly - lines 57-96: 30 commands)
            const count = 30;
            return Array(count).fill(`M190 S${actualTemp}`).join('\n');
        } else {
            // Fallback: Single M190 command
            return `M190 S${actualTemp}`;
        }
    }

    /**
     * Updates start code textarea with variable replacement
     * @param {string|null} gcodeContent - G-code content to extract variables from, or null to show template
     */
    function updateStartCodeTextarea(gcodeContent) {
        try {
            const startCodeTextarea = document.getElementById("startCode");
            if (!startCodeTextarea) return; // Element doesn't exist if advanced settings not visible
            
            // CRITICAL: Get the correct start code template based on current printer model
            const startCodeTemplate = getStartCodeTemplate();
            
            // If no G-code content provided, show template
            if (!gcodeContent) {
                startCodeTextarea.value = startCodeTemplate;
                return;
            }
            
            // Parse G-code structure to get config block
            const structure = parseGcodeStructure(gcodeContent);
            const gcodeConfig = structure.config || '';
            
            // Extract variable values
            const variableValues = extractVariableValues(gcodeContent, gcodeConfig);
            
            // Replace variables in start code (use the correct template for current printer model)
            const startCodeWithVars = replaceStartCodeVariables(startCodeTemplate, variableValues);
            
            // Update textarea
            startCodeTextarea.value = startCodeWithVars;
            
            if (DEBUG_MODE) {
                console.log("[DIAG] updateStartCodeTextarea: Updated start code for printer model:", currentPrinterModel, "length:", startCodeWithVars.length);
            }
        } catch (error) {
            if (DEBUG_MODE) console.error("Error updating start code textarea:", error);
            // If error, show template without variable replacement
            const startCodeTextarea = document.getElementById("startCode");
            if (startCodeTextarea) {
                startCodeTextarea.value = getStartCodeTemplate();
            }
        }
    }

    /**
     * Updates all end code textareas with current settings
     * Uses dynamic push coordinates based on model placement if available
     */
    function updateEndCodeTextareas() {
        if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Called for printer model:", currentPrinterModel);
        
        // CRITICAL: Only sync from dropdown if currentPrinterModel is not set
        // DO NOT override currentPrinterModel if it's already set (e.g., from auto-detection)
        // This prevents auto-detected A1 from being overwritten by stale dropdown value
        if (!currentPrinterModel || currentPrinterModel === '') {
            const modelSelect = document.getElementById("printerModel");
            if (modelSelect && modelSelect.value) {
                const selectedModel = modelSelect.value;
                if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: currentPrinterModel not set, using dropdown value:", selectedModel);
                currentPrinterModel = selectedModel;
            } else {
                // No printer model selected - don't generate end codes
                if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: No printer model selected, skipping end code generation");
                return;
            }
        } else {
            // currentPrinterModel is already set - trust it (likely from auto-detection)
            // Only log mismatch for debugging, but don't override
            const modelSelect = document.getElementById("printerModel");
            if (modelSelect && modelSelect.value && currentPrinterModel !== modelSelect.value) {
                if (DEBUG_MODE) console.warn("[DIAG] updateEndCodeTextareas: currentPrinterModel mismatch! current:", currentPrinterModel, "selected:", modelSelect.value, "- keeping current (likely from auto-detection)");
            }
        }
        
        const off = currentOffset;
        const temp = getCooldownTemp();
        if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Parameters - offset:", off, "temp:", temp);
        
        const originalDirection = currentDirection;
        
        // LOGIC FIREWALL: Strict routing - A1 must use A1-specific logic, never fall through to P1 logic
        if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas:", currentPrinterModel, "path - updating end code");
            
            // Update A1 end code
            const endA1CodeEl = document.getElementById('endA1Code');
            if (!endA1CodeEl) {
                if (DEBUG_MODE) console.warn("[DIAG] updateEndCodeTextareas: A1 end code element not found! This may cause 'End code is empty' error.");
                return; // Exit early if element doesn't exist
            }
            
            // Calculate model center Y for A1/A1Mini (fallback to 128 if not available)
            const modelCenterY = calculateModelCenterY();
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas:", currentPrinterModel, "modelCenterY:", modelCenterY, "lastDebugData:", lastDebugData);
            
            // Generate A1/A1Mini end code - always generate even if lastDebugData is not available yet
            const a1EndCode = (currentPrinterModel === 'A1Mini') ? getA1MiniEndCode(temp, off, modelCenterY) : getA1EndCode(temp, off, modelCenterY);
            endA1CodeEl.value = a1EndCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas:", currentPrinterModel, "end code updated, length:", a1EndCode.length);
            
            return; // Don't process P1 end codes
        }
        
        // LOGIC FIREWALL: P1/X1 path - validate we're actually P1 or X1
        if (currentPrinterModel !== 'P1' && currentPrinterModel !== 'x1') {
            throw new Error(`FIREWALL VIOLATION: updateEndCodeTextareas is P1/X1-only but called with model: ${currentPrinterModel}`);
        }
        if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: P1/X1 path - processing end codes");
        
        // CRITICAL: Ensure P1 end code elements exist
        const endCenterEl = document.getElementById('endCenterCode');
        const endLeftEl = document.getElementById('endLeftCode');
        const endRightEl = document.getElementById('endRightCode');
        
        if (!endCenterEl || !endLeftEl || !endRightEl) {
            if (DEBUG_MODE) console.warn("[DIAG] updateEndCodeTextareas: P1/X1 end code elements not found! This may cause 'End code is empty' error.");
            // Don't return - try to continue with available elements
        }
        
        // Try to get dynamic coordinates from model placement
        // Note: calculateDynamicPushCoordinates() has its own FIREWALL guard for P1/X1
        const dynamicCoords = calculateDynamicPushCoordinates();
        if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Dynamic coordinates:", dynamicCoords);
        
        if (dynamicCoords) {
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Using dynamic coordinates for all directions");
            // Use dynamic coordinates based on actual model placement
            // All directions use the same calculated coordinates (center, left, right lanes)
            
            // Show warning if offset was auto-adjusted
            if (dynamicCoords.warning) {
                if (DEBUG_MODE) console.warn("[DIAG] updateEndCodeTextareas: Offset warning:", dynamicCoords.warning);
                const statusEl = document.getElementById("pushLaneOffsetStatus");
                const maxInfoEl = document.getElementById("pushLaneOffsetMaxInfo");
                if (statusEl) {
                    statusEl.textContent = dynamicCoords.warning;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.textContent = `Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm`;
                    maxInfoEl.style.display = "block";
                }
            }
            
            currentDirection = 'center';
            const centerCode = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
            document.getElementById("endCenterCode").value = centerCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Center end code updated, length:", centerCode.length);
            
            currentDirection = 'right';
            const rightCode = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
            document.getElementById("endRightCode").value = rightCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Right end code updated, length:", rightCode.length);
            
            currentDirection = 'left';
            const leftCode = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
            document.getElementById("endLeftCode").value = leftCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Left end code updated, length:", leftCode.length);
        } else {
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: No dynamic coordinates, using hardcoded fallback");
            // Fallback to hardcoded coordinates if no model data available
            // CENTER (40mm separation): X108, X148
            currentDirection = 'center'; 
            const centerCode = getEndCode(off, temp, 170, 108, 148, 148);
            document.getElementById("endCenterCode").value = centerCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Center end code (fallback) updated, length:", centerCode.length);

            // RIGHT (40mm separation): X180, X220
            currentDirection = 'right';
            const rightCode = getEndCode(off, temp, 220, 180, 220, 220);
            document.getElementById("endRightCode").value = rightCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Right end code (fallback) updated, length:", rightCode.length);
                
            // LEFT (40mm separation): Safe X positions (min 10mm to avoid filament cutter)
            // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
            const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
            const bedMinX = bedBounds.minX || 10;
            
            currentDirection = 'left';
            const leftCode = getEndCode(off, temp, 
                Math.max(bedMinX, 36), 
                Math.max(bedMinX, 30), Math.max(bedMinX, 50), Math.max(bedMinX, 70)
            );
            document.getElementById("endLeftCode").value = leftCode;
            if (DEBUG_MODE) console.log("[DIAG] updateEndCodeTextareas: Left end code (fallback) updated, length:", leftCode.length);
        }
            
        currentDirection = originalDirection;
        selectDirection(currentDirection, false); 
    }

    /**
     * Shows info dialog about test file before generating
     * Handles both G-code and 3MF files
     */
    async function showTestFileInfo() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) {
            showStatus("fileError", "error");
            return;
        }

        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        let content = null;
        
        try {
            if (is3MF) {
                // For 3MF files, unzip and extract G-code
                if (typeof JSZip === 'undefined') {
                    alert("Error: JSZip library not loaded. Please refresh the page.");
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Find G-code file
                const gcodeFiles = [];
                zip.forEach((relativePath) => {
                    if (relativePath.match(/^Metadata\/plate_\d+\.gcode$/i)) {
                        gcodeFiles.push(relativePath);
                    }
                });
                
                if (gcodeFiles.length === 0) {
                    alert("Error: No G-code file found in 3MF.");
                    return;
                }
                
                content = await zip.file(gcodeFiles[0]).async('string');
            } else {
                // For G-code files, read directly
                content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            // Extract model height from G-code header
            const maxZMatch = content.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let modelHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                modelHeight = parseFloat(maxZMatch[1]);
            }

            if (!modelHeight || modelHeight <= 0) {
                alert("Could not detect model height from G-code header. Please ensure the file contains 'max_z_height' in the header.");
                return;
            }

            // Calculate bed position
            let bedZ;
            if (modelHeight > 31) {
                bedZ = modelHeight - 30;
            } else {
                bedZ = 1;
            }

            const directionNames = { left: "Left", center: "Center", right: "Right" };
            const directionName = directionNames[currentDirection] || currentDirection;

            const message = `Test File Information:

This will generate a simple test file that:
‚Ä¢ Moves hotend to safe position
‚Ä¢ Lowers bed to ${bedZ.toFixed(2)}mm (Factorian method: ${modelHeight.toFixed(2)}mm - 30mm)
‚Ä¢ Performs push-off from ${directionName} side (outer lane first, then inner lane)

The test file does NOT include:
‚Ä¢ Print G-code
‚Ä¢ Cooldown sequence
‚Ä¢ Multiple loops

Use this to test if the push-off height is correct before running the full looped print.

Model height: ${modelHeight.toFixed(2)}mm
Push direction: ${directionName}
Bed will lower to: Z${bedZ.toFixed(2)}

Generate test file?`;

            if (confirm(message)) {
                generateTestFile();
            }
        } catch (error) {
            if (DEBUG_MODE) console.error("Error reading file for test info:", error);
            alert("Error reading file: " + error.message);
        }
    }

    /**
     * Generates a test file for push-off testing
     * Creates a simple G-code file that only performs push-off sequence
     * Based on the uploaded file's model height and selected push direction
     */
    /**
     * Generates a test G-code file for push-off testing
     * Validates direction and extracts model height from G-code header
     * Creates a minimal test file with only push-off sequence
     * Handles both G-code and 3MF files
     */
    async function generateTestFile() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) {
            showStatus("fileError", "error");
            return;
        }

        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        let content = null;
        
        try {
            if (is3MF) {
                // For 3MF files, unzip and extract G-code
                if (typeof JSZip === 'undefined') {
                    alert("Error: JSZip library not loaded. Please refresh the page.");
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Find G-code file
                const gcodeFiles = [];
                zip.forEach((relativePath) => {
                    if (relativePath.match(/^Metadata\/plate_\d+\.gcode$/i)) {
                        gcodeFiles.push(relativePath);
                    }
                });
                
                if (gcodeFiles.length === 0) {
                    alert("Error: No G-code file found in 3MF.");
                    return;
                }
                
                content = await zip.file(gcodeFiles[0]).async('string');
            } else {
                // For G-code files, read directly
                content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            // Extract model height from G-code header
            const maxZMatch = content.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let modelHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                modelHeight = parseFloat(maxZMatch[1]);
            }

            if (!modelHeight || modelHeight <= 0) {
                alert("Could not detect model height from G-code header. Please ensure the file contains 'max_z_height' in the header.");
                return;
            }

            // Ensure currentPrinterModel is set
            const modelSelect = document.getElementById("printerModel");
            if (modelSelect && modelSelect.value) {
                currentPrinterModel = modelSelect.value;
            }
            if (!currentPrinterModel) {
                currentPrinterModel = "P1"; // Default fallback
            }
            
            // A1/A1Mini uses Y-axis push (no direction selector needed)
            if (currentPrinterModel === 'A1' || currentPrinterModel === 'A1Mini') {
                // A1/A1Mini doesn't use push direction or lane offset
                // Get model center X and Y from lastDebugData if available
                const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.A1.bedBounds;
                let modelCenterX = (bedBounds.minX + bedBounds.maxX) / 2; // Default bed center X
                let modelCenterY = (bedBounds.minY + bedBounds.maxY) / 2; // Default bed center Y
                if (lastDebugData) {
                    if (lastDebugData.minX !== undefined && lastDebugData.maxX !== undefined) {
                        modelCenterX = (lastDebugData.minX + lastDebugData.maxX) / 2;
                    }
                    if (lastDebugData.minY !== undefined && lastDebugData.maxY !== undefined) {
                        modelCenterY = (lastDebugData.minY + lastDebugData.maxY) / 2;
                    }
                }
                
                // Calculate bed Z using A1's 41mm rule (Factorian's A1 method)
                let bedZ;
                if (modelHeight > 41) {
                    bedZ = modelHeight - 40; // A1: 41mm rule
                } else {
                    bedZ = 1.0; // Minimum safe position
                }
                
                // Generate A1/A1Mini test file with Y-axis push
                const modelName = (currentPrinterModel === 'A1Mini') ? 'A1 Mini' : 'A1';
                const bedMaxY = bedBounds.maxY || 262;
                const testCode = `; Test G-code for ${modelName} push-off testing (Y-axis push, bed moves)
; Model height: ${modelHeight.toFixed(2)}mm (max_layer_z = ${modelHeight.toFixed(2)})
; Printer: Bambu Lab ${modelName}
; Push type: Y-axis (bed moves forward)
; Model center X: ${modelCenterX.toFixed(2)}mm, Y: ${modelCenterY.toFixed(2)}mm
; 
; Factorian's A1 method (41mm rule):
; - If max_layer_z > 41: G1 Z{max_layer_z - 40}
; - Else: G1 Z1.0
; 
; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 41 ? `${modelHeight.toFixed(2)} > 41` : `${modelHeight.toFixed(2)} <= 41`} ‚Üí G1 Z${bedZ.toFixed(2)}
; This lowers bed from ${modelHeight.toFixed(2)}mm to ${bedZ.toFixed(2)}mm (${(modelHeight - bedZ).toFixed(2)}mm lower)

; Initialize
G28 ; Home all axes
G90 ; Absolute positioning
G21 ; Set units to millimeters

; CRITICAL STEP 1: Move hotend to safe position AND safe Z height
; Move hotend AWAY from print (to safe X/Y position)
G1 X0 Y${modelCenterY.toFixed(2)} F18000 ; Move to safe X/Y position (away from print)
G1 X${bedBounds.poopZoneX || -13.0} F3000 ; Move to safe X position (A1: X-13.0, A1 Mini: X-13.5)
; CRITICAL: Move hotend UP to safe Z height BEFORE lowering bed
; Hotend must be HIGHER than model (${modelHeight.toFixed(2)}mm) + safety margin
G1 Z${Math.max(150, modelHeight + 20).toFixed(0)} F900 ; Move hotend to safe Z height (above ${modelHeight.toFixed(2)}mm model)
M400 ; Wait for motion to complete

; CRITICAL STEP 2: Lower bed using Factorian's A1 method (41mm rule)
; Factorian's A1 logic: {if (max_layer_z ) > 41}
;                       G1 Z{max_layer_z - 40} F600
;                       {else}
;                       G1 Z1.0 F600
;                       {endif}
; 
; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 41 ? `${modelHeight.toFixed(2)} > 41` : `${modelHeight.toFixed(2)} <= 41`} ‚Üí G1 Z${bedZ.toFixed(2)}
; Since hotend is now at safe height, this is safe
G1 Z${bedZ.toFixed(2)} F600 ; Factorian A1 method: max_layer_z (${modelHeight.toFixed(2)}) - ${modelHeight > 41 ? '40' : `${modelHeight - 1}`} = ${bedZ.toFixed(2)}
M400 ; Wait for motion to complete

; CRITICAL STEP 3: Align nozzle X-position with model center before push
; After cooldown, toolhead is at X-48 (A1) or X-13 (A1 Mini). We must move it to model center
; before the bed moves forward (Y-0.5), otherwise the push will miss the model.
G0 X${modelCenterX.toFixed(2)} F12000 ; Align nozzle with model center for push
M400 ; Wait for motion to complete

; === A1 Y-AXIS PUSH-OFF SEQUENCE ===
; Factorian Speed: F300 (very slow to prevent tipping on moving bed)
G1 Y-0.5 F300 ; very slow push off using the bed (Y-axis, bed moves)
M400 ; Wait for push to complete

; Return bed to safe position
G1 Y${bedMaxY} F800 ; move bed forward again (A1: Y262, A1 Mini: Y185)
M400 ; Wait for motion to complete

; Return to safe position
G1 X0 Y${modelCenterY.toFixed(2)} F18000 ; Return to safe position
G1 X${bedBounds.poopZoneX || -13.0} F3000

; End
M400 ; Wait for all motion to complete
M30 ; End of program
`;

                // Get push-off speed from input and replace F300 in test code
                const pushSpeedInput = document.getElementById("pushSpeedInput");
                const pushSpeed = pushSpeedInput ? (parseFloat(pushSpeedInput.value) || DEFAULT_PUSH_SPEED) : DEFAULT_PUSH_SPEED;
                const validatedPushSpeed = Math.max(MIN_PUSH_SPEED, Math.min(MAX_PUSH_SPEED, pushSpeed));
                
                // Replace F300 in push-off sequence with the validated speed
                const testCodeWithSpeed = testCode.replace(/Y-0\.5 F300/g, `Y-0.5 F${validatedPushSpeed}`);
                
                // Add A1/A1Mini wiggle sweep if enabled (A1/A1Mini sweep is always active, but can be tested separately)
                let sweepGcode = '';
                const sweepZInput = document.getElementById("sweepZInput");
                const sweepSpeedInput = document.getElementById("sweepSpeedInput");
                if (sweepZInput && sweepSpeedInput) {
                    const zHeight = parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z;
                    const speed = parseFloat(sweepSpeedInput.value) || DEFAULT_SWEEP_SPEED;
                    if (currentPrinterModel === 'A1Mini') {
                        sweepGcode = generateA1MiniWiggleSweep(zHeight, speed);
                    } else {
                        sweepGcode = generateA1WiggleSweep(zHeight, speed);
                    }
                }
                
                const testCodeFinal = testCodeWithSpeed.replace('; End', sweepGcode + '\n; End');
                
                // Download the test file
                const blob = new Blob([testCodeFinal], { type: 'text/plain' });
                let url = null;
                try {
                    url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const originalFilename = is3MF 
                        ? file.name.replace(/\.[^.]*$/, "") 
                        : file.name.replace(/\.(gcode|gco|g|txt)$/i, "") || "test";
                    const printerSuffix = (currentPrinterModel === 'A1Mini') ? 'A1Mini' : 'A1';
                    a.download = `${originalFilename}_test_pushoff_${printerSuffix}_${modelHeight.toFixed(0)}mm.gcode`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } finally {
                    if (url) {
                        URL.revokeObjectURL(url);
                    }
                }
                
                showStatus("A1 test file generated successfully!", "success");
                return;
            }
            
            // P1/X1: Validate push direction (edge case #15)
            const validDirections = ['left', 'center', 'right'];
            if (!validDirections.includes(currentDirection)) {
                alert(`Invalid push direction: ${currentDirection}. Please select a valid direction.`);
                return;
            }
            
            // Get push lane offset from input
            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
            const pushLaneOffset = pushLaneOffsetInput ? (parseFloat(pushLaneOffsetInput.value) || DEFAULT_PUSH_LANE_OFFSET) : DEFAULT_PUSH_LANE_OFFSET;
            
            // Get dynamic push coordinates if available, otherwise use fallback
            let xStart, xLeft, xCenter, xRight;
            let dynamicCoords = null;
            if (currentPrinterModel === 'P1' || currentPrinterModel === 'x1') {
                dynamicCoords = calculateDynamicPushCoordinates(pushLaneOffset);
            }
            
            if (dynamicCoords) {
                // Use dynamic coordinates based on actual model placement
                xStart = parseFloat(dynamicCoords.safeX);
                xLeft = parseFloat(dynamicCoords.leftX);
                xCenter = parseFloat(dynamicCoords.centerX);
                xRight = parseFloat(dynamicCoords.rightX);
            } else {
                // Fallback to hardcoded coordinates if no model data
                if (currentDirection === 'center') {
                    xStart = 170;
                    xLeft = 108;
                    xCenter = 128;
                    xRight = 148;
                } else if (currentDirection === 'right') {
                    xStart = 220;
                    xLeft = 180;
                    xCenter = 200;
                    xRight = 220;
                } else { // left
                    // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
                    const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
                    const bedMinX = bedBounds.minX || 10;
                    
                    // Ensure all X positions are within safe boundaries (min 10mm to avoid filament cutter)
                    xStart = Math.max(bedMinX, 36);
                    xLeft = Math.max(bedMinX, 30);
                    xCenter = Math.max(bedMinX, 50);
                    xRight = Math.max(bedMinX, 70);
                }
            }

            // Calculate bed position using Factorian's method
            let bedZ;
            if (modelHeight > 31) {
                bedZ = modelHeight - 30; // Factorian's method
            } else {
                bedZ = 1; // Minimum safe position
            }

            // Generate test file with dynamic multi-lane push system (P1/X1)
            const printerName = currentPrinterModel === 'x1' ? 'X1/X1C' : 'P1/P1S';
            const testCode = `; Test G-code for push-off testing (Dynamic Multi-Lane Push System)
            ; Model height: ${modelHeight.toFixed(2)}mm (max_layer_z = ${modelHeight.toFixed(2)})
            ; Printer: Bambu Lab ${printerName}
            ; Push direction: ${currentDirection.toUpperCase()}
            ${dynamicCoords ? `; Dynamic coordinates calculated from model placement:
            ; Model center: X${xCenter} (calculated from minX=${lastDebugData.minX.toFixed(1)}, maxX=${lastDebugData.maxX.toFixed(1)})
            ; Push lane offset: ${pushLaneOffset}mm (${dynamicCoords.adjustedOffset !== pushLaneOffset.toFixed(1) ? `auto-adjusted from ${pushLaneOffset}mm to ${dynamicCoords.adjustedOffset}mm` : 'as set'})
            ; Left lane: X${xLeft} (center - ${dynamicCoords.adjustedOffset}mm)
            ; Right lane: X${xRight} (center + ${dynamicCoords.adjustedOffset}mm)
            ${dynamicCoords.maxPossibleOffset ? `; Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm` : ''}` : `; Using fallback coordinates (no model placement data available)
            ; Push lane offset: ${pushLaneOffset}mm`}
            ; 
            ; Factorian's original method:
            ; - If max_layer_z > 31: G1 Z{max_layer_z - 30}
            ; - Else: G1 Z1
            ; 
            ; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 31 ? `${modelHeight.toFixed(2)} > 31` : `${modelHeight.toFixed(2)} <= 31`} ‚Üí G1 Z${bedZ.toFixed(2)}
            ; This lowers bed from ${modelHeight.toFixed(2)}mm to ${bedZ.toFixed(2)}mm (${(modelHeight - bedZ).toFixed(2)}mm lower)

            ; Initialize
            G28 ; Home all axes
            G90 ; Absolute positioning
            G21 ; Set units to millimeters

            ; CRITICAL STEP 1: Move hotend to safe position AND safe Z height
            ; Move hotend AWAY from print (to safe X/Y position)
            G1 X65 Y245 F12000 ; Move to safe X/Y position (away from print)
            G1 Y265 F3000
            ; CRITICAL: Move hotend UP to safe Z height BEFORE lowering bed
            ; Hotend must be HIGHER than model (${modelHeight.toFixed(2)}mm) + safety margin
            G1 Z${Math.max(150, modelHeight + 20).toFixed(0)} F600 ; Move hotend to safe Z height (above ${modelHeight.toFixed(2)}mm model)
            M400 ; Wait for motion to complete

            ; CRITICAL STEP 2: Lower bed using Factorian's original method
            ; Factorian's logic: {if (max_layer_z ) > 31}
            ;                    G1 Z{max_layer_z - 30} F600
            ;                    {else}
            ;                    G1 Z1 F600
            ;                    {endif}
            ; 
            ; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 31 ? `${modelHeight.toFixed(2)} > 31` : `${modelHeight.toFixed(2)} <= 31`} ‚Üí G1 Z${bedZ.toFixed(2)}
            ; Since hotend is now at safe height, this is safe
            ; NOTE: In test file, we hardcode the value since max_layer_z is not defined
            ; In actual Looprint-generated code, the IF statement will work correctly
            G1 Z${bedZ.toFixed(2)} F600 ; Factorian method: max_layer_z (${modelHeight.toFixed(2)}) - ${modelHeight > 31 ? '30' : `${modelHeight - 1}`} = ${bedZ.toFixed(2)}
            M400 ; Wait for motion to complete

            ; CRITICAL STEP 3: Move hotend to push-off start position
            ; Now that bed is lowered, hotend can safely move to push position
            G1 X${xStart} Y254 F600 ; Move nozzle a little to the side for safety
            M400 ; Wait all motion done

            ; === DYNAMIC MULTI-LANE PUSH-OFF SEQUENCE ===
            ; Three push lanes ensure centered force regardless of model shape
            
            ; --- PUSH LANE 1: CENTER (Primary push force at model center) ---
            G1 X${xCenter} Y230 F1200 ; Take start position at model center (X=${xCenter})
            G1 X${xCenter} Y5 F300 ; Push center lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety

            ; --- PUSH LANE 2: LEFT (30mm left of center for stability) ---
            G1 X${xLeft} Y230 F1200 ; Take start position at left lane (X=${xLeft}, center - 30mm)
            G1 X${xLeft} Y5 F300 ; Push left lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety

            ; --- PUSH LANE 3: RIGHT (30mm right of center for stability) ---
            G1 X${xRight} Y230 F1200 ; Take start position at right lane (X=${xRight}, center + 30mm)
            G1 X${xRight} Y5 F300 ; Push right lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety
`;

            // Get push-off speed from input and replace F300 in test code
            const pushSpeedInput = document.getElementById("pushSpeedInput");
            const pushSpeed = pushSpeedInput ? (parseFloat(pushSpeedInput.value) || DEFAULT_PUSH_SPEED) : DEFAULT_PUSH_SPEED;
            const validatedPushSpeed = Math.max(MIN_PUSH_SPEED, Math.min(MAX_PUSH_SPEED, pushSpeed));
            
            // Replace all F300 in push-off sequences with the validated speed
            const testCodeWithSpeed = testCode.replace(/Y5 F300/g, `Y5 F${validatedPushSpeed}`);

            // Add sweep if enabled
            let sweepGcode = '';
            const enableSweep = document.getElementById("enableSweep");
            if (enableSweep && enableSweep.checked) {
                const sweepSpeedInput = document.getElementById("sweepSpeedInput");
                const sweepZInput = document.getElementById("sweepZInput");
                const speed = sweepSpeedInput ? (parseFloat(sweepSpeedInput.value) || DEFAULT_SWEEP_SPEED) : DEFAULT_SWEEP_SPEED;
                const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
                sweepGcode = generateSweepGcode(zHeight, speed);
            }

            const testCodeFinal = testCodeWithSpeed + sweepGcode + `
; Return to safe position
G1 X65 Y245 F12000 ; Return to safe position
G1 Y265 F3000

; End
M400 ; Wait for all motion to complete
M30 ; End of program
`;

            // Download the test file (with memory leak protection)
            const blob = new Blob([testCodeFinal], { type: 'text/plain' });
            let url = null;
            try {
                url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // Handle both G-code and 3MF filenames
                const originalFilename = is3MF 
                    ? file.name.replace(/\.[^.]*$/, "") 
                    : file.name.replace(/\.(gcode|gco|g|txt)$/i, "") || "test";
                // Test files are always G-code format (G-code is extracted from 3MF if needed)
                const printerSuffix = currentPrinterModel === 'x1' ? 'X1' : (currentPrinterModel === 'A1Mini' ? 'A1Mini' : (currentPrinterModel === 'A1' ? 'A1' : 'P1'));
                a.download = `${originalFilename}_test_pushoff_${printerSuffix}_${modelHeight.toFixed(0)}mm.gcode`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } finally {
                if (url) {
                    URL.revokeObjectURL(url);
                }
            }

            showStatus("Test file generated successfully!", "success");
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in generateTestFile:", error);
            alert("Error generating test file: " + error.message);
        }
    }
    
    /**
     * Generates a simple test file with only sweep sequence (no temperature, no cooldown, no push-off)
     * Fast test to verify sweep functionality
     */
    function generateSweepTestFile() {
        try {
            // Get sweep settings from inputs
            const sweepSpeedInput = document.getElementById("sweepSpeedInput");
            const sweepZInput = document.getElementById("sweepZInput");
            const speed = sweepSpeedInput ? (parseFloat(sweepSpeedInput.value) || DEFAULT_SWEEP_SPEED) : DEFAULT_SWEEP_SPEED;
            const zHeight = sweepZInput ? (parseFloat(sweepZInput.value) || DEFAULT_SWEEP_Z) : DEFAULT_SWEEP_Z;
            
            // Validate inputs
            const validatedSpeed = Math.max(MIN_SWEEP_SPEED, Math.min(MAX_SWEEP_SPEED, speed));
            const validatedZ = Math.max(MIN_SWEEP_Z, Math.min(MAX_SWEEP_Z, zHeight));
            
            // Ensure currentPrinterModel is set
            const modelSelect = document.getElementById("printerModel");
            if (modelSelect && modelSelect.value) {
                currentPrinterModel = modelSelect.value;
            }
            if (!currentPrinterModel) {
                currentPrinterModel = "P1"; // Default fallback
            }
            
            // Generate sweep G-code
            const sweepGcode = generateSweepGcode(validatedZ, validatedSpeed);
            
            if (!sweepGcode) {
                alert("Error: Could not generate sweep G-code. Please check settings.");
                return;
            }
            
            // CRITICAL: Use printer model-specific bed bounds (not hardcoded P1 values)
            const bedBounds = PRINTER_MODELS[currentPrinterModel]?.bedBounds || PRINTER_MODELS.P1.bedBounds;
            const bedMinX = bedBounds.minX || 10;
            const bedMaxY = bedBounds.maxY || 256;
            const bedMinY = bedBounds.minY || 0;
            
            // Get printer name for test file
            const printerName = currentPrinterModel === 'A1Mini' ? 'A1Mini' : (currentPrinterModel === 'A1' ? 'A1' : (currentPrinterModel === 'x1' ? 'X1' : 'P1'));
            
            // Create minimal test file - just initialization, sweep, and end
            const testCode = `; Sweep Test File (Looprint)
            ; This file tests ONLY the sweep sequence
            ; No temperature, no cooldown, no push-off
            ; Printer: Bambu Lab ${printerName === 'A1Mini' ? 'A1 Mini' : (printerName === 'A1' ? 'A1' : (printerName === 'X1' ? 'X1/X1C' : 'P1/P1S'))}
            ; Sweep Z height: ${validatedZ.toFixed(1)}mm
            ; Sweep speed: ${validatedSpeed}mm/min

            ; Initialize printer
            G28 ; Home all axes
            G90 ; Absolute positioning
            G21 ; Set units to millimeters

            ; Move to safe position
            G1 X${bedMinX} Y${bedMaxY} Z${validatedZ.toFixed(1)} F5000 ; Move to start position (safe left position, back, at sweep height)
            M400 ; Wait for motion to complete

            ; === SWEEP SEQUENCE ===
            ${sweepGcode}

            ; Return to safe position
            G1 Z10 F600 ; Lift up
            M400 ; Wait for all motion to complete
            G1 X${bedMinX} Y${Math.max(bedMinY, 10)} F12000 ; Return to safe left position at front (avoids filament cutter)
            M400 ; Wait for all motion to complete

            ; End
            M30 ; End of program
            `;

            // Download the test file
            const blob = new Blob([testCode], { type: 'text/plain' });
            let url = null;
            try {
                url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sweep_test_${printerName}_${validatedZ.toFixed(1)}mm_${validatedSpeed}mmmin.gcode`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up URL after a delay
                setTimeout(() => {
                    if (url) URL.revokeObjectURL(url);
                }, 100);
                
                showStatus("Sweep test file generated successfully!", "success");
            } catch (downloadError) {
                if (DEBUG_MODE) console.error("Error downloading sweep test file:", downloadError);
                alert("Error downloading file. Please try again.");
                if (url) URL.revokeObjectURL(url);
            }
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in generateSweepTestFile:", error);
            alert("Error generating sweep test file: " + error.message);
        }
    }
    
    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', function(e) {
        // Enter = Generate (if button is not disabled and not in input field)
        if (e.key === 'Enter' && 
            !(DOM.generateBtn || document.getElementById("generateBtn")).disabled &&
            e.target.tagName !== 'INPUT' && 
            e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            processFiles();
        }
        
        // Esc = Reset (if not in input field) or close instructions
        if (e.key === 'Escape') {
            if (document.getElementById('instructionsModal').classList.contains('active')) {
                closeInstructions();
            } else if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            resetDefaults();
            }
        }
    });

    /**
     * Opens the instructions modal
     */
    function openInstructions() {
        const modal = document.getElementById('instructionsModal');
        if (modal) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
    }

    /**
     * Closes the instructions modal
     */
    function closeInstructions() {
        const modal = document.getElementById('instructionsModal');
        if (modal) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    }

    /**
     * Closes instructions modal when clicking on backdrop
     */
    function closeInstructionsOnBackdrop(event) {
        if (event.target.id === 'instructionsModal') {
            closeInstructions();
        }
    }
    // Global observer for Google Translate widget (created once)
    let translateWidgetObserver = null;
    
    // Force styling for Google Translate widget text color
    function forceTranslateWidgetStyle() {
        const menuValueElements = document.querySelectorAll('.goog-te-menu-value, .goog-te-menu-value span');
        menuValueElements.forEach(function(el) {
            if (el.style) {
                el.style.color = '#c9d1d9'; // Light gray text
                el.style.setProperty('color', '#c9d1d9', 'important');
            }
        });
        
        // Also target the gadget simple container
        const gadgetSimple = document.querySelector('.goog-te-gadget-simple');
        if (gadgetSimple) {
            const textElements = gadgetSimple.querySelectorAll('span, div');
            textElements.forEach(function(el) {
                if (el.classList && (el.classList.contains('goog-te-menu-value') || el.tagName === 'SPAN')) {
                    if (el.style) {
                        el.style.color = '#c9d1d9';
                        el.style.setProperty('color', '#c9d1d9', 'important');
                    }
                }
            });
        }
    }
    
    // Setup MutationObserver for Google Translate widget (only once)
    function setupTranslateWidgetObserver() {
        if (translateWidgetObserver) return; // Already set up
        
        translateWidgetObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) { // Element node
                        const menuValueElements = node.querySelectorAll ? node.querySelectorAll('.goog-te-menu-value, .goog-te-menu-value span') : [];
                        menuValueElements.forEach(function(el) {
                            if (el.style) {
                                el.style.color = '#c9d1d9';
                                el.style.setProperty('color', '#c9d1d9', 'important');
                            }
                        });
                        if (node.classList && (node.classList.contains('goog-te-menu-value') || node.classList.contains('goog-te-gadget-simple'))) {
                            if (node.style) {
                                node.style.color = '#c9d1d9';
                                node.style.setProperty('color', '#c9d1d9', 'important');
                            }
                        }
                    }
                });
            });
            // Also force style all existing elements
            forceTranslateWidgetStyle();
        });
        
        // Observe the translate element container
        const translateElement = document.getElementById('google_translate_element');
        if (translateElement) {
            translateWidgetObserver.observe(translateElement, { childList: true, subtree: true });
        }
        
        // Also observe document body for any translate elements added elsewhere
        translateWidgetObserver.observe(document.body, { childList: true, subtree: true });
    }
    
    // Google Translate Widget
    function googleTranslateElementInit() {
        if (typeof google !== 'undefined' && google.translate) {
            new google.translate.TranslateElement({
                pageLanguage: 'en',
                includedLanguages: 'da,de,es,fr,it,nl,no,pl,pt,ru,sv,zh-CN,ja,ko',
                layout: google.translate.TranslateElement.InlineLayout.SIMPLE,
                autoDisplay: false
            }, 'google_translate_element');
            
            // Setup observer (only once)
            setupTranslateWidgetObserver();
            
            // Force styling after widget is created (with delays to catch delayed rendering)
            setTimeout(forceTranslateWidgetStyle, 50);
            setTimeout(forceTranslateWidgetStyle, 200);
            setTimeout(forceTranslateWidgetStyle, 500);
            setTimeout(forceTranslateWidgetStyle, 1000);
        } else {
            console.error('Google Translate API not loaded');
        }
    }
    
    // Ensure Google Translate loads after page is ready
    window.addEventListener('load', function() {
        if (typeof google === 'undefined' || !google.translate) {
            // Retry loading if not already loaded
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = 'https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit';
            document.body.appendChild(script);
        } else {
            // Widget already loaded, setup observer and force styling
            setupTranslateWidgetObserver();
            setTimeout(forceTranslateWidgetStyle, 100);
            setTimeout(forceTranslateWidgetStyle, 500);
        }
    });
    
    // Also setup observer when DOM is ready (in case widget loads early)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setupTranslateWidgetObserver();
        });
    } else {
        // DOM already loaded
        setupTranslateWidgetObserver();
    }
</script>
<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</body>
</html>
