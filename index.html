<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="color-scheme" content="dark">
    <title>LOOPRINT (Beta)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg: #0d1117;
            --card: #161b22;
            --accent: #2ea043;
            --accent-soft: #238636;
            --text: #c9d1d9;
            --muted: #8b949e;
            --input: #21262d;
            --border: #30363d;
            --danger: #f85149;
            --warning: #d29922;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 20px;
            display: flex; justify-content: center;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #161b22 0, #0d1117 45%, #02040a 100%);
            color: var(--text);
        }
        .container {
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(8px);
            padding: 24px 24px 20px;
            border-radius: 16px;
            border: 1px solid var(--border);
            max-width: 900px; width: 100%;
            box-shadow: 0 18px 45px rgba(0,0,0,0.55);
        }
        .header-row {
            display: flex; justify-content: space-between; gap: 16px;
            align-items: flex-start; padding-bottom: 14px;
            border-bottom: 1px solid var(--border); margin-bottom: 18px;
        }
        h1 { margin: 0 0 6px; font-size: 1.7rem; color: var(--accent); letter-spacing: 0.02em; }
        .subtitle { margin: 0; color: var(--muted); font-size: 0.9rem; max-width: 520px; }
        .badge {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 3px 8px; border-radius: 999px;
            border: 1px solid var(--border); font-size: 0.7rem;
            color: var(--muted); margin-top: 4px;
        }
        label { display: block; font-size: 0.85rem; font-weight: 600; margin-bottom: 6px; }
        select, input[type="file"], input[type="number"] {
            width: 100%; padding: 9px 10px; border-radius: 8px;
            border: 1px solid var(--border); background: var(--input);
            color: var(--text); font-size: 0.9rem;
        }
        select:focus, input:focus {
            outline: 2px solid var(--accent-soft); outline-offset: 1px; border-color: var(--accent-soft);
        }
        .section { margin-top: 0; padding-top: 14px; border-top: 1px solid var(--border); }
        .section:first-of-type { border-top: none; }
        .section-title { font-size: 0.95rem; font-weight: 600; margin-bottom: 8px; }
        .help-text { margin: 4px 0 0; font-size: 0.78rem; color: var(--muted); }
        .row { display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; }
        .col { flex: 1; min-width: 200px; }
        .checkbox-container {
            margin-top: 10px; padding: 9px 10px; border-radius: 8px;
            border: 1px solid var(--border); background: var(--input);
            display: flex; align-items: flex-start; gap: 8px; font-size: 0.83rem;
        }
        .checkbox-container input { margin-top: 2px; }
        
        /* Button Styles */
        .btn-row { display: flex; gap: 12px; margin-top: 18px; }
        button { font-family: inherit; }
        button.primary {
            flex: 2; padding: 11px 12px;
            border-radius: 999px; border: none; font-size: 1rem;
            font-weight: 600; cursor: pointer;
            background: linear-gradient(135deg, var(--accent), var(--accent-soft));
            color: #06090f;
            box-shadow: 0 8px 18px rgba(46, 160, 67, 0.35);
            transition: all 0.2s ease;
        }
        button.primary:hover { filter: brightness(1.05); transform: translateY(-1px); }
        button.primary:active { transform: translateY(0); }
        button.primary:disabled {
            background: var(--input); color: var(--muted);
            cursor: not-allowed; box-shadow: none; transform: none;
        }
        button.secondary {
            flex: 1; padding: 11px 12px;
            border-radius: 999px; border: 1px solid var(--border); 
            background: transparent; color: var(--muted);
            font-size: 0.9rem; font-weight: 600; cursor: pointer;
            transition: all 0.2s ease;
        }
        button.secondary:hover { border-color: var(--text); color: var(--text); }
        .btn-pill {
            width: auto; padding: 6px 10px; font-size: 0.8rem;
            border-radius: 999px; background: #111827;
            border: 1px solid var(--border); color: var(--text); cursor: pointer;
        }
        .btn-pill:hover { border-color: var(--accent); color: var(--accent); }
        
        .output-area {
            display: none; margin-top: 16px; padding: 12px 12px 10px;
            border-radius: 12px; border: 1px dashed var(--border);
            background: #05070d; font-size: 0.86rem;
        }
        .output-header { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .output-header-icon {
            width: 20px; height: 20px; border-radius: 999px;
            display: inline-flex; align-items: center; justify-content: center;
            background: rgba(46, 160, 67, 0.15); color: var(--accent); font-size: 0.9rem;
        }
        .output-header strong { color: var(--accent); }
        .stat-line {
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 0.78rem; color: var(--muted);
        }
        .stat-line span.value { color: var(--text); }
        .output-actions { margin-top: 10px; }
        
        /* Footer */
        .footer {
            margin-top: 18px; padding-top: 12px; border-top: 1px solid var(--border);
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between;
        }
        .footer-text { font-size: 0.75rem; color: var(--muted); max-width: 480px; }
        .footer-note {
            font-size: 0.72rem; color: var(--muted); text-align: right;
            display: flex; flex-direction: column; gap: 2px;
        }
        .footer-note span { color: var(--text); font-weight: 600; }
        #statusMessage { margin-top: 8px; font-size: 0.8rem; font-weight: 500; display: none; }
        
        /* Bed Preview & Selection */
        .bed-preview-wrapper {
            display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; margin-top: 16px; margin-bottom: 10px;
        }
        .bed-preview {
            position: relative; width: 100%; max-width: 260px; height: 170px;
            border-radius: 10px; border: 1px solid var(--border);
            background-color: #111827;
            background-image: linear-gradient(#1f2933 1px, transparent 1px), linear-gradient(90deg, #1f2933 1px, transparent 1px);
            background-size: 20px 20px; overflow: hidden;
            transition: opacity 0.3s ease;
        }
        /* L√ÖST TILSTAND */
        .bed-preview.locked {
            pointer-events: none;
            opacity: 0.6; 
            cursor: default !important;
        }
        .bed-label {
            position: absolute; font-size: 0.7rem; font-weight: 600;
            color: #6b7280; text-transform: uppercase; pointer-events: none;
        }
        .bed-label-front { bottom: 4px; left: 50%; transform: translateX(-50%); }
        .bed-label-back { top: 4px; left: 50%; transform: translateX(-50%); }
        .bed-label-left { top: 50%; left: 4px; transform: translateY(-50%) rotate(-90deg); }
        .bed-label-right { top: 50%; right: 4px; transform: translateY(-50%) rotate(90deg); }
        
        .bed-zone {
            position: absolute; bottom: 18px; height: 40px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center;
            justify-content: center; font-size: 0.7rem; font-weight: 600; color: #e5e7eb;
            cursor: pointer;
            /* ENSARTET BREDDE */
            width: calc(33.333% - 4px);
        }
        /* ENSARTET PLACERING */
        .bed-zone.left { left: 4px; background: rgba(249,115,22,0.20); }
        .bed-zone.center { left: 50%; transform: translateX(-50%); background: rgba(59,130,246,0.20); }
        .bed-zone.right { right: 4px; background: rgba(16,185,129,0.20); }

        .bed-zone.active {
             border: 2px solid var(--accent); 
             box-shadow: 0 0 8px var(--accent);
             opacity: 1 !important;
        }
        .bed-preview-text { flex: 1; min-width: 200px; font-size: 0.78rem; color: var(--muted); }
        .bed-offset-line { margin-top: 6px; font-size: 0.78rem; }
        .offset-warning { margin-top: 4px; font-size: 0.75rem; color: var(--danger); }
        .direction-warning {
            margin-top: 8px; padding: 8px 10px; border-radius: 6px;
            background: rgba(248, 81, 73, 0.1); border: 1px solid var(--danger);
            font-size: 0.8rem; color: var(--danger); display: none;
        }
        .direction-info {
            margin-top: 8px; padding: 8px 10px; border-radius: 6px;
            background: rgba(46, 160, 67, 0.1); border: 1px solid var(--accent);
            font-size: 0.8rem; color: var(--accent); display: none;
        }
        
        /* Selection Toggle (Status Display) */
        .push-selector {
            display: flex; gap: 10px; margin: 15px 0; padding: 10px;
            background: var(--input); border-radius: 10px; border: 1px solid var(--border);
            pointer-events: none;
        }
        .push-option {
            flex: 1; text-align: center; 
            padding: 8px 5px; border-radius: 6px;
            font-size: 0.85rem; font-weight: 600; color: var(--muted);
            border: 1px solid transparent; transition: all 0.2s;
        }
        .push-option.active {
            background: rgba(46, 160, 67, 0.2); color: var(--accent);
            border-color: var(--accent);
        }
        .push-selector-label {
            display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
            font-size: 0.85rem; font-weight: 600;
        }
        
        /* Code Sections Logic */
        .code-section {
            margin-top: 12px; padding: 10px 10px 12px;
            border-radius: 10px; border: 1px solid var(--border); background: #05070d;
            transition: all 0.3s ease;
        }
        .code-section.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .code-section.active { border-color: var(--accent); box-shadow: 0 0 10px rgba(46, 160, 67, 0.1); }
        .code-header { display: flex; flex-direction: column; gap: 4px; margin-bottom: 6px; }
        .code-title { font-size: 0.9rem; font-weight: 600; }
        .code-desc { font-size: 0.78rem; color: var(--muted); margin: 0; }
        .code-actions { margin: 4px 0 6px; display: flex; justify-content: flex-end; gap: 8px; }
        .code-textarea {
            width: 100%; min-height: 220px; max-height: 400px; resize: vertical;
            padding: 8px; border-radius: 8px; border: 1px solid var(--border);
            background: #000; color: var(--text);
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 0.75rem; line-height: 1.3;
        }
        
        /* Debug status */
        #placementDebug {
            margin-top: 4px; padding-top: 8px; 
            border-top: 1px dashed var(--border);
        }
        #placementDebug p:first-child { margin-top: 0; }
        
        /* Drag & Drop */
        .file-upload-area {
            position: relative;
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            background: var(--input);
        }
        .file-upload-area.drag-over {
            border-color: var(--accent);
            background: rgba(46, 160, 67, 0.1);
        }
        .file-upload-area.drag-over::before {
            content: "üìÅ Drop file here";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: 600;
            pointer-events: none;
            z-index: 10;
        }
        .file-size-estimate {
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--muted);
            font-weight: 500;
        }
        .file-size-estimate strong {
            color: var(--accent);
        }
        
        /* Advanced Settings Toggle */
        .advanced-toggle-container {
            margin-top: 10px;
            padding: 10px;
            background: var(--input);
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .advanced-toggle-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0;
        }
        .advanced-toggle-container input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }
        #endCodeSection {
            display: none;
            margin-top: 0;
        }
        #endCodeSection.advanced-visible {
            display: block;
        }
        
        /* Loading indicator */
        .loading-container {
            display: none; margin-top: 10px;
        }
        .loading-container.active {
            display: block;
        }
        .progress-bar-container {
            background: var(--input); border-radius: 8px; height: 8px; overflow: hidden;
            margin-bottom: 4px;
        }
        .progress-bar {
            background: var(--accent); height: 100%; width: 0%; 
            transition: width 0.3s; border-radius: 8px;
        }
        .progress-text {
            font-size: 0.75rem; color: var(--muted); margin-top: 4px;
        }
        
        /* Bed preview locked indicator */
        .bed-preview.locked::after {
            content: "üîí Locked after file upload";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 10;
            border: 1px solid var(--border);
        }

        /* Instructions Modal */
        .instructions-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .instructions-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .instructions-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 24px;
            margin-top: 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
        }
        .instructions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .instructions-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--accent);
        }
        .instructions-close {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .instructions-close:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .instructions-section {
            margin-bottom: 24px;
        }
        .instructions-section h3 {
            color: var(--accent);
            font-size: 1.1rem;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }
        .instructions-section p {
            margin: 0 0 12px 0;
            line-height: 1.6;
            color: var(--text);
        }
        .instructions-section ul, .instructions-section ol {
            margin: 12px 0;
            padding-left: 24px;
            color: var(--text);
        }
        .instructions-section li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        .instructions-section strong {
            color: var(--accent);
        }
        .instructions-section code {
            background: var(--input);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: ui-monospace, monospace;
            font-size: 0.9em;
            color: var(--accent);
        }
        .instructions-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .instructions-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* --- DONATION BUTTON STYLES --- */
        .donation-container {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .donate-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--accent), var(--accent-soft));
            color: #06090f;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(46, 160, 67, 0.35);
        }

        .donate-btn:hover {
            filter: brightness(1.05);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(46, 160, 67, 0.45);
        }

        @media (max-width: 640px) {
            .header-row { flex-direction: column; align-items: flex-start; }
            .instructions-content {
                padding: 16px;
                margin-top: 20px;
                margin-bottom: 20px;
            }
            .lang-block { width: 100%; text-align: left; }
            .footer { flex-direction: column; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header-row">
        <div>
            <h1 data-lang="title">LOOPRINT (Beta)</h1>
            <p class="subtitle" data-lang="subtitle">
                Automated multi-loop G-code builder for Bambu Lab P1/P1S. Supports G-code and 3MF files.
            </p>
        </div>
        <button class="instructions-btn" onclick="openInstructions()" title="View instructions">
            üìñ Instructions
        </button>
    </div>
    
    <div class="section"> 
        <div class="section-title" data-lang="resourcesTitle">‚ö†Ô∏è Setup Required</div>
        <p class="help-text" data-lang="resourcesText">
            <strong>Looprint supports all file types:</strong> G-code files (directly from slicer) and 3MF files. Start and end code are added automatically.
        </p>
        <p class="help-text" style="font-size: 0.75rem; color: var(--muted); margin-top: 8px;">
            Logic based on <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: none;">Factorian Designs</a> G-code templates. I recommend watching his video about this.
        </p>
    </div>

    <div class="section">
        <div class="section-title" data-lang="step1Title">1. Upload File</div>
        <div class="file-upload-area" id="fileUploadArea">
            <input type="file" id="fileInput" accept=".gcode,.gco,.g,.txt,.3mf" onchange="validateFileImmediate()" style="display: none;">
            <label for="fileInput" style="display: inline-block; padding: 10px 20px; background: var(--accent); color: #06090f; border-radius: 8px; cursor: pointer; font-weight: 600; margin-bottom: 10px;">
                üìÅ Browse Files
            </label>
            <p style="margin: 8px 0 0; font-size: 0.85rem; color: var(--muted);">or drag and drop your G-code or 3MF file here</p>
        </div>
        <p id="fileSizeEstimate" class="file-size-estimate" style="display:none;"></p>
        <p class="help-text" style="margin-top: 10px;">
            <span data-lang="step1Help">Upload a G-code file (directly from slicer) or a 3MF file. Start and end code will be added automatically.</span>
        </p>

        <p id="fileValidationStatus" style="display:none; font-size:0.8rem; margin-top:6px; font-weight:600;"></p>
    </div>

    <div class="section">
        <div class="section-title" data-lang="step2Title">2. Loop Configuration</div>
        <div class="row">
            <div class="col">
                <label for="loopCount" data-lang="loopsLabel">Number of loops</label>
                <input type="number" id="loopCount" value="5" min="1" step="1" onchange="saveSettings()">
            </div>
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="skirtConfirmed">
            <label for="skirtConfirmed">
                <span data-lang="safetyText">I confirm this file was sliced with Brim enabled.</span>
            </label>
        </div>
        
        <div class="advanced-toggle-container">
            <label for="showAdvancedSettings">
                <input type="checkbox" id="showAdvancedSettings" onchange="toggleAdvancedSettings()">
                <span>‚öôÔ∏è Show Advanced Settings (Push-off Configuration)</span>
            </label>
        </div>
    </div>

    <div class="section" id="endCodeSection">
        <div class="section-title" data-lang="endSectionTitle">3. Push-off Configuration (Advanced)</div>
        <p class="help-text" data-lang="endSectionHelp">
            Push direction is automatically detected from your file. <strong>You can click the zones in the bed preview below to change it manually.</strong>
            <br><span style="font-size: 0.85em; color: var(--muted);">Note: In simple mode, push direction is locked to the auto-detected value. In advanced mode, you can change it but will see a warning if it differs from the auto-detected direction.</span>
        </p>
        
        <div class="row" style="margin-top: 15px;">
            <div class="col">
                <label for="cooldownTempInput" data-lang="cooldownTempLabel">Target Bed Temp (¬∞C)</label>
                <input type="number" id="cooldownTempInput" value="18" min="15" max="90" step="1" oninput="saveSettings(); checkCooldownWarning(); updateEndCodeTextareas();">
                <p id="cooldownWarningMessage" style="color:var(--danger); margin-top: 5px; font-size: 0.75rem; display: none; font-weight: 600;"></p>
                <p class="help-text" data-lang="cooldownHelp">Default 18¬∞C (Approx. 23¬∞C on the plate). Wait max 60 min.</p>
            </div>
            
            <div class="col">
                <label for="zOffsetInput" data-lang="zOffsetLabel">Z Push Offset (mm)</label>
                <input type="number" id="zOffsetInput" value="30" min="5" max="120" step="1" oninput="saveSettings(); applyOffset();">
                <p id="zOffsetStatus" style="font-size: 0.75rem; margin-top: 4px; display: none; font-weight: 600;"></p>
                <p class="help-text" data-lang="zOffsetHelp">Default 30mm below top.</p>
            </div>
        </div>
        
        <div class="row" style="margin-top: 15px;">
            <div class="col">
                <label for="pushLaneOffsetInput">Push Lane Offset (mm)</label>
                <input type="number" id="pushLaneOffsetInput" value="30" min="10" max="60" step="1" oninput="saveSettings(); updatePushLaneOffset();">
                <p id="pushLaneOffsetStatus" style="font-size: 0.75rem; margin-top: 4px; display: none; font-weight: 600;"></p>
                <p id="pushLaneOffsetMaxInfo" style="font-size: 0.75rem; margin-top: 4px; display: none; color: var(--muted);"></p>
                <p class="help-text">Distance from model center for left/right push lanes. Default 30mm. Auto-adjusted if too large for model placement.</p>
            </div>
        </div>

        <div class="bed-preview-wrapper">
            <div class="bed-preview" id="bedPreviewContainer">
                <div class="bed-label bed-label-front" data-lang="bedPreviewFront">FRONT</div>
                <div class="bed-label bed-label-back" data-lang="bedPreviewBack">BACK</div>
                <div class="bed-label bed-label-left" data-lang="bedPreviewLeft">LEFT</div>
                <div class="bed-label bed-label-right" data-lang="bedPreviewRight">RIGHT</div>
                <div class="bed-zone center" id="zone-center" onclick="selectDirection('center')"><span data-lang="bedZoneCenter">Center</span></div>
                <div class="bed-zone right" id="zone-right" onclick="selectDirection('right')"><span data-lang="bedZoneRight">Right</span></div>
                <div class="bed-zone left" id="zone-left" onclick="selectDirection('left')"><span data-lang="bedZoneLeft">Left</span></div>
            </div>
            <div class="bed-preview-text">
                <strong data-lang="bedPreviewTitle">Bed Preview & Model Placement</strong>
                <p class="help-text" data-lang="bedPreviewText">
                    The zone with the <strong style="color: var(--accent);">green border</strong> is the selected push direction.
                    <br><span style="font-size: 0.85em;">In advanced mode, you can click any zone to change it after file upload.</span>
                </p>
                <p class="bed-offset-line">
                    <span data-lang="bedPreviewOffsetLabel">Z push offset:</span>
                    <strong><span id="bedOffsetDisplay">30</span> mm</strong>
                    <span data-lang="bedPreviewOffsetSuffix">below top of print</span>
                </p>
                <p class="offset-warning" data-lang="zOffsetWarning">‚ö†Ô∏è Advanced: Incorrect values can cause collisions.</p>
                <div id="directionWarning" class="direction-warning">
                    ‚ö†Ô∏è <strong>Warning:</strong> You have changed the push direction from the automatically detected direction. Make sure this matches your model placement.
            </div>
                <div id="directionInfo" class="direction-info">
                    ‚ÑπÔ∏è <strong>Auto-detected:</strong> Push direction was automatically set based on model placement.
                </div>
            </div>
        </div>

        <div id="placementDebug" style="display:none; margin-top: 20px; padding-top: 15px; border-top: 1px dashed var(--border);">
             <p class="help-text" style="font-size: 0.75rem; color: var(--accent); font-weight: 600; margin: 0 0 4px;" data-lang="debugHeaderTitle">
                 üìç Model Placement Analysis:
             </p>
             <p style="margin: 0; font-size: 0.75rem; color: var(--muted); font-family: ui-monospace, SFMono-Regular, monospace;" id="debugOutputContent"></p>
        </div>

        <div id="block-start" class="code-section" style="margin-top: 20px;">
            <div class="code-header">
                <div class="code-title">Start G-code</div>
                <p class="code-desc">Start code that will be inserted at the beginning of each loop. Variables are replaced with values from your file.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('startCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="startCode" class="code-textarea" readonly></textarea>
        </div>

        <div class="push-selector-label" style="margin-top: 20px;">
            <span>üìç</span><span data-lang="selectDirectionLabel">Selected Push Direction:</span>
        </div>
        <div class="push-selector">
            <div class="push-option" id="opt-left" data-lang="optLeft">Left</div>
            <div class="push-option active" id="opt-center" data-lang="optCenter">Center</div>
            <div class="push-option" id="opt-right" data-lang="optRight">Right</div>
        </div>

        <div id="block-left" class="code-section disabled">
            <div class="code-header">
                <div class="code-title" data-lang="endLeftTitle">Left Push End G-code</div>
                <p class="code-desc" data-lang="endLeftDesc">Pushes model from left zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endLeftCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endLeftCode" class="code-textarea" readonly></textarea>
        </div>

        <div id="block-center" class="code-section active">
            <div class="code-header">
                <div class="code-title" data-lang="endCenterTitle">Center Push End G-code</div>
                <p class="code-desc" data-lang="endCenterDesc">Pushes model from center zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endCenterCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endCenterCode" class="code-textarea" readonly></textarea>
        </div>
        
        <div id="block-right" class="code-section disabled">
            <div class="code-header">
                <div class="code-title" data-lang="endRightTitle">Right Push End G-code</div>
                <p class="code-desc" data-lang="endRightDesc">Pushes model from right zone towards front. Z height calculated automatically.</p>
            </div>
            <div class="code-actions"><button type="button" class="btn-pill" onclick="copyCode('endRightCode')" data-lang="copyBtn">Copy G-code</button></div>
            <textarea id="endRightCode" class="code-textarea" readonly></textarea>
        </div>

    </div>

    <div class="btn-row">
        <button class="primary" id="generateBtn" onclick="processFiles()" data-lang="generateBtn">
            Generate Loop File
        </button>
        <button class="secondary" id="generateTestBtn" onclick="showTestFileInfo()" data-lang="generateTestBtn" style="display:none;" title="Generate a test file with only push-off sequence for testing">
            Generate Test File
        </button>
        <button class="secondary" onclick="resetDefaults()" data-lang="resetBtn">
            Reset to Defaults
        </button>
    </div>

    <p id="statusMessage"></p>
    
    <div id="loadingContainer" class="loading-container">
        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>
        <p id="progressText" class="progress-text">Processing...</p>
    </div>

    <div id="output" class="output-area">
        <div class="output-header">
            <div class="output-header-icon">‚úÖ</div>
            <strong data-lang="outputReady">Loop File Ready</strong>
        </div>
        <p data-lang="outputDesc">Your file has been looped into a single file with push-off sequences between each loop.</p>
        <p class="stat-line"><span data-lang="statLabelSource">Source file:</span> <span class="value" id="statSourceName">‚Äì</span></p>
        <p class="stat-line"><span data-lang="statLabelLoops">Total loops:</span> <span class="value" id="statLoops">0</span></p>
        <p class="stat-line" id="pushDirectionStatLine" style="display:none;">
            <span data-lang="statLabelPushDirection">Push direction:</span> 
            <span class="value" id="statPushDirection">‚Äì</span>
        </p>
        <p class="stat-line" id="filamentStatLine" style="display:none;">
            <span data-lang="statLabelFilament">Est. Filament usage:</span> 
            <span class="value" id="statFilament">0</span> <span class="value" id="statFilamentUnit">g</span>
        </p>
        <p class="stat-line" id="timeStatLine" style="display:none;">
            <span data-lang="statLabelTime">Est. Total Print Time:</span> 
            <span class="value" id="statTime">0</span>
            <span style="font-size: 0.75rem; color: var(--muted); margin-left: 6px;" data-lang="timeCooldownNote">(estimate calculated with 60min cooldown per loop)</span>
        </p>
        <p class="stat-line" id="fileSizeStatLine" style="display:none;">
            <span data-lang="statLabelFileSize">Est. File size:</span> 
            <span class="value" id="statFileSize">0</span>
        </p>
        <p class="stat-line" id="bedTempStatLine" style="display:none;">
            <span data-lang="statLabelBedTemp">Target Bed Temp:</span> 
            <span class="value" id="statBedTemp">‚Äì</span>
        </p>
        <p class="stat-line" id="pushOffsetStatLine" style="display:none;">
            <span data-lang="statLabelPushOffset">Z Push Offset:</span> 
            <span class="value" id="statPushOffset">‚Äì</span>
        </p>

        <div class="output-actions">
            <button class="primary" style="font-size:0.9rem; padding-inline:18px;" onclick="downloadFile()" id="downloadBtn" data-lang="downloadBtn">Download Looped File</button>
        </div>
    </div>

    <div class="donation-container">
        <p class="help-text" style="margin-bottom: 8px;">Find this tool useful? Support the project and keep Looprint updated:</p>
        <a href="https://buymeacoffee.com/nickiandersen" target="_blank" rel="noopener noreferrer" class="donate-btn">
            ‚òï Buy me a coffee
        </a>
    </div>

    <div class="footer">
        <div class="footer-text" data-lang="footerText" style="display: none;">
            <strong>‚ö†Ô∏è Safety reminder:</strong> Always test with a simple model first. Print from SD card.
        </div>
        <div class="footer-note" data-lang="footerNote">
            Looprint loops your file and adds push-off sequences between loops. All print settings (temperatures, speeds, etc.) come from your original file. Start and end code are added automatically for all file types (G-code and 3MF). Logic based on <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: none;">Factorian Designs</a> G-code templates. I recommend watching his video about this.
        </div>
        <p style="width: 100%; text-align: right; font-size: 0.75rem; color: var(--text); margin: 0; padding: 5px 0 0; font-weight: 600;">Nicki Andersen</p>
        <p style="width: 100%; text-align: right; font-size: 0.75rem; color: var(--muted); margin: 0; padding: 2px 0 0;">(v2.0 Beta - G-code Auto Start/End Code)</p>
    </div>
</div>

    <!-- Instructions Modal -->
    <div id="instructionsModal" class="instructions-modal" onclick="closeInstructionsOnBackdrop(event)">
        <div class="instructions-content" onclick="event.stopPropagation()">
            <div class="instructions-header">
                <h2>üìñ Looprint Instructions</h2>
                <button class="instructions-close" onclick="closeInstructions()">Close</button>
            </div>
            
            <div class="instructions-section">
                <h3>What is Looprint?</h3>
                <p>
                    Looprint is an automated multi-loop G-code builder for Bambu Lab P1/P1S printers. It takes your sliced G-code or 3MF file and automatically creates multiple print loops with push-off sequences between each loop, allowing you to print multiple copies of your model automatically.
                </p>
                <p>
                    <strong>Logic based on <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent);">Factorian Designs</a> G-code templates.</strong> I recommend watching his video about this.
                </p>
            </div>

            <div class="instructions-section">
                <h3>Supported File Types</h3>
                <ul>
                    <li><strong>G-code files</strong> - Export from Bambu Studio: File ‚Üí Export ‚Üí Export G-Code
                        <ul>
                            <li>Supported extensions: <code>.gcode</code>, <code>.gco</code>, <code>.g</code>, <code>.txt</code></li>
                            <li><strong>Must be printed from SD card (required)</strong></li>
                        </ul>
                    </li>
                    <li><strong>3MF files</strong> - Export from Bambu Studio: Dropdown (where "Print Plate" is) ‚Üí "Export plate sliced file"
                        <ul>
                            <li>Supported extension: <code>.3mf</code></li>
                            <li>Can be sent directly to the printer from Bambu Studio</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Start and end code are added automatically for all file types. You don't need any special printer profiles or modifications.
                </p>
                <p>
                    <strong>Note:</strong> Maximum file size: 150MB
                </p>
            </div>

            <div class="instructions-section">
                <h3>How to Use Looprint</h3>
                <ol>
                    <li>
                        <strong>Upload your file</strong>
                        <ul>
                            <li><strong>For 3MF files:</strong>
                                <ol>
                                    <li>Slice your model in Bambu Studio</li>
                                    <li>Click the dropdown where you normally click "Print Plate"</li>
                                    <li>Select "Export plate sliced file"</li>
                                    <li>Click "Choose File" or drag and drop the exported 3MF file to Looprint</li>
                                    <li>The file will be validated automatically</li>
                                    <li>After generating: Open the downloaded 3MF file in Bambu Studio and click "Print Plate" (do not slice again)</li>
                                </ol>
                            </li>
                            <li><strong>For G-code files:</strong>
                                <ol>
                                    <li>Slice your model in Bambu Studio</li>
                                    <li>Click "File" in the menu bar</li>
                                    <li>Select "Export" ‚Üí "Export G-Code"</li>
                                    <li>Click "Choose File" or drag and drop the exported G-code file to Looprint</li>
                                    <li>The file will be validated automatically</li>
                                    <li>After generating: Copy the downloaded G-code file to SD card and print from SD card (required)</li>
                                </ol>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>Configure loops</strong>
                        <ul>
                            <li>Set the number of loops (how many times to print your model)</li>
                            <li>Maximum: 1000 loops (recommended maximum: 50 loops to avoid memory issues)</li>
                            <li>The program will automatically detect your model's placement (Left, Center, or Right)</li>
                            <li>You can view the detected placement in the bed preview below</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Advanced settings (optional)</strong>
                        <ul>
                            <li>Click the checkbox "‚öôÔ∏è Show Advanced Settings" to access push-off configuration</li>
                            <li><strong>Target Bed Temp:</strong> Temperature to cool the bed to before push-off starts
                                <ul>
                                    <li>Default: 18¬∞C (Approx. 23¬∞C on the plate)</li>
                                    <li>Range: 15¬∞C - 90¬∞C</li>
                                    <li>Wait max 60 min for bed to cool before push-off sequence begins</li>
                                    <li>Warning shown if set above 35¬∞C (increases risk of sticking)</li>
                                </ul>
                            </li>
                            <li><strong>Z Push Offset:</strong> How far below the model top to push
                                <ul>
                                    <li>Default: 30mm</li>
                                    <li>Range: 5mm - 120mm</li>
                                </ul>
                            </li>
                            <li><strong>Push Lane Offset:</strong> Distance from model center for left/right push lanes
                                <ul>
                                    <li>Default: 30mm</li>
                                    <li>Range: 10mm - 60mm</li>
                                    <li>Automatically adjusted if too large for model placement (prevents crashes)</li>
                                    <li>Maximum possible offset is shown when auto-adjusted</li>
                                </ul>
                            </li>
                            <li><strong>Push Direction:</strong> Can be changed manually in advanced mode
                                <ul>
                                    <li>Click zones in the bed preview to change direction</li>
                                    <li>Warning shown if manually changed from auto-detected direction</li>
                                </ul>
                            </li>
                            <li><strong>Safety confirmation:</strong> Checkbox to confirm your model was sliced with Brim and placed at the edge of the bed (required before generating)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Generate and download</strong>
                        <ul>
                            <li>Click "Generate Loop File" to create the looped file</li>
                            <li>Or click "Generate Test File" (appears after file upload) to test just the push-off sequence</li>
                            <li>Wait for processing to complete (progress bar shows status)</li>
                            <li>Download your looped file</li>
                            <li>Use "Reset to Defaults" button to reset all settings to defaults</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="instructions-section">
                <h3>What Looprint Does</h3>
                <p>When you generate a looped file, Looprint:</p>
                <ol>
                    <li><strong>Analyzes your file</strong> - Detects model placement, dimensions, and print settings</li>
                    <li><strong>Removes original start/end code</strong> - Cleans up the slicer's start and end code</li>
                    <li><strong>Adds custom start code</strong> - Inserts optimized start code with proper temperature settings</li>
                    <li><strong>Loops the print</strong> - Repeats your print G-code for the specified number of loops</li>
                    <li><strong>Adds push-off sequences</strong> - Inserts automated push-off code between each loop to eject the finished print</li>
                    <li><strong>Adds custom end code</strong> - Inserts end code that cools the bed and prepares for the next loop</li>
                    <li><strong>Preserves all settings</strong> - All temperatures, speeds, and other settings from your original file are maintained</li>
                </ol>
            </div>

            <div class="instructions-section">
                <h3>Dynamic Multi-Lane Push System</h3>
                <p>
                    Looprint uses a dynamic push-off system that calculates three push lanes based on your model's position:
                </p>
                <ul>
                    <li><strong>Center lane:</strong> Pushes at the model's center (X = (minX + maxX) / 2)</li>
                    <li><strong>Left lane:</strong> Pushes at center - offset (default: 30mm to the left of center)</li>
                    <li><strong>Right lane:</strong> Pushes at center + offset (default: 30mm to the right of center)</li>
                </ul>
                <p>
                    This ensures stable ejection regardless of your model's shape. The offset is automatically adjusted if it would cause the printer to crash into the bed edges. A warning is displayed if auto-adjustment occurs, showing the maximum possible offset.
                </p>
                <p>
                    <strong>Safety Clear:</strong> After push-off, the hotend moves to a safe X position to avoid hitting the model on the next loop.
                </p>
            </div>

            <div class="instructions-section">
                <h3>Important Safety Reminders</h3>
                <ul>
                    <li><strong>Always test with a simple model first</strong> - Verify the push-off sequence works correctly</li>
                    <li><strong>Use Brim</strong> - Your model must be sliced with Brim enabled</li>
                    <li><strong>Place model at edge</strong> - Position your model at the edge of the bed for proper ejection</li>
                    <li><strong>G-code files:</strong> Must be printed from SD card (required)</li>
                    <li><strong>3MF files:</strong> After generating, open the downloaded 3MF file in Bambu Studio and click "Print Plate" (do not slice again)</li>
                    <li><strong>Monitor first print</strong> - Watch the first loop to ensure everything works as expected</li>
                </ul>
            </div>

            <div class="instructions-section">
                <h3>Tips & Best Practices</h3>
                <ul>
                    <li>Start with 2-3 loops to test before doing longer runs</li>
                    <li>Use the "Generate Test File" option to test just the push-off sequence</li>
                    <li>Keep your bed clean and properly leveled</li>
                    <li>Ensure your model has a good first layer adhesion</li>
                    <li>The cooldown temperature (default 18¬∞C) helps the finished print release from the bed so it can be pushed off</li>
                    <li>If prints stick and won't release, try lowering the cooldown temperature slightly</li>
                    <li>If prints release too easily or don't stick enough during printing, you may need to adjust the cooldown temperature</li>
                </ul>
            </div>

            <div class="instructions-section">
                <h3>Troubleshooting</h3>
                <ul>
                    <li><strong>File won't upload:</strong> Ensure it's a valid G-code (.gcode, .gco, .g, .txt) or 3MF (.3mf) file. Maximum file size: 150MB</li>
                    <li><strong>Wrong placement detected:</strong> Check that your model is clearly on one side of the bed. You can manually change push direction in advanced settings if needed</li>
                    <li><strong>Push-off doesn't work:</strong> Verify Brim is enabled and model is at bed edge. Use "Generate Test File" to test push-off sequence</li>
                    <li><strong>Temperature issues:</strong> All temperatures come from your original file - check your slicer settings. Start code automatically extracts and uses correct temperatures</li>
                    <li><strong>File too large:</strong> Maximum file size is 150MB. Large files may take longer to process - be patient. Progress bar shows processing status</li>
                    <li><strong>Too many loops warning:</strong> If you set more than 100 loops, you'll get a warning. Recommended maximum is 50 loops</li>
                    <li><strong>Push lane offset auto-adjusted:</strong> If you see a warning about offset being adjusted, the value was too large for your model placement. Check the displayed maximum value</li>
                    <li><strong>Cooldown temperature warning:</strong> If set above 35¬∞C, you'll see a warning about increased sticking risk</li>
                    <li><strong>Settings not saving:</strong> Settings are saved to browser localStorage. Clear browser data if you have issues</li>
                </ul>
            </div>

            <div class="instructions-section">
                <h3>Need Help?</h3>
                <p>
                    If you encounter issues or have questions, make sure you've watched the <a href="https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2" target="_blank" rel="noopener noreferrer" style="color: var(--accent);">Factorian Designs video</a> about the automation system that Looprint is based on.
                </p>
            </div>
    </div>
</div>

<script>
    // ===== CONSTANTS =====
    const COOLDOWN_WARNING_THRESHOLD = 35;
    const REQUIRED_SIGNATURE = "FactorianDesigns";
    const LOOPRINT_SIGNATURE = "Looprint Loop File"; 
    const END_CODE_START_MARKER = ";===== date:";
    // Regex pattern for finding G-code files in 3MF structure
    const GCODE_FILE_IN_3MF_REGEX = /^Metadata\/plate_\d+\.gcode$/i; 
    
    // Performance and processing constants
    const FILE_SIZE_OVERHEAD_FACTOR = 1.1; // 10% overhead for headers and end codes
    const CHUNKED_PROCESSING_DELAY_MS = 2; // Reduced from 10ms for better performance
    const MAX_Z_HEIGHT_MM = 1000; // Increased from 500mm for taller models
    const FILE_SIZE_ESTIMATE_3MF_OVERHEAD = 1.15; // 15% overhead for 3MF files (compression, headers)
    const MAX_PLACEMENT_PARSE_LINES = 100000; // Reduced from 500000 for better performance
    
    // Start code for 3MF files (inserted in each loop)
    const START_CODE_3MF = `;===== machine: P1S ======================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
;===== date: 20231107 =====================
;===== turn on the HB fan & MC board fan =================
M104 S75 ;set extruder temp to turn on the HB fan and prevent filament oozing from nozzle
M710 A1 S255 ;turn on MC fan by default(P1S)
;===== reset machine status =================
M290 X40 Y40 Z2.6666666
G91
M17 Z0.4 ; lower the z-motor current
G380 S2 Z30 F300 ; G380 is same as G38; lower the hotbed , to prevent the nozzle is below the hotbed
G380 S2 Z-25 F300 ;
G1 Z5 F300;
G90
M17 X1.2 Y1.2 Z0.75 ; reset motor current to default
M960 S5 P1 ; turn on logo lamp
G90
M220 S100 ;Reset Feedrate
M221 S100 ;Reset Flowrate
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 5
M221 X0 Y0 Z0 ; turn off soft endstop to prevent protential logic problem
G29.1 Z{+0.0} ; clear z-trim value first
M204 S10000 ; init ACC set to 10m/s^2

;===== heatbed preheat ====================
M1002 gcode_claim_action : 2
M140 S[bed_temperature_initial_layer_single] ;set bed temp
M190 S[bed_temperature_initial_layer_single] ;wait for bed temp



;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead

;===== prepare print temperature and material ==========
M104 S[nozzle_temperature_initial_layer] ;set extruder temp
G91
G0 Z10 F1200
G90
G28 X
M975 S1 ; turn on
G1 X60 F12000
G1 Y245
G1 Y265 F3000
M620 M
M620 S[initial_extruder]A   ; switch material if AMS exist
    M109 S[nozzle_temperature_initial_layer]
    G1 X120 F12000

    G1 X20 Y50 F12000
    G1 Y-3
    T[initial_extruder]
    G1 X54 F12000
    G1 Y265
    M400
M621 S[initial_extruder]A
M620.1 E F{filament_max_volumetric_speed[initial_extruder]/2.4053*60} T{nozzle_temperature_range_high[initial_extruder]}


M412 S1 ; ===turn on filament runout detection===

M109 S250 ;set nozzle to common flush temp
M106 P1 S0
G92 E0
G1 E50 F200
M400
M104 S[nozzle_temperature_initial_layer]
G92 E0
G1 E50 F200
M400
M106 P1 S255
G92 E0
G1 E5 F300
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20} ; drop nozzle temp, make filament shink a bit
G92 E0
G1 E-0.5 F300

G1 X70 F9000
G1 X76 F15000
G1 X65 F15000
G1 X76 F15000
G1 X65 F15000; shake to put down garbage
G1 X80 F6000
G1 X95 F15000
G1 X80 F15000
G1 X165 F15000; wipe and shake
M400
M106 P1 S0
;===== prepare print temperature and material end =====


;===== wipe nozzle ===============================
M1002 gcode_claim_action : 14
M975 S1
M106 S255
G1 X65 Y230 F18000
G1 Y264 F6000
M109 S{nozzle_temperature_initial_layer[initial_extruder]-20}
G1 X100 F18000 ; first wipe mouth

G0 X135 Y253 F20000  ; move to exposed steel surface edge
G28 Z P0 T300; home z with low precision,permit 300deg temperature
G29.2 S0 ; turn off ABL
G0 Z5 F20000

G1 X60 Y265
G92 E0
G1 E-0.5 F300 ; retrack more
G1 X100 F5000; second wipe mouth
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X100 F5000
G1 X70 F15000
G1 X90 F5000
G0 X128 Y261 Z-1.5 F20000  ; move to exposed steel surface and stop the nozzle
M104 S140 ; set temp down to heatbed acceptable
M106 S255 ; turn on fan (G28 has turn off fan)

M221 S; push soft endstop status
M221 Z0 ;turn off Z axis endstop
G0 Z0.5 F20000
G0 X125 Y259.5 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y262.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y260.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.5
G0 Z-1.01
G0 X131 F211
G0 X124
G0 Z0.5 F20000
G0 X125 Y261.0
G0 Z-1.01
G0 X131 F211
G0 X124
G0 X128
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300
G2 I0.5 J0 F300

M109 S140 ; wait nozzle temp down to heatbed acceptable
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000
G2 I0.5 J0 F3000

M221 R; pop softend status
G1 Z10 F1200
M400
G1 Z10
G1 F30000
G1 X230 Y15
G29.2 S1 ; turn on ABL
;G28 ; home again after hard wipe mouth
M106 S0 ; turn off fan , too noisy
;===== wipe nozzle end ================================


;===== bed leveling ==================================
;M1002 judge_flag g29_before_print_flag
;M622 J1
;
;    M1002 gcode_claim_action : 1
;    G29 A X{first_layer_print_min[0]} Y{first_layer_print_min[1]} I{first_layer_print_size[0]} J{first_layer_print_size[1]}
;    M400
;    M500 ; save cali data
;
;M623
G1 X128 Y128; move to the middle of the buildplate
G28 Z P1 T300; level clean nozzle 
																 
;===== bed leveling end ================================

;===== home after wipe mouth============================
M1002 judge_flag g29_before_print_flag
M622 J0

    M1002 gcode_claim_action : 13
    G28

M623
;===== home after wipe mouth end =======================

M975 S1 ; turn on vibration supression


;=============turn on fans to prevent PLA jamming=================
{if filament_type[initial_extruder]=="PLA"}
    {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)}
    M106 P3 S180
    {endif};Prevent PLA from jamming
{endif}
M106 P2 S100 ; turn on big fan ,to cool down toolhead


;M104 S{nozzle_temperature_initial_layer[initial_extruder]} ; set extrude temp earlier, to reduce wait time

;===== mech mode fast check============================
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q1 A7 B30 C80  H15 K0
;M974 Q1 S2 P0
;
;G1 X128 Y128 Z10 F20000
;M400 P200
;M970.3 Q0 A7 B30 C90 Q0 H15 K0
;M974 Q0 S2 P0
;
;M975 S1
;G1 F30000
;G1 X230 Y15
;G28 X ; re-home XY
;===== fmech mode fast check============================


;===== nozzle load line ===============================
M975 S1
G90
M83
T1000
;G1 X18.0 Y1.0 Z0.8 F18000;Move to start position
;M109 S{nozzle_temperature_initial_layer[initial_extruder]}
;G1 Z0.2
;G0 E2 F300
;G0 X240 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
;G0 Y11 E0.700 F{outer_wall_volumetric_speed/(0.3*0.5)/ 4 * 60}
;G0 X239.5
;G0 E0.2
;G0 Y1.5 E0.700
;G0 X18 E15 F{outer_wall_volumetric_speed/(0.3*0.5)     * 60}
M400

;===== for Textured PEI Plate , lower the nozzle as the nozzle was touching topmost of the texture when homing ==
;curr_bed_type={curr_bed_type}
{if curr_bed_type=="Textured PEI Plate"}
G29.1 Z{-0.07} ; for Textured PEI Plate
{endif}
;========turn off light and wait extrude temperature =============
M1002 gcode_claim_action : 0
M109 S{nozzle_temperature_initial_layer[initial_no_support_extruder]-20}; -20 ¬∞C so print already starts and nozzle doesn't ooze unnecessarily
M104 S[nozzle_temperature_initial_layer]  ; let it reach target temperatur while printing																																			   
M106 S0 ; turn off fan
M106 P2 S0 ; turn off big fan
M106 P3 S0 ; turn off chamber fan

M975 S1 ; turn on mech mode supression

; ================================== Start Code End ======================================`;
    
    // Bed boundaries (mm) - for placement detection
    const PUSH_LEFT_BOUNDARY = 90;
    const PUSH_RIGHT_BOUNDARY = 166;
    
    // Placement detection
    const MIN_POINTS_REQUIRED = 50;
    const MAX_DATA_POINTS = 10000;
    const MAX_LINES_TO_PARSE = MAX_PLACEMENT_PARSE_LINES; // Use constant
    const Z_FILTER_THRESHOLD = 4.0; // mm
    
    // Placement detection tolerance
    const PLACEMENT_TOLERANCE = 1.0; // mm
    
    // Bed boundaries for push-off (safe X positions)
    const BED_MIN_X = 10;                // Minimum safe X position (mm from left edge)
    const BED_MAX_X = 246;               // Maximum safe X position (mm from left edge, bed width ~256mm)
    
    // Default values
    const DEFAULT_LOOPS = 5;
    const DEFAULT_TEMP = 18;
    const DEFAULT_OFFSET = 30;
    const MIN_OFFSET = 5;
    const MAX_OFFSET = 120;
    const MIN_TEMP = 15;
    const MAX_TEMP = 90;
    const MAX_LOOPS = 1000;
    
    // Dynamic push lane offset settings
    const DEFAULT_PUSH_LANE_OFFSET = 30; // Default offset from model center (mm)
    const MIN_PUSH_LANE_OFFSET = 10;     // Minimum offset (safety margin from bed edges)
    const MAX_PUSH_LANE_OFFSET = 60;     // Maximum offset (prevents excessive values)
    
    // File size limits
    const MAX_FILE_SIZE = 150 * 1024 * 1024; // 150MB
    
    // Debug mode - set to false for production
    const DEBUG_MODE = false; // Set to true to enable console logging for debugging

    // Global: LOCKED TO ENGLISH
    let currentLang = "en";
    let finalFileContent = null; // Can be string (small files) or Blob (large files)
    let originalFilename = "";
    let currentOffset = 30;
    let currentFilamentUsage = "";
    let currentDirection = "center";
    let autoDetectedDirection = null; // Stores the automatically detected direction
    let lastValidationStatus = { key: null, color: null };
    let lastDebugData = null; 
    let currentFileType = "gcode"; // "gcode" or "3mf"
    
    // DOM element cache for performance (cached on page load)
    const DOM = {
        fileInput: null,
        generateBtn: null,
        generateTestBtn: null,
        loopCount: null,
        output: null,
        fileSizeEstimate: null,
        directionWarning: null,
        directionInfo: null,
        placementDebug: null,
        debugOutputContent: null,
        fileValidationStatus: null,
        zOffsetInput: null,
        bedOffsetDisplay: null,
        cooldownTempInput: null,
        showAdvancedSettings: null,
        // Will be initialized on page load
    }; 

    // formatString function removed - was never used

    const LANG = {
        en: { 
            title: "LOOPRINT (Beta)", subtitle: "Automated multi-loop G-code builder for Bambu Lab P1/P1S. Supports G-code and 3MF files.",
            step1Title: "1. Upload File",             step1Help: "Upload a G-code file (directly from slicer) or a 3MF file. Start and end code will be added automatically.",
            validationWarning: "‚úì Push direction is automatically detected from model placement.", validationError: "Validation failed: Could not read or parse the file. Please ensure it is a valid G-code or 3MF file.",
            validationErrorLooprint: "Validation failed: This file has already been processed by Looprint. Please upload the original sliced file.",
            validationErrorParse: "Validation failed: Could not read or parse the file content. Ensure it is a valid G-code or 3MF file.",
            validationSuccess: "File verified: Valid G-code or 3MF file detected. Start and end code will be added automatically.", step2Title: "2. Loop Configuration", loopsLabel: "Number of loops", safetyText: "I confirm this file was sliced with Brim enabled, and the model is placed at the edge of the bed.",
            safetyHelp: "", generateBtn: "Generate Loop File", generateTestBtn: "Generate Test File", resetBtn: "Reset to Defaults", 
            outputReady: "Loop File Ready", outputDesc: "Your file has been looped into a single file with push-off sequences between each loop.", statLabelSource: "Source file:", statLabelLoops: "Total loops:",
            statLabelFilament: "Est. Filament usage:", statLabelTime: "Est. Total Print Time:", timeCooldownNote: "(estimate calculated with 60min cooldown per loop)", statLabelFileSize: "Est. File size:", statLabelPushDirection: "Push direction:", statLabelBedTemp: "Target Bed Temp:", statLabelPushOffset: "Z Push Offset:", downloadBtn: "Download Looped File",             footerText: "<strong>‚ö†Ô∏è Safety reminder:</strong> Always test with a simple model first. Print from SD card.",
            footerText3MF: "<strong>‚ö†Ô∏è Safety reminder:</strong> Always test with a simple model first. 3MF files can be sent directly from Bambu Studio.",
            footerNote: "Looprint loops your file and adds push-off sequences between loops. All print settings (temperatures, speeds, etc.) come from your original file. Start and end code are added automatically for all file types (G-code and 3MF). Logic based on <a href=\"https://factoriandesigns.com/print-automation-bambu-lab-p1-x1-2\" target=\"_blank\" rel=\"noopener noreferrer\" style=\"color: var(--accent); text-decoration: none;\">Factorian Designs</a> G-code templates. I recommend watching his video about this.", resourcesTitle: "‚ö†Ô∏è Setup Required", resourcesText: "Looprint supports all file types: G-code files (directly from slicer) and 3MF files. Start and end code are added automatically.",
            resourcesLink: "", 
            endSectionTitle: "3. Push-off Configuration (Advanced)",
            endSectionHelp: "Push direction is automatically detected from your file. You can click the zones in the bed preview below to change it manually. Note: In simple mode, push direction is locked to the auto-detected value. In advanced mode, you can change it but will see a warning if it differs from the auto-detected direction.",
            cooldownTempLabel: "Target Bed Temp (¬∞C)", cooldownHelp: "Default 18¬∞C (Approx. 23¬∞C on the plate). Wait max 60 min.", cooldownRiskWarning: `Warning: Target > ${COOLDOWN_WARNING_THRESHOLD}¬∞C increases risk of sticking.`,
            zOffsetLabel: "Z Push Offset (mm)", zOffsetApply: "Apply", zOffsetHelp: "Default 30mm below top.", zOffsetWarning: "‚ö†Ô∏è Advanced: Incorrect values can cause collisions.",
            zOffsetErrorRange: "Offset must be between 5 mm and 120 mm.", zOffsetApplied: "Offset updated.", selectDirectionLabel: "Selected Push Direction:",
            optLeft: "Left", optCenter: "Center", optRight: "Right", endCenterTitle: "Center Push End G-code", endCenterDesc: "Pushes model from center zone towards front. Z height calculated automatically.",
            endRightTitle: "Right Push End G-code", endRightDesc: "Pushes model from right zone towards front. Z height calculated automatically.", endLeftTitle: "Left Push End G-code", endLeftDesc: "Pushes model from left zone towards front. Z height calculated automatically.",
            copyBtn: "Copy G-code", fileError: "Please select a G-code or 3MF file.", loopsError: "Please enter a valid loop count (at least 1).", loopsTooManyError: "Too many loops. Maximum recommended: 50. Large files may cause memory issues.", skirtError: "Safety check failed: You must confirm that Brim was enabled and the model is placed at the edge of the bed.",
            fileEmptyError: "The uploaded file appears to be empty or unreadable.", copySuccess: "Copied!", copyError: "Failed to copy.", bedPreviewTitle: "Bed Preview & Model Placement",
            bedPreviewText: "The zone with the green border is the selected push direction. In advanced mode, you can click any zone to change it after file upload.", bedPreviewFront: "FRONT", bedPreviewBack: "BACK", bedPreviewLeft: "LEFT", bedPreviewRight: "RIGHT",
            bedZoneCenter: "Center", bedZoneRight: "Right", bedZoneLeft: "Left", bedPreviewOffsetLabel: "Z push offset:", bedPreviewOffsetSuffix: "below top of print",
            debugHeaderTitle: "üìç Model Placement Analysis:",
            debugInfoTooFew: 'Too few G-code data points found (Need >50). Defaulted to Center.',
            debugInfoFiltered: 'All data points filtered out. Defaulted to Center.',
            debugInfoOverlap: 'Model width: %s. Overlap -> Left: %smm, Center: %smm, Right: %smm.',
            debugInfoWinner: 'Zone "%s" has the most model overlap. Selected.',
            zoneLeft: "Left", zoneCenter: "Center", zoneRight: "Right",
            debugInfoDedicatedRight: 'Model is fully located in the RIGHT zone (minX: %s > 166).',
            debugInfoDedicatedLeft: 'Model is fully located in the LEFT zone (maxX: %s < 90).',
            debugZoneSelection: 'Selected Zone:',
        }
    };

    /**
     * Applies English text to all elements with data-lang attribute
     */
    function applyEnglishText() {
        const dict = LANG.en;
        document.querySelectorAll("[data-lang]").forEach(el => {
            const key = el.getAttribute("data-lang");
            const value = dict[key] || key;
            // Special handling for footerNote to preserve HTML link
            if (key === "footerNote" && value.includes("<a ")) {
                el.innerHTML = value;
            } else {
                el.textContent = value;
            }
        });
    }
    
    /**
     * Toggles visibility of advanced settings section
     */
    function toggleAdvancedSettings() {
        const checkbox = document.getElementById("showAdvancedSettings");
        const advancedSection = document.getElementById("endCodeSection");
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const debugEl = document.getElementById("placementDebug");
        
        if (checkbox.checked) {
            advancedSection.classList.add("advanced-visible");
            // Update start code textarea
            // If file is uploaded, try to get G-code content from file input
            const fileInput = DOM.fileInput || document.getElementById("fileInput");
            if (fileInput.files.length > 0 && autoDetectedDirection !== null) {
                // File is uploaded - read it and update start code with variables
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    updateStartCodeTextarea(e.target.result);
                };
                reader.readAsText(file);
            } else {
                // No file uploaded - show template
                updateStartCodeTextarea(null);
            }
            // In advanced mode, unlock bed preview if file is uploaded (user can change it)
            // But keep it locked if we're in simple mode (auto-detected)
            if (autoDetectedDirection !== null) {
                // File is uploaded - unlock in advanced mode so user can change
                bedPreviewContainer.classList.remove('locked');
                updateDirectionInfo();
                // Show debug info if available
                if (lastDebugData) {
                    debugEl.style.display = "block";
                }
            }
        } else {
            advancedSection.classList.remove("advanced-visible");
            // In simple mode, always lock bed preview after file upload
            if (autoDetectedDirection !== null) {
                bedPreviewContainer.classList.add('locked');
            }
            // Hide warnings and debug when hiding advanced
            document.getElementById("directionWarning").style.display = "none";
            document.getElementById("directionInfo").style.display = "none";
            debugEl.style.display = "none";
        }
        
        // Save preference to localStorage
        try {
            localStorage.setItem('looprint_showAdvanced', checkbox.checked ? 'true' : 'false');
        } catch (e) {
            if (DEBUG_MODE) console.warn("Could not save advanced settings preference:", e);
        }
    }
    
    /**
     * Updates direction info/warning messages
     * Uses textContent/createElement to prevent XSS
     */
    function updateDirectionInfo() {
        const directionWarning = DOM.directionWarning || document.getElementById("directionWarning");
        const directionInfo = DOM.directionInfo || document.getElementById("directionInfo");
        
        if (autoDetectedDirection === null) {
            // No file uploaded yet
            directionWarning.style.display = "none";
            directionInfo.style.display = "none";
            return;
        }
        
        const isAdvanced = (DOM.showAdvancedSettings || document.getElementById("showAdvancedSettings")).checked;
        if (!isAdvanced) {
            directionWarning.style.display = "none";
            directionInfo.style.display = "none";
            return;
        }
        
        // Clear existing content
        directionWarning.textContent = '';
        directionInfo.textContent = '';
        
        if (currentDirection === autoDetectedDirection) {
            // Matches auto-detected
            directionWarning.style.display = "none";
            directionInfo.style.display = "block";
            
            // Use createElement for safe HTML insertion
            const icon = document.createTextNode("‚ÑπÔ∏è ");
            const strong = document.createElement("strong");
            strong.textContent = "Auto-detected: ";
            const text = document.createTextNode(`Push direction "${autoDetectedDirection}" was automatically set based on model placement.`);
            directionInfo.appendChild(icon);
            directionInfo.appendChild(strong);
            directionInfo.appendChild(text);
        } else {
            // Changed from auto-detected
            directionWarning.style.display = "block";
            directionInfo.style.display = "none";
            
            // Use createElement for safe HTML insertion
            const icon = document.createTextNode("‚ö†Ô∏è ");
            const strong = document.createElement("strong");
            strong.textContent = "Warning: ";
            const text = document.createTextNode(`Auto-detected direction was "${autoDetectedDirection}", but you've changed it to "${currentDirection}". Make sure this matches your model placement.`);
            directionWarning.appendChild(icon);
            directionWarning.appendChild(strong);
            directionWarning.appendChild(text);
        }
    }

    /**
     * Validates and sets input value from localStorage
     * @param {string} inputId - ID of input element
     * @param {string} savedValue - Value from localStorage
     * @param {number} min - Minimum allowed value
     * @param {number} max - Maximum allowed value
     * @param {number} defaultValue - Default value if validation fails
     * @returns {number} The validated value
     */
    function validateAndSetInput(inputId, savedValue, min, max, defaultValue) {
        const input = document.getElementById(inputId);
        if (!input) return defaultValue;
        
        const numValue = parseFloat(savedValue);
        if (!isNaN(numValue) && numValue >= min && numValue <= max) {
            input.value = numValue;
            return numValue;
        } else {
            input.value = defaultValue;
            return defaultValue;
        }
    }

    /**
     * Formats bytes to human readable size
     * @param {number} bytes - Size in bytes
     * @returns {string} Formatted size string
     */
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
    }
    
    /**
     * Updates file size estimate display
     * Uses safe DOM manipulation to prevent XSS
     */
    function updateFileSizeEstimate() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const estimateEl = document.getElementById("fileSizeEstimate");
        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
        const loopCount = parseInt(loopCountEl.value, 10) || DEFAULT_LOOPS;
        
        if (!fileInput.files.length) {
            estimateEl.style.display = "none";
            return;
        }
        
        const file = fileInput.files[0];
        const fileSize = file.size;
        const estimatedSize = fileSize * loopCount;
        
        // Add some overhead for headers and end codes
        const overheadFactor = currentFileType === "3mf" ? FILE_SIZE_ESTIMATE_3MF_OVERHEAD : FILE_SIZE_OVERHEAD_FACTOR;
        const estimatedWithOverhead = estimatedSize * overheadFactor;
        
        // Use textContent for safety (formatFileSize is safe, but avoid innerHTML)
        estimateEl.textContent = '';
        const strong = document.createElement("strong");
        strong.textContent = "Estimated output: ";
        const text = document.createTextNode(`~${formatFileSize(estimatedWithOverhead)} (${loopCount} loops √ó ${formatFileSize(fileSize)})`);
        estimateEl.appendChild(strong);
        estimateEl.appendChild(text);
        estimateEl.style.display = "block";
    }
    
    /**
     * Sets up drag and drop functionality for file upload
     * Handles dragenter, dragover, dragleave, and drop events
     */
    function setupDragAndDrop() {
        const uploadArea = document.getElementById("fileUploadArea");
        const fileInput = document.getElementById("fileInput");
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('drag-over');
            }, false);
        });
        
        uploadArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                fileInput.files = files;
                validateFileImmediate();
            }
        }, false);
    }

    /**
     * Initialize DOM cache for performance
     * Caches all frequently accessed DOM elements
     */
    function initDOMCache() {
        DOM.fileInput = document.getElementById("fileInput");
        DOM.generateBtn = document.getElementById("generateBtn");
        DOM.generateTestBtn = document.getElementById("generateTestBtn");
        DOM.loopCount = document.getElementById("loopCount");
        DOM.output = document.getElementById("output");
        DOM.fileSizeEstimate = document.getElementById("fileSizeEstimate");
        DOM.directionWarning = document.getElementById("directionWarning");
        DOM.directionInfo = document.getElementById("directionInfo");
        DOM.placementDebug = document.getElementById("placementDebug");
        DOM.debugOutputContent = document.getElementById("debugOutputContent");
        DOM.fileValidationStatus = document.getElementById("fileValidationStatus");
        DOM.zOffsetInput = document.getElementById("zOffsetInput");
        DOM.bedOffsetDisplay = document.getElementById("bedOffsetDisplay");
        DOM.cooldownTempInput = document.getElementById("cooldownTempInput");
        DOM.showAdvancedSettings = document.getElementById("showAdvancedSettings");
    }

    window.onload = function() {
        initDOMCache();
        // --- LOCKED TO ENGLISH ---
        applyEnglishText();
        // Footer text will be shown when a file is uploaded
        
        try {
            const savedLoops = localStorage.getItem('looprint_loops');
            const savedTemp = localStorage.getItem('looprint_temp');
            const savedOffset = localStorage.getItem('looprint_offset');
            const savedPushLaneOffset = localStorage.getItem('looprint_pushLaneOffset');

            // Validate and set values with proper bounds checking
            validateAndSetInput("loopCount", savedLoops, 1, MAX_LOOPS, DEFAULT_LOOPS);
            validateAndSetInput("cooldownTempInput", savedTemp, MIN_TEMP, MAX_TEMP, DEFAULT_TEMP);
            
            if (savedOffset) {
                const offset = parseFloat(savedOffset);
                if (!isNaN(offset) && offset >= MIN_OFFSET && offset <= MAX_OFFSET) {
                    document.getElementById("zOffsetInput").value = offset;
                    currentOffset = offset;
                    document.getElementById("bedOffsetDisplay").textContent = offset;
                } else {
                    // Reset to default if invalid
                    document.getElementById("zOffsetInput").value = DEFAULT_OFFSET;
                    currentOffset = DEFAULT_OFFSET;
                    document.getElementById("bedOffsetDisplay").textContent = DEFAULT_OFFSET;
                }
            }
            
            // Load push lane offset
            if (savedPushLaneOffset) {
                const pushLaneOffset = parseFloat(savedPushLaneOffset);
                if (!isNaN(pushLaneOffset) && pushLaneOffset >= MIN_PUSH_LANE_OFFSET && pushLaneOffset <= MAX_PUSH_LANE_OFFSET) {
                    const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                    if (pushLaneOffsetInput) {
                        pushLaneOffsetInput.value = pushLaneOffset;
                    }
                }
            }
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully - defaults will be used
            if (DEBUG_MODE) console.warn("Could not load settings from localStorage:", e);
        }

        setupDragAndDrop();
        updateEndCodeTextareas();
        updateStartCodeTextarea(null); // Show template on page load
        checkCooldownWarning();
        selectDirection('center', false);
            (DOM.generateBtn || document.getElementById("generateBtn")).disabled = true;
        document.getElementById("bedPreviewContainer").classList.remove('locked');
        autoDetectedDirection = null; // Reset on page load
        
        // Load advanced settings preference
        try {
            const showAdvanced = localStorage.getItem('looprint_showAdvanced');
            if (showAdvanced === 'true') {
                document.getElementById("showAdvancedSettings").checked = true;
                toggleAdvancedSettings();
            }
        } catch (e) {
            if (DEBUG_MODE) console.warn("Could not load advanced settings preference:", e);
        }
        
        // Update file size estimate when loop count changes
        document.getElementById("loopCount").addEventListener('input', updateFileSizeEstimate);
    };

    function updateValidationStatusText() {
        const statusEl = document.getElementById("fileValidationStatus");
        const dict = LANG.en;

        if (statusEl.style.display !== "none" && lastValidationStatus.key) {
            statusEl.textContent = dict[lastValidationStatus.key] || lastValidationStatus.key;
            statusEl.style.color = lastValidationStatus.color;
        }
    }

    /**
     * Renders debug text for model placement analysis
     * Uses safe DOM methods to prevent XSS
     */
    function renderDebugText() {
        if (!lastDebugData) return;
        
        const dict = LANG.en;
        const debugOutput = document.getElementById("debugOutputContent");
        
        // Clear existing content safely
        debugOutput.textContent = '';
        
        let minX = lastDebugData.minX.toFixed(1);
        let maxX = lastDebugData.maxX.toFixed(1);
        
        let headerLine = `Min X: ${minX}, Max X: ${maxX}`;

        if (lastDebugData.infoKey === 'debugInfoTooFew' || lastDebugData.infoKey === 'debugInfoFiltered') {
            // Simple case: just text
            const resultLine = dict[lastDebugData.infoKey] || lastDebugData.infoKey;
            debugOutput.textContent = `${headerLine}\n${resultLine}`;
        } else {
            // Complex case: need to show zone name with formatting
            let zoneKey = 'zone' + lastDebugData.direction.charAt(0).toUpperCase() + lastDebugData.direction.slice(1);
            let zoneNameTranslated = dict[zoneKey] || lastDebugData.direction;
            
            // Create elements safely to avoid XSS
            const headerText = document.createTextNode(headerLine);
            const br = document.createElement('br');
            const selectionText = document.createTextNode(dict.debugZoneSelection + ' ');
            const strong = document.createElement('strong');
            strong.textContent = zoneNameTranslated;
            
            debugOutput.appendChild(headerText);
            debugOutput.appendChild(br);
            debugOutput.appendChild(selectionText);
            debugOutput.appendChild(strong);
        }
    }

    /**
     * Saves current settings to localStorage
     */
    function saveSettings() {
        try {
            localStorage.setItem('looprint_loops', document.getElementById("loopCount").value);
            localStorage.setItem('looprint_temp', document.getElementById("cooldownTempInput").value);
            localStorage.setItem('looprint_offset', document.getElementById("zOffsetInput").value);
            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
            if (pushLaneOffsetInput) {
                localStorage.setItem('looprint_pushLaneOffset', pushLaneOffsetInput.value);
            }
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully - settings just won't persist
            if (DEBUG_MODE) console.warn("Could not save settings to localStorage:", e);
        }
    }
    
    /**
     * Selects push direction and updates UI accordingly
     * @param {string} dir - Direction: 'left', 'center', or 'right'
     * @param {boolean} updateCode - Whether to update end code textareas
     * @param {boolean} isAutoDetected - Whether this is from auto-detection
     */
    function selectDirection(dir, updateCode = true, isAutoDetected = false) {
        // Check if bed preview is locked (in simple mode after file upload)
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const isAdvanced = document.getElementById("showAdvancedSettings").checked;
        
        if (bedPreviewContainer.classList.contains('locked') && !isAdvanced && !isAutoDetected) {
            // In simple mode and locked - don't allow manual changes
            return;
        }
        
        currentDirection = dir;
        
        // Store auto-detected direction
        if (isAutoDetected) {
            autoDetectedDirection = dir;
        }
        
        document.querySelectorAll('.bed-zone').forEach(el => el.classList.remove('active'));
        document.getElementById('zone-' + dir).classList.add('active');

        document.querySelectorAll('.push-option').forEach(el => el.classList.remove('active'));
        document.getElementById('opt-' + dir).classList.add('active');
        
        const blocks = {
            left: document.getElementById('block-left'),
            center: document.getElementById('block-center'),
            right: document.getElementById('block-right')
        };
        
        Object.values(blocks).forEach(el => {
            el.classList.remove('active');
            el.classList.add('disabled');
        });
        
        if (blocks[dir]) {
            blocks[dir].classList.remove('disabled');
            blocks[dir].classList.add('active');
        }

        if (updateCode) {
            updateEndCodeTextareas();
        }
        
        // Update direction info/warning if in advanced mode
        if (isAdvanced) {
            updateDirectionInfo();
        }
    }
    
    /**
     * Parses time string (e.g., "2h 30m 15s") to total seconds
     * @param {string} timeStr - Time string to parse
     * @returns {number} Total seconds
     */
    function parseTimeStringToSeconds(timeStr) {
        let totalSeconds = 0;
        const dMatch = timeStr.match(/(\d+)d/);
        const hMatch = timeStr.match(/(\d+)h/);
        const mMatch = timeStr.match(/(\d+)m/);
        const sMatch = timeStr.match(/(\d+)s/);

        if (dMatch) totalSeconds += parseInt(dMatch[1]) * 86400;
        if (hMatch) totalSeconds += parseInt(hMatch[1]) * 3600;
        if (mMatch) totalSeconds += parseInt(mMatch[1]) * 60;
        if (sMatch) totalSeconds += parseInt(sMatch[1]);
        
        return totalSeconds;
    }

    /**
     * Formats total seconds to human-readable time string
     * @param {number} totalSeconds - Total seconds
     * @returns {string} Formatted time string (e.g., "2h 30m")
     */
    function formatSecondsToTime(totalSeconds) {
        const d = Math.floor(totalSeconds / 86400);
        totalSeconds %= 86400;
        const h = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        const m = Math.floor(totalSeconds / 60);
        const s = Math.round(totalSeconds % 60);

        let result = "";
        if (d > 0) result += `${d}d `;
        if (h > 0) result += `${h}h `;
        if (m > 0) result += `${m}m `;
        
        if (d === 0 && h === 0) {
            result += `${s}s`;
        } else if (result === "") {
             result += "0s";
        }

        return result.trim();
    }
    
    /**
     * Determines model placement on print bed based on G-code coordinates
     * Optimized for large files with line-by-line parsing
     * @param {string} gcode - The G-code file content
     * @returns {Object} Placement result with direction, coordinates, and debug info
     * @property {string} direction - 'left', 'center', or 'right'
     * @property {number} minX - Minimum X coordinate found
     * @property {number} maxX - Maximum X coordinate found
     * @property {string} infoKey - Debug information key for display
     */
    function determineModelPlacement(gcode) {
        const xCoords = [];
        
        // For store filer: Parse linje-for-linje i stedet for kompleks regex p√• hele filen
        // Optimized: Only parse first portion of file (model placement is typically early)
        try {
            const lines = gcode.split('\n');
            const MAX_LINES = Math.min(lines.length, MAX_PLACEMENT_PARSE_LINES);
            
            for (let i = 0; i < MAX_LINES; i++) {
                const line = lines[i].trim();
                
                // Hurtig check: Skip linjer der ikke starter med G0 eller G1
                if (!line.startsWith('G0') && !line.startsWith('G1')) continue;
                
                // Check om linjen har X, Y og E koordinater
                if (!line.includes('X') || !line.includes('Y') || !line.includes('E')) continue;
                
                // Parse koordinater
                const xMatch = line.match(/X([\d\.]+)/);
                if (!xMatch) continue;
                
                const zMatch = line.match(/Z([\d\.]+)/);
                const eMatch = line.match(/E([\d\.-]+)/); 

                const zValue = zMatch ? parseFloat(zMatch[1]) : 0;
                const eValue = eMatch ? parseFloat(eMatch[1]) : 0;

                // Vi inkluderer linjen, hvis:
                // 1. Z-h√∏jden er over threshold (langt over start purge)
                // 2. E-v√¶rdien er positiv (det er en reel ekstrudering/printlinje), uanset Z-h√∏jde
                if (zValue > Z_FILTER_THRESHOLD || eValue > 0) {
                    const xValue = parseFloat(xMatch[1]);
                    if (!isNaN(xValue)) {
                        xCoords.push(xValue);
                    }
                }
                
                // Stop tidligt hvis vi har nok data points
                if (xCoords.length > MAX_DATA_POINTS) break;
            }
        } catch (error) {
            // Don't use regex fallback on entire file - it's too slow for large files
            // Instead, return default center placement with error info
            if (DEBUG_MODE) console.warn("Line-by-line parsing failed:", error);
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
        } 

        if (xCoords.length < MIN_POINTS_REQUIRED) {
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoTooFew' }; 
        }

        const filteredCoords = xCoords.filter(x => x > BED_MIN_X && x < BED_MAX_X); 
        
        if (filteredCoords.length === 0) {
            return { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
        }

        // Use reducer for large arrays to avoid stack overflow
        const minX = filteredCoords.reduce((min, val) => val < min ? val : min, filteredCoords[0]);
        const maxX = filteredCoords.reduce((max, val) => val > max ? val : max, filteredCoords[0]);
        const totalWidth = maxX - minX;
        
        // 1. DEDIKERET H√òJRE PLACERING:
        if (minX > PUSH_RIGHT_BOUNDARY) {
            return { direction: 'right', minX: minX, maxX: maxX, infoKey: 'debugInfoDedicatedRight' };
        }
        
        // 2. DEDIKERET VENSTRE PLACERING:
        if (maxX < PUSH_LEFT_BOUNDARY) {
            return { direction: 'left', minX: minX, maxX: maxX, infoKey: 'debugInfoDedicatedLeft' };
        }
        
        // 3. OVERLAP / CENTER PLACERING:
        const widthLeft = Math.max(0, Math.min(maxX, PUSH_LEFT_BOUNDARY) - minX);
        const widthRight = Math.max(0, maxX - Math.max(minX, PUSH_RIGHT_BOUNDARY));
        const widthCenter = totalWidth - widthLeft - widthRight;

        let direction = 'center'; 
        let winnerText = 'Center';

        if (widthRight >= widthCenter - PLACEMENT_TOLERANCE && widthRight > widthLeft) {
            direction = 'right';
            winnerText = 'Right';
        } 
        else if (widthLeft >= widthCenter - PLACEMENT_TOLERANCE && widthLeft > widthRight) {
            direction = 'left';
            winnerText = 'Left';
        } 
        else if (widthLeft > widthCenter && widthLeft > widthRight) {
            direction = 'left';
            winnerText = 'Left';
        } else if (widthRight > widthCenter && widthRight > widthLeft) {
            direction = 'right';
            winnerText = 'Right';
        } else {
            direction = 'center';
            winnerText = 'Center';
        }

        return { 
            direction: direction, 
            minX: minX, 
            maxX: maxX,
            totalWidth: totalWidth,
            widthLeft: widthLeft,
            widthCenter: widthCenter,
            widthRight: widthRight,
            winnerText: winnerText,
            infoKey: 'debugInfoOverlap'
        };
    }
    // --- SLUT P√Ö determineModelPlacement() FUNKTION ---

    /**
     * Updates statistics display with file information
     * @param {string} content - G-code file content
     * @param {number} loopCount - Number of loops
     */
    function updateStatsDisplay(content, loopCount) {
        const loopValEl = document.getElementById("statLoops");
        const filamentStatLine = document.getElementById("filamentStatLine");
        const filamentValEl = document.getElementById("statFilament");
        const filamentUnitEl = document.getElementById("statFilamentUnit");
        const timeStatLine = document.getElementById("timeStatLine");
        const timeValEl = document.getElementById("statTime");
        const fileSizeStatLine = document.getElementById("fileSizeStatLine");
        const fileSizeValEl = document.getElementById("statFileSize");
        const pushDirectionStatLine = document.getElementById("pushDirectionStatLine");
        const pushDirectionValEl = document.getElementById("statPushDirection");
        const bedTempStatLine = document.getElementById("bedTempStatLine");
        const bedTempValEl = document.getElementById("statBedTemp");
        const pushOffsetStatLine = document.getElementById("pushOffsetStatLine");
        const pushOffsetValEl = document.getElementById("statPushOffset");

        loopValEl.textContent = loopCount.toString();
        loopValEl.style.color = "var(--accent)";
        loopValEl.style.fontWeight = "bold";
        
        // Display push direction
        const directionNames = { left: "Left", center: "Center", right: "Right" };
        const directionName = directionNames[currentDirection] || currentDirection;
        pushDirectionValEl.textContent = directionName;
        pushDirectionStatLine.style.display = "block";
        pushDirectionValEl.style.color = "var(--accent)";
        pushDirectionValEl.style.fontWeight = "bold";
        
        // Display bed temp
        const cooldownTempInput = DOM.cooldownTempInput || document.getElementById("cooldownTempInput");
        if (cooldownTempInput) {
            const bedTemp = cooldownTempInput.value || "18";
            bedTempValEl.textContent = bedTemp + "¬∞C";
            bedTempStatLine.style.display = "block";
            bedTempValEl.style.color = "var(--accent)";
            bedTempValEl.style.fontWeight = "bold";
        } else {
            bedTempStatLine.style.display = "none";
        }
        
        // Display push offset
        const bedOffsetDisplay = DOM.bedOffsetDisplay || document.getElementById("bedOffsetDisplay");
        if (bedOffsetDisplay) {
            const pushOffset = bedOffsetDisplay.textContent || currentOffset || "30";
            pushOffsetValEl.textContent = pushOffset + " mm";
            pushOffsetStatLine.style.display = "block";
            pushOffsetValEl.style.color = "var(--accent)";
            pushOffsetValEl.style.fontWeight = "bold";
        } else {
            pushOffsetStatLine.style.display = "none";
        }
        
        // Calculate and display estimated file size
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (fileInput.files.length > 0) {
            const fileSize = fileInput.files[0].size;
            const estimatedSize = fileSize * loopCount * 1.1; // Add 10% overhead
            fileSizeValEl.textContent = formatFileSize(estimatedSize);
            fileSizeStatLine.style.display = "block";
            fileSizeValEl.style.color = "var(--accent)";
            fileSizeValEl.style.fontWeight = "bold";
        } else {
            fileSizeStatLine.style.display = "none";
        }

        let singleUsage = 0;
        const filamentMatch = content.match(/;\s*total\s+filament\s+(?:used|weight)\s+\[g\]\s*[:=]\s*([\d\.]+)/i);
        if (filamentMatch && filamentMatch[1]) {
            singleUsage = parseFloat(filamentMatch[1]);
        }

        if (singleUsage > 0) {
            const totalUsage = (singleUsage * loopCount).toFixed(1);
            filamentValEl.textContent = totalUsage;
            filamentStatLine.style.display = "block";
            currentFilamentUsage = totalUsage;
            filamentValEl.style.color = "var(--accent)";
            filamentValEl.style.fontWeight = "bold"; 
            filamentUnitEl.style.color = "var(--accent)";
            filamentUnitEl.style.fontWeight = "bold"; 
        } else {
            filamentValEl.textContent = "0.0";
            filamentStatLine.style.display = "none";
            currentFilamentUsage = "";
        }

        const timeMatch = content.match(/;\s*(?:estimated|model)\s+printing\s+time.*[:=]\s*(.+)/i);
        
        if (timeMatch && timeMatch[1]) {
            const singleTimeStr = timeMatch[1].trim();
            const singleSeconds = parseTimeStringToSeconds(singleTimeStr);
            
            if (singleSeconds > 0) {
                // Calculate total print time: (single print time * loops) + (cooldown time * (loops - 1))
                // Cooldown is 60 minutes (3600 seconds) between each loop (conservative estimate)
                const COOLDOWN_SECONDS = 60 * 60; // 60 minutes in seconds
                const totalSeconds = (singleSeconds * loopCount) + (COOLDOWN_SECONDS * (loopCount - 1));
                const formattedTotalTime = formatSecondsToTime(totalSeconds);
                
                timeValEl.textContent = formattedTotalTime;
                timeStatLine.style.display = "block";
                timeValEl.style.color = "var(--accent)";
                timeValEl.style.fontWeight = "bold";
            } else {
                timeValEl.textContent = "0s";
                timeStatLine.style.display = "none";
            }
        } else {
            timeValEl.textContent = "0s";
            timeStatLine.style.display = "none";
        }
        
        document.getElementById("output").style.display = "block";
    }

    /**
     * Updates footer text based on file type
     * @param {boolean} is3MF - Whether the current file is a 3MF file
     */
    function updateFooterText(is3MF) {
        const footerTextEl = document.querySelector('.footer-text[data-lang="footerText"]');
        if (footerTextEl) {
            const dict = LANG.en;
            const text = is3MF ? dict.footerText3MF : dict.footerText;
            
            // Clear existing content safely
            footerTextEl.textContent = '';
            
            // Parse text to preserve <strong> tag structure safely
            // Text format: "<strong>‚ö†Ô∏è Safety reminder:</strong> Always test..."
            const strongMatch = text.match(/^<strong>(.*?)<\/strong>(.*)$/);
            if (strongMatch) {
                const strongText = strongMatch[1];
                const restText = strongMatch[2];
                
                const strong = document.createElement('strong');
                strong.textContent = strongText;
                
                footerTextEl.appendChild(strong);
                footerTextEl.appendChild(document.createTextNode(restText));
            } else {
                // No <strong> tag, just use textContent
                footerTextEl.textContent = text;
            }
            
            // Show footer text when file is uploaded
            footerTextEl.style.display = "block";
        }
    }

    function validateFileImmediate() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const statusEl = document.getElementById("fileValidationStatus");
        const debugEl = document.getElementById("placementDebug");
        const debugOutput = document.getElementById("debugOutputContent");
        const genBtn = DOM.generateBtn || document.getElementById("generateBtn");
        const outputEl = DOM.output || document.getElementById("output");
        const bedPreviewContainer = document.getElementById("bedPreviewContainer");
        const dict = LANG.en;
        
        lastValidationStatus = { key: null, color: null };
        lastDebugData = null; 

        if (!fileInput.files.length) {
            statusEl.style.display = "none";
            debugEl.style.display = "none";
            genBtn.disabled = true;
            const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
            if (testBtn) {
                testBtn.style.display = "none";
            }
            outputEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
            updateFileSizeEstimate(); // Hide estimate
            autoDetectedDirection = null; // Reset auto-detected direction
            document.getElementById("directionWarning").style.display = "none";
            document.getElementById("directionInfo").style.display = "none";
            // Hide footer text when no file is selected
            const footerTextEl = document.querySelector('.footer-text[data-lang="footerText"]');
            if (footerTextEl) {
                footerTextEl.style.display = "none";
            }
            return;
        }
        
        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        // Check file size
        if (file.size > MAX_FILE_SIZE) {
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(1);
            const maxSizeMB = (MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
            statusEl.textContent = `File too large (${fileSizeMB}MB). Maximum: ${maxSizeMB}MB`;
            statusEl.style.color = "var(--danger)";
            statusEl.style.display = "block";
            genBtn.disabled = true;
            outputEl.style.display = "none";
            debugEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
            return;
        }
        
        genBtn.disabled = true; 
        outputEl.style.display = "none";
        statusEl.style.display = "none";
        debugEl.style.display = "none";
        debugOutput.textContent = ''; 
        bedPreviewContainer.classList.remove('locked');

        document.getElementById("statSourceName").textContent = file.name; 
        
        // Handle 3MF files differently
        if (is3MF) {
            // For 3MF files, validate by trying to unzip and find G-code
            updateProgress(10, "Validating 3MF file...");
            
            // Check if JSZip is available
            if (typeof JSZip === 'undefined') {
                statusEl.textContent = "Error: JSZip library not loaded. Please refresh the page.";
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
                genBtn.disabled = true;
                return;
            }
            
            // Validate 3MF file structure
            file.arrayBuffer().then(async (arrayBuffer) => {
                try {
                    updateProgress(30, "Checking 3MF structure...");
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    
                    // Find G-code file
                    const gcodeFiles = [];
                    zip.forEach((relativePath) => {
                        if (relativePath.match(GCODE_FILE_IN_3MF_REGEX)) {
                            gcodeFiles.push(relativePath);
                        }
                    });
                    
                    if (gcodeFiles.length === 0) {
                        statusEl.textContent = "Error: No G-code file found in 3MF. Expected: Metadata/plate_*.gcode";
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        return;
                    }
                    
                    // Try to read and validate G-code content
                    updateProgress(50, "Validating G-code in 3MF...");
                    const gcodePath = gcodeFiles[0];
                    const gcodeContent = await zip.file(gcodePath).async('string');
                    
                    // Check for Looprint signature (should not be present - file already processed)
                    // Check for both the signature and "Generated by Looprint" watermark
                    const hasLooprint = gcodeContent.indexOf(LOOPRINT_SIGNATURE) !== -1 || 
                                       gcodeContent.indexOf("Generated by Looprint") !== -1 ||
                                       gcodeContent.indexOf("Contact: Nicki.Andersen@gmail.com") !== -1;
                    
                    if (hasLooprint) {
                        statusEl.textContent = dict.validationErrorLooprint;
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        updateProgress(0);
                        return;
                    }
                    
                    // For 3MF files, we don't require FactorianDesigns signature because:
                    // - Start/end G-code is in the printer profile, not in the G-code file
                    // - The signature will be added when we generate the looped file
                    // Instead, validate that it's a valid G-code file with max_z_height
                    const hasMaxZHeight = /;\s*max_z_height\s*[:=]\s*[\d\.]+/i.test(gcodeContent);
                    
                    if (!hasMaxZHeight) {
                        statusEl.textContent = "Error: G-code file in 3MF does not contain max_z_height. Please ensure the file was sliced correctly.";
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                        genBtn.disabled = true;
                        return;
                    }
                    
                    // Valid 3MF file - now detect model placement
                    updateProgress(70, "Detecting model placement...");
                    try {
                        const placementResult = determineModelPlacement(gcodeContent);
                        autoDetectedDirection = placementResult.direction;
                        currentDirection = placementResult.direction;
                        lastDebugData = placementResult;
                        
                        // Update UI with detected placement
                        selectDirection(placementResult.direction, true, true);
                        
                        // Update push lane offset display with maximum possible offset
                        // Only if advanced settings are visible (input element exists)
                        try {
                            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                            if (pushLaneOffsetInput) {
                                updatePushLaneOffset();
                            }
                        } catch (offsetError) {
                            // Don't let offset update error prevent file upload
                            if (DEBUG_MODE) console.warn("Error updating push lane offset:", offsetError);
                        }
                        
                        // Show debug info if advanced settings are enabled
                        const isAdvanced = (DOM.showAdvancedSettings || document.getElementById("showAdvancedSettings")).checked;
                        if (isAdvanced) {
                            renderDebugText();
                            debugEl.style.display = "block";
                        } else {
                            debugEl.style.display = "none";
                        }
                        
                        // Lock bed preview in simple mode, unlock in advanced mode
                        if (isAdvanced) {
                            bedPreviewContainer.classList.remove('locked');
                        } else {
                            bedPreviewContainer.classList.add('locked');
                        }
                        
                        // Show test file button (works for 3MF too now that we have G-code content)
                        const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
                        if (testBtn) {
                            testBtn.style.display = "inline-block";
                        }
                    } catch (placementError) {
                        if (DEBUG_MODE) console.error("Error in determineModelPlacement for 3MF:", placementError);
                        // Default to center if placement detection fails
                        autoDetectedDirection = 'center';
                        currentDirection = 'center';
                        placementResult = { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
                        selectDirection('center', true, true);
                    }
                    
                    statusEl.textContent = "File verified: Valid 3MF file detected. Start and end code will be added automatically.";
                    statusEl.style.color = "var(--accent)";
                    statusEl.style.display = "block";
                    genBtn.disabled = false;
                    
                    // Update stats display (same as for G-code files)
                    const loopsForDisplay = parseInt(document.getElementById("loopCount").value, 10) || DEFAULT_LOOPS;
                    updateStatsDisplay(gcodeContent, loopsForDisplay);
                    
                    // Update file size estimate after validation
                    updateFileSizeEstimate();
                    
                    // Show output area
                    outputEl.style.display = "block";
                    
                    // Update footer text for 3MF files
                    updateFooterText(true);
                    
                    // Update start code textarea with variable replacement
                    updateStartCodeTextarea(gcodeContent);
                    
                    updateProgress(0);
                } catch (error) {
                    setLoadingState(false);
                    statusEl.textContent = `Error validating 3MF file: ${error.message || "Invalid 3MF structure"}`;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                    genBtn.disabled = true;
                    updateProgress(0);
                }
            }).catch((error) => {
                setLoadingState(false);
                statusEl.textContent = `Error reading 3MF file: ${error.message || "Could not read file"}`;
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
                genBtn.disabled = true;
                updateProgress(0);
            });
            
            return; // Exit early for 3MF files
        }
        
        // Handle G-code files (existing logic)
        const reader = new FileReader();
        
        // Show progress during file read
        updateProgress(10, "Reading file..."); 

        reader.onload = function(e) {
            try {
                updateProgress(30, "Validating file...");
                const content = e.target.result;
                
                // Check for tom fil
                if (!content || content.length === 0) {
                    throw new Error("File is empty");
                }
                
                let validationKey = null;
                let validationColor = null;

                // Check if already processed by Looprint
                // Check for both the signature and watermarks to ensure file hasn't been looped
                const hasLooprint = content.indexOf(LOOPRINT_SIGNATURE) !== -1 ||
                                   content.indexOf("Generated by Looprint") !== -1 ||
                                   content.indexOf("Contact: Nicki.Andersen@gmail.com") !== -1;

                if (hasLooprint) {
                    validationKey = "validationErrorLooprint";
                    validationColor = "var(--danger)";
                    bedPreviewContainer.classList.remove('locked');
                } else {
                    // G-code file is valid (no longer require Factorian signature - start/end code will be added automatically)
                    validationKey = "validationSuccess";
                    validationColor = "var(--accent)";
                    
                    updateProgress(60, "Analyzing model placement...");
                    
                    // Wrap placement detection in try-catch for better error handling
                    let placementResult;
                    try {
                        placementResult = determineModelPlacement(content);
                    } catch (placementError) {
                        if (DEBUG_MODE) console.error("Error in determineModelPlacement:", placementError);
                        // Fallback to center if placement detection fails
                        placementResult = { direction: 'center', minX: 0, maxX: 256, infoKey: 'debugInfoFiltered' };
                    }
                    
                    updateProgress(90, "Finalizing...");
                    
                    // Set direction with auto-detected flag
                    selectDirection(placementResult.direction, true, true);
                    
                    // Update push lane offset display with maximum possible offset
                    // Only if advanced settings are visible (input element exists)
                    try {
                        const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
                        if (pushLaneOffsetInput) {
                            updatePushLaneOffset();
                        }
                    } catch (offsetError) {
                        // Don't let offset update error prevent file upload
                        if (DEBUG_MODE) console.warn("Error updating push lane offset:", offsetError);
                    }
                    
                    genBtn.disabled = false;
                    
                    // Show test file button when file is validated
                    const testBtn = DOM.generateTestBtn || document.getElementById("generateTestBtn");
                    if (testBtn) {
                        testBtn.style.display = "inline-block";
                    }
                    
                    const loopsForDisplay = parseInt(document.getElementById("loopCount").value, 10) || DEFAULT_LOOPS; 
                    updateStatsDisplay(content, loopsForDisplay);
                    
                    lastDebugData = placementResult;
                    renderDebugText();

                    // Update file size estimate after validation
                    updateFileSizeEstimate();

                    outputEl.style.display = "block";
                    
                    // Show debug only if advanced settings are enabled
                    const isAdvanced = document.getElementById("showAdvancedSettings").checked;
                    if (isAdvanced) {
                        debugEl.style.display = "block";
                    } else {
                        debugEl.style.display = "none";
                    }
                    
                    // Update footer text for G-code files
                    updateFooterText(false);
                    
                    // Update start code textarea with variable replacement
                    updateStartCodeTextarea(content);
                    
                    // Lock bed preview based on advanced mode
                    if (!isAdvanced) {
                        // Simple mode: always lock after file upload
                    bedPreviewContainer.classList.add('locked');
                    } else {
                        // Advanced mode: unlock so user can change
                        bedPreviewContainer.classList.remove('locked');
                        updateDirectionInfo();
                    }
                    
                    updateProgress(100, "Ready!");
                    setTimeout(() => updateProgress(0), 500);
                }

                if (validationKey) {
                    lastValidationStatus = { key: validationKey, color: validationColor };
                    statusEl.textContent = dict[validationKey] || validationKey;
                    statusEl.style.color = validationColor;
                    statusEl.style.display = "block";

                    if (validationColor === "var(--danger)") {
                        genBtn.disabled = true;
                        outputEl.style.display = "none";
                        debugEl.style.display = "none";
                        bedPreviewContainer.classList.remove('locked');
                    }
                }
                
            } catch (error) {
                const validationKey = "validationErrorParse";
                const validationColor = "var(--danger)";
                lastValidationStatus = { key: validationKey, color: validationColor };

                statusEl.textContent = dict[validationKey] || validationKey;
                statusEl.style.color = validationColor;
                statusEl.style.display = "block";
                genBtn.disabled = true;
                outputEl.style.display = "none";
                debugEl.style.display = "none";
                bedPreviewContainer.classList.remove('locked');
                if (DEBUG_MODE) console.error("Critical error during file validation:", error);
            }
        };
        
        reader.onerror = function() {
            const validationKey = "validationErrorParse";
            const validationColor = "var(--danger)";
            lastValidationStatus = { key: validationKey, color: validationColor };
            
            statusEl.textContent = dict[validationKey] || validationKey;
            statusEl.style.color = validationColor;
            statusEl.style.display = "block";
            genBtn.disabled = true;
            outputEl.style.display = "none";
            debugEl.style.display = "none";
            bedPreviewContainer.classList.remove('locked');
        };
        
        reader.readAsText(file);
    }
    
    /**
     * Resets all settings to default values
     */
    function resetDefaults() {
        const defaultLoops = DEFAULT_LOOPS;
        const defaultTemp = DEFAULT_TEMP; 
        const defaultOffset = DEFAULT_OFFSET;
        const defaultPushLaneOffset = DEFAULT_PUSH_LANE_OFFSET;
        
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");

        loopCountEl.value = defaultLoops;
        document.getElementById("cooldownTempInput").value = defaultTemp;
        document.getElementById("zOffsetInput").value = defaultOffset;
        document.getElementById("skirtConfirmed").checked = false;
        
        // Reset Push Lane Offset to default
        const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
        if (pushLaneOffsetInput) {
            pushLaneOffsetInput.value = defaultPushLaneOffset;
        }
        
        document.getElementById("bedPreviewContainer").classList.remove('locked');

        currentOffset = defaultOffset;
        document.getElementById("bedOffsetDisplay").textContent = defaultOffset;
        
        try {
            localStorage.removeItem('looprint_loops');
            localStorage.removeItem('looprint_temp');
            localStorage.removeItem('looprint_offset');
            localStorage.removeItem('looprint_pushLaneOffset');
        } catch (e) {
            // localStorage might not be available (e.g., private browsing mode)
            // This is handled gracefully
            if (DEBUG_MODE) console.warn("Could not clear settings from localStorage:", e);
        }
        
        checkCooldownWarning();
        updatePushLaneOffset(); // Update push lane offset display
        updateEndCodeTextareas();
        
        if (fileInput.files.length > 0) {
            validateFileImmediate(); 
        } else {
            selectDirection('center', false);
            document.getElementById("output").style.display = "none";
            document.getElementById("placementDebug").style.display = "none"; 
            document.getElementById("fileValidationStatus").style.display = "none";
            (DOM.generateBtn || document.getElementById("generateBtn")).disabled = true; 
        }
        
        clearStatus();
        document.getElementById("zOffsetStatus").style.display = "none";
        document.getElementById("pushLaneOffsetStatus").style.display = "none";
        document.getElementById("pushLaneOffsetMaxInfo").style.display = "none";
        autoDetectedDirection = null; // Reset auto-detected direction
        document.getElementById("directionWarning").style.display = "none";
        document.getElementById("directionInfo").style.display = "none";
        currentFileType = "gcode"; // Reset file type
    }

    /**
     * Processes the uploaded file (G-code or 3MF) and generates looped version
     * Includes progress tracking and error handling
     */
    async function processFiles() {
        clearStatus();
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) { showStatus("fileError", "error"); return; }

        const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
        const loops = parseInt(loopCountEl.value, 10);
        if (isNaN(loops) || loops < 1) { 
            showStatus("loopsError", "error"); 
            return; 
        }
        
        // Warn about very high loop counts
        if (loops > 100) {
            if (!confirm(`Warning: ${loops} loops is a very high number. This may cause memory issues or browser crashes.\n\nRecommended maximum: 50 loops.\n\nContinue anyway?`)) {
                return;
            }
        }
        
        if (loops > MAX_LOOPS) {
            showStatus("loopsTooManyError", "error");
            return;
        }

        if (!document.getElementById("skirtConfirmed").checked) { showStatus("skirtError", "error"); return; }

        const file = fileInput.files[0];
        
        // Detect file type
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        // Estimate final file size and warn if too large
        const estimatedFinalSize = file.size * loops;
        const MAX_ESTIMATED_SIZE = 500 * 1024 * 1024; // 500MB
        
        if (estimatedFinalSize > MAX_ESTIMATED_SIZE) {
            const estimatedMB = (estimatedFinalSize / 1024 / 1024).toFixed(1);
            const maxMB = (MAX_ESTIMATED_SIZE / 1024 / 1024).toFixed(0);
            if (!confirm(`Warning: Estimated file size will be ${estimatedMB}MB (max recommended: ${maxMB}MB).\n\nThis may cause memory issues. Continue anyway?`)) {
                return;
            }
        }

        // Route to appropriate handler
        currentFileType = is3MF ? "3mf" : "gcode";
        if (is3MF) {
            await process3MFFile(file, loops);
        } else {
            await processGcodeFile(file, loops);
        }
    }
    
    /**
     * Processes a G-code file (existing functionality)
     * @param {File} file - The G-code file to process
     * @param {number} loops - Number of loops to generate
     */
    async function processGcodeFile(file, loops) {
        // Show loading state
        setLoadingState(true, "Generating looped G-code file...");
        updateProgress(10, "Reading file...");

        originalFilename = file.name.replace(/\.(gcode|gco|g|txt)$/i, "") || "looprint";

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                updateProgress(30, "Processing G-code...");
                const baseGcode = (e.target.result || "").trim();
                
                // Check for empty file (edge case #20)
                if (!baseGcode || baseGcode.length === 0) {
                    setLoadingState(false);
                    showStatus("fileEmptyError", "error");
                    return;
                }
                
                // Check if already processed by Looprint
                // Check for both the signature and watermarks to ensure file hasn't been looped
                const hasLooprint = baseGcode.includes(LOOPRINT_SIGNATURE) ||
                                   baseGcode.includes("Generated by Looprint") ||
                                   baseGcode.includes("Contact: Nicki.Andersen@gmail.com");
                
                if (hasLooprint) {
                    setLoadingState(false);
                        showStatus("validationErrorLooprint", "error");
                    return;
                }

                updateProgress(50, "Building loop structure...");
                updateStatsDisplay(baseGcode, loops);

                // Extract max_z_height from G-code header for max_layer_z replacement
                const maxZMatch = baseGcode.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
                let maxZHeight = null;
                if (maxZMatch && maxZMatch[1]) {
                    maxZHeight = parseFloat(maxZMatch[1]);
                    // Validate extracted value (increased max to 1000mm for taller models)
                    if (isNaN(maxZHeight) || maxZHeight <= 0 || maxZHeight > MAX_Z_HEIGHT_MM) {
                        if (DEBUG_MODE) console.warn(`Invalid max_z_height value: ${maxZMatch[1]}`);
                        maxZHeight = null;
                    }
                }

                // Get end code
                const endCodeElement = document.getElementById(`end${currentDirection.charAt(0).toUpperCase() + currentDirection.slice(1)}Code`);
                if (!endCodeElement) {
                    setLoadingState(false);
                    showStatus("validationErrorParse", "error", "Error: Could not find end code element. Please refresh the page.");
                    return;
                }
                let activeEndCode = endCodeElement.value;
                
                if (!activeEndCode || activeEndCode.trim().length === 0) {
                    setLoadingState(false);
                    showStatus("validationErrorParse", "error", "Error: End code is empty. Please refresh the page.");
                    return;
                }
                
                // Replace {max_layer_z} with actual value and evaluate conditionals
                if (maxZHeight !== null && !isNaN(maxZHeight)) {
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                    activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                        const numVal = parseFloat(val);
                        if (isNaN(numVal)) {
                            if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                            return match;
                        }
                        const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                        return result.toFixed(2);
                    });
                    activeEndCode = activeEndCode.replace(/\{if\s*\(max_layer_z\s*\)\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                        const thresholdNum = parseFloat(threshold);
                        if (isNaN(thresholdNum)) {
                            if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                            return match;
                        }
                        if (maxZHeight > thresholdNum) {
                            return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                         .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                             const numVal = parseFloat(val);
                                             if (isNaN(numVal)) {
                                                 if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                 return m;
                                             }
                                             const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                             return result.toFixed(2);
                                         }).trim();
                        } else {
                            return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                          .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                              const numVal = parseFloat(val);
                                                              if (isNaN(numVal)) {
                                                                  if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                                  return m;
                                                              }
                                                              const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                              return result.toFixed(2);
                                                          }).trim() : '';
                        }
                    });
                } else {
                    setLoadingState(false);
                    showStatus("validationErrorParse", "error", 
                        "Error: Could not extract model height (max_z_height) from G-code header. " +
                        "The generated file would contain invalid variables. Please ensure your G-code file contains 'max_z_height' in the header.");
                    if (DEBUG_MODE) console.error("Cannot generate file: max_z_height not found in G-code header");
                    return;
                }

                // Extract print G-code only (remove existing end code)
                const endCodeStartMarker = END_CODE_START_MARKER; 
                let printGcodeOnly = baseGcode;
                const endCodeIndex = baseGcode.lastIndexOf(endCodeStartMarker);
                if (endCodeIndex !== -1) {
                    printGcodeOnly = baseGcode.substring(0, endCodeIndex).trim();
                } else {
                    if (DEBUG_MODE) console.warn("Factorian End Code marker not found. Looping entire file without safely deleting end code.");
                }

                // Parse G-code structure (same logic as 3MF)
                const gcodeStructure = parseGcodeStructure(printGcodeOnly);
                const gcodeHeader = gcodeStructure.header;
                const gcodeConfig = gcodeStructure.config;
                const printGcodeExecutable = gcodeStructure.executable;
                
                updateProgress(60, `Generating ${loops} loops...`);
                
                // Extract variable values from CONFIG_BLOCK or G-code
                const variableValues = extractVariableValues(baseGcode, gcodeConfig);
                
                // Replace variables in START_CODE_3MF with actual values
                const startCodeWithVars = replaceStartCodeVariables(START_CODE_3MF, variableValues);
                
                // Build looped G-code with start code in each loop
                const parts = [];
                parts.push(`; ===== ${LOOPRINT_SIGNATURE} (Start) =====`);
                parts.push(`; Source: ${file.name}`);
                parts.push(`; Loops: ${loops}`);
                parts.push(`; Generated: ${new Date().toISOString()}`);
                parts.push(`; Generated by Looprint`);
                parts.push(`; Contact: Nicki.Andersen@gmail.com`);
                parts.push(`\n`);
                
                for (let i = 1; i <= loops; i++) {
                    const loopProgress = 60 + (i / loops) * 30;
                        updateProgress(loopProgress, `Generating loop ${i} of ${loops}...`);
                        
                    parts.push(`; >>> LOOP ${i} / ${loops} <<<`);
                    
                    if (i === 1) {
                        // First loop: include header and config
                        if (gcodeHeader) {
                            parts.push(gcodeHeader);
                            parts.push('\n');
                        }
                        if (gcodeConfig) {
                            parts.push(gcodeConfig);
                            parts.push('\n');
                        }
                    } else {
                        // Subsequent loops: M400 safety wait
                        parts.push("M400 ; Looprint safety: Wait for buffer clear before next loop");
                        parts.push('\n');
                    }
                    
                    // Add setup part (EXECUTABLE_BLOCK_START, setup commands, FEATURE: Custom)
                    if (typeof printGcodeExecutable === 'object' && printGcodeExecutable.setup) {
                        parts.push(printGcodeExecutable.setup);
                        parts.push('\n');
                        
                        // Add start code for each loop (AFTER FEATURE: Custom, BEFORE print G-code)
                        parts.push(startCodeWithVars);
                        parts.push('\n');
                        
                        // Ensure temperature is set correctly after start code
                        if (printGcodeExecutable.print) {
                            const printStart = printGcodeExecutable.print.trim();
                            if (printStart.match(/^;LAYER_CHANGE|^; layer|^;LAYER/i)) {
                                // Print starts directly with layer marker - ensure temp is set
                                if (variableValues['nozzle_temperature_initial_layer']) {
                                    parts.push(`; Ensure nozzle temperature is set for printing\n`);
                                    parts.push(`M104 S${variableValues['nozzle_temperature_initial_layer']} ; Set nozzle temp for printing\n`);
                                    parts.push('\n');
                                }
                            }
                            parts.push(printGcodeExecutable.print);
                            parts.push('\n');
                        }
                    } else {
                        // Fallback: if structure is different, use as string
                        const printGcodeStr = typeof printGcodeExecutable === 'string' ? printGcodeExecutable : String(printGcodeExecutable);
                        if (!printGcodeStr.includes('machine: P1S') && !printGcodeStr.includes('FactorianDesigns')) {
                            // Original start code not found, safe to add
                            parts.push(startCodeWithVars);
                            parts.push('\n');
                        }
                        parts.push(printGcodeStr);
                        parts.push('\n');
                    }
                    
                    // Add end code after each loop
                    parts.push(activeEndCode);
                    parts.push('\n');
                }

                updateProgress(95, "Finalizing file...");
                parts.push(`; >>> END OF PRINT LOOPS <<<`);
                parts.push(`; ===== ${LOOPRINT_SIGNATURE} (End) =====`);

                // Build file efficiently - use Blob for large files to avoid string length limits
                try {
                    updateProgress(97, "Assembling final file...");
                    
                    // Estimate total size (optimized: only count strings, skip non-strings)
                    let estimatedSize = 0;
                    for (let i = 0; i < parts.length; i++) {
                        if (typeof parts[i] === 'string') {
                            estimatedSize += parts[i].length;
                        }
                    }
                    const MAX_STRING_SIZE = 200 * 1024 * 1024; // 200MB - safe limit for most browsers
                    
                    if (estimatedSize > MAX_STRING_SIZE) {
                        // For large files, build directly as Blob to avoid string length limits
                        updateProgress(98, "Building large file (using optimized method)...");
                        
                        // Convert all parts to strings and create Blob directly (optimized: only convert non-strings)
                        const blobParts = [];
                        for (let i = 0; i < parts.length; i++) {
                            blobParts.push(typeof parts[i] === 'string' ? parts[i] : String(parts[i]));
                        }
                        finalFileContent = new Blob(blobParts, { type: 'text/plain' });
                        
                        // Check blob size
                        if (finalFileContent.size > 1000 * 1024 * 1024) { // 1GB limit
                            throw new Error("Generated file is too large (>1GB). Please reduce number of loops.");
                        }
                    } else {
                        // For smaller files, use string (faster and simpler)
                finalFileContent = parts.join("\n");
                    }
                } catch (joinError) {
                    setLoadingState(false);
                    if (joinError.message && (joinError.message.includes("too large") || joinError.message.includes("Invalid string length"))) {
                        showStatus("validationErrorParse", "error", 
                            `File too large for ${loops} loops. Try reducing to ${Math.max(1, Math.floor(loops * 0.7))} loops or less.`);
                    } else {
                        showStatus("validationErrorParse", "error", 
                            `Failed to generate file: ${joinError.message || "Out of memory. Try reducing number of loops."}`);
                    }
                    if (DEBUG_MODE) console.error("Error assembling file:", joinError);
                    return;
                }

                updateProgress(100, "Complete!");
                setLoadingState(false);
                
                const outputEl = DOM.output || document.getElementById("output");
                outputEl.style.display = "block";
                document.getElementById("statSourceName").textContent = file.name;
                showStatus("outputReady", "success");
                
                setTimeout(() => updateProgress(0), 500);
                outputEl.scrollIntoView({ behavior: 'smooth' });
                outputEl.scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                setLoadingState(false);
                let errorMessage = LANG.en.validationErrorParse + ` (Generation Error)`;
                
                // Provide more specific error messages
                if (error instanceof RangeError || 
                    (error.message && (error.message.includes("memory") || error.message.includes("Invalid string length") || error.message.includes("string length")))) {
                    errorMessage = `File too large for ${loops} loops. JavaScript has a string length limit. Try reducing to ${Math.max(1, Math.floor(loops * 0.7))} loops or less.`;
                } else if (error.message) {
                    errorMessage = `Generation failed: ${error.message}`;
                }
                
                showStatus("validationErrorParse", "error", errorMessage);
                if (DEBUG_MODE) {
                    console.error("Critical error during file generation:", error);
                    console.error("Error details:", {
                        loops: loops,
                        fileSize: file.size,
                        estimatedSize: file.size * loops,
                        errorName: error.name,
                        errorMessage: error.message
                    });
                }
            }
        };
        
        reader.onerror = function() {
            setLoadingState(false);
            showStatus("validationErrorParse", "error");
        };
        
        reader.readAsText(file);
    }
    // --- SLUT P√Ö processGcodeFile() FUNKTION ---
    
    /**
     * Shared function to parse G-code structure (used by both G-code and 3MF processing)
     * Extracts header, config block, setup commands, and print G-code
     * @param {string} gcodeContent - Full G-code content (without end code)
     * @returns {Object} Object with header, config, setup, and print parts
     */
    function parseGcodeStructure(gcodeContent) {
        // Find where executable block starts (after CONFIG_BLOCK)
        const executableBlockStart = gcodeContent.indexOf('; EXECUTABLE_BLOCK_START');
        let gcodeHeader = '';
        let gcodeConfig = '';
        let printGcodeExecutable = gcodeContent;
        
        if (executableBlockStart !== -1) {
            // Split into header/config and executable parts
            gcodeHeader = gcodeContent.substring(0, executableBlockStart).trim();
            printGcodeExecutable = gcodeContent.substring(executableBlockStart).trim();
            
            // Find CONFIG_BLOCK
            const configStart = gcodeHeader.indexOf('; CONFIG_BLOCK_START');
            const configEnd = gcodeHeader.indexOf('; CONFIG_BLOCK_END');
            if (configStart !== -1 && configEnd !== -1) {
                gcodeConfig = gcodeHeader.substring(configStart, configEnd + '; CONFIG_BLOCK_END'.length);
                gcodeHeader = gcodeHeader.substring(0, configStart).trim() + '\n' + gcodeHeader.substring(configEnd + '; CONFIG_BLOCK_END'.length).trim();
            }
            
            // Extract setup commands (M73, M201, etc.) and FEATURE: Custom, but remove original start code
            // Structure: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> start code -> print G-code
            // We want: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> START_CODE -> print G-code
            
            // Split into: setup part (up to FEATURE: Custom) and print part (after original start code)
            let setupPart = '';
            let printPart = '';
            
                const featureIndex = printGcodeExecutable.indexOf('; FEATURE: Custom');
            if (featureIndex !== -1) {
                // Keep everything up to and including "FEATURE: Custom"
                setupPart = printGcodeExecutable.substring(0, featureIndex + '; FEATURE: Custom'.length);
                
                // After FEATURE: Custom, there's original start code, then print G-code
                const afterFeature = printGcodeExecutable.substring(featureIndex + '; FEATURE: Custom'.length);
                
                // First, try to find "Start Code End" marker (most reliable indicator)
                // This marker is added by Bambu Studio to mark the end of start code
                const startCodeEndMarker = /; =+.*Start Code End.*=+/i;
                const startCodeEndMatch = afterFeature.match(startCodeEndMarker);
                
                let printStartIndex = -1;
                
                if (startCodeEndMatch) {
                    // Found "Start Code End" marker - print starts after this marker
                    // CRITICAL: Everything between FEATURE: Custom and "Start Code End" is the original start code
                    // We need to skip it completely and start from after "Start Code End"
                    const afterMarker = afterFeature.substring(startCodeEndMatch.index + startCodeEndMatch[0].length);
                    // Find CHANGE_LAYER after marker (most reliable)
                    const changeLayerMatch = afterMarker.match(/; CHANGE_LAYER|;LAYER_CHANGE/i);
                    if (changeLayerMatch) {
                        printStartIndex = startCodeEndMatch.index + startCodeEndMatch[0].length + changeLayerMatch.index;
                    } else {
                        // Fallback: Find first non-empty, non-comment line after marker
                        const lines = afterMarker.split('\n');
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (line && !line.startsWith(';')) {
                                // Found first actual G-code command
                                printStartIndex = startCodeEndMatch.index + startCodeEndMatch[0].length + 
                                    lines.slice(0, i).join('\n').length + 1; // +1 for newline
                                break;
                            }
                        }
                    }
                }
                
                // ROBUST REGEX: Find standard Bambu/Orca layer change or Z-height markers
                // Prioritized list of markers that indicate start of actual print
                // CRITICAL: Layer markers must come FIRST - they are the most reliable indicators
                const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                
                // Find where original start code ends using robust regex
                // CRITICAL: We need to find the FIRST occurrence of the marker, not any occurrence
                const splitMatch = printStartIndex === -1 ? afterFeature.match(startCodeEndRegex) : null;
                
                if (printStartIndex !== -1) {
                    // Use "Start Code End" marker position
                    let layerStart = afterFeature.substring(printStartIndex);
                    
                    // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                    // These are remnants from the original start code that should be removed
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    
                    // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1; // +1 for newline
                            continue;
                        }
                        // Skip M104 S140 or M109 S140 commands
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        // Found first non-temp command - this is where print actually starts
                        break;
                    }
                    
                    printPart = layerStart.substring(startIndex).trim();
                } else if (!splitMatch) {
                    if (DEBUG_MODE) {
                        console.warn("WARNING: Could not find start point (Layer Change) in file. Start code may be duplicated!");
                        console.warn("Attempting fallback: Split after last M109 (Wait for temp)...");
                    }
                    
                    // Fallback: Try to find last M109 (Wait for temp) which marks the end of start code
                    const m109Matches = [...afterFeature.matchAll(/M109\s+S\d+/gi)];
                    if (m109Matches.length > 0) {
                        const lastM109 = m109Matches[m109Matches.length - 1];
                        const afterM109 = afterFeature.substring(lastM109.index + lastM109[0].length);
                        
                        // Try to find first print command after M109
                        const firstPrintMatch = afterM109.match(/(M73\s+P\d+|G1\s+X|G0\s+X|;LAYER|; layer)/i);
                        if (firstPrintMatch) {
                            printPart = afterM109.substring(firstPrintMatch.index).trim();
                        } else {
                            // Last fallback: use everything after last M109
                            printPart = afterM109.trim();
                            if (DEBUG_MODE) console.warn("Using everything after last M109 as fallback - start code may still be duplicated!");
                        }
                    } else {
                        // No M109 found - try to find first print command
                        const firstPrintMatch = afterFeature.match(/(M73\s+P\d+|G1\s+X|G0\s+X|G28|;LAYER|; layer)/i);
                        if (firstPrintMatch) {
                            printPart = afterFeature.substring(firstPrintMatch.index).trim();
                        } else {
                            // Last fallback: use everything after FEATURE: Custom (NOT IDEAL - start code may be duplicated)
                            printPart = afterFeature.trim();
                            if (DEBUG_MODE) console.error("CRITICAL: Could not find start point. Start code will likely be duplicated!");
                        }
                    }
                } else {
                    // Found a match - start from the matched position
                    // CRITICAL: splitMatch.index gives us the position of the marker in afterFeature
                    // We want everything AFTER the marker, not before it
                    let layerStart = afterFeature.substring(splitMatch.index);
                    
                    // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                    // These are remnants from the original start code that should be removed
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    
                    // Skip marker line and any following M104 S140 or M109 S140 commands
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1; // +1 for newline
                            continue;
                        }
                        // Skip M104 S140 or M109 S140 commands
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        // Found first non-temp command - this is where print actually starts
                        break;
                    }
                    
                    printPart = layerStart.substring(startIndex).trim();
                    
                    // Safety check: If printPart still contains old start code, try to find layer marker again
                    if (printPart.includes('G1 Z5 F300') || printPart.includes('M17 X1.2 Y1.2 Z0.75') || printPart.includes('G90\nM17 X1.2')) {
                        if (DEBUG_MODE) console.warn('WARNING: printPart may still contain old start code! Attempting to fix...');
                        // Try to find where the actual print starts by looking for layer markers
                        const layerMarkerMatch = printPart.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i);
                        if (layerMarkerMatch) {
                            printPart = printPart.substring(layerMarkerMatch.index);
                        }
                    }
                }
            } else {
                // If no FEATURE: Custom, try to find layer marker directly
                const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                const splitMatch = printGcodeExecutable.match(startCodeEndRegex);
                
                if (splitMatch) {
                    setupPart = printGcodeExecutable.substring(0, splitMatch.index).trim();
                    let layerStart = printGcodeExecutable.substring(splitMatch.index);
                    
                    // Remove temperature commands after marker
                    const lines = layerStart.split('\n');
                    let startIndex = 0;
                    for (let i = 0; i < Math.min(lines.length, 20); i++) {
                        const line = lines[i].trim();
                        if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        if (line.match(/^M(104|109)\s+S140/i)) {
                            startIndex += lines[i].length + 1;
                            continue;
                        }
                        break;
                    }
                    printPart = layerStart.substring(startIndex).trim();
                } else {
                    // No structure found - keep everything as setup (fallback)
                    setupPart = printGcodeExecutable;
                    printPart = '';
                }
            }
            
            // Store both parts separately so we can insert START_CODE between them
            printGcodeExecutable = { setup: setupPart, print: printPart };
        }
        
        return {
            header: gcodeHeader,
            config: gcodeConfig,
            executable: printGcodeExecutable
        };
    }
    
    /**
     * Processes a 3MF file: unzips, modifies G-code, and repacks
     * @param {File} file - The 3MF file to process
     * @param {number} loops - Number of loops to generate
     */
    /**
     * Parses entire CONFIG_BLOCK into a map/object
     * Handles lists (comma-separated values) and converts them to arrays
     * @param {string} gcodeConfig - CONFIG_BLOCK content
     * @returns {Object} Map of all config variables
     */
    function parseConfigBlock(gcodeConfig) {
        const configMap = {};
        
        if (!gcodeConfig) return configMap;
        
        // Split into lines and process each line
        const lines = gcodeConfig.split('\n');
        for (const line of lines) {
            // Match: ; variable_name = value
            // or: ; variable_name[index] = value
            // or: ; variable_name = "value"
            const match = line.match(/^;\s*([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?\s*=\s*(.+)$/);
            if (match) {
                const varName = match[1];
                const arrayIndex = match[2];
                let value = match[3].trim();
                
                // Remove quotes if present
                if ((value.startsWith('"') && value.endsWith('"')) || 
                    (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }
                
                // Handle comma-separated lists (convert to array)
                if (value.includes(',') && !value.includes('"') && !value.includes("'")) {
                    const listValues = value.split(',').map(v => v.trim()).filter(v => v);
                    if (listValues.length > 1) {
                        // Store as array
                        if (!configMap[varName]) {
                            configMap[varName] = [];
                        }
                        if (arrayIndex !== undefined) {
                            // Array format: variable[index] = value
                            const idx = parseInt(arrayIndex, 10);
                            if (!Array.isArray(configMap[varName])) {
                                configMap[varName] = [];
                            }
                            configMap[varName][idx] = value; // Store single value at index
                        } else {
                            // List format: variable = value1,value2,value3
                            configMap[varName] = listValues;
                        }
                    } else {
                        // Single value despite comma
                        if (arrayIndex !== undefined) {
                            const idx = parseInt(arrayIndex, 10);
                            if (!configMap[varName]) {
                                configMap[varName] = [];
                            }
                            configMap[varName][idx] = value;
                        } else {
                            configMap[varName] = value;
                        }
                    }
                } else {
                    // Single value
                    if (arrayIndex !== undefined) {
                        const idx = parseInt(arrayIndex, 10);
                        if (!configMap[varName]) {
                            configMap[varName] = [];
                        }
                        configMap[varName][idx] = value;
                    } else {
                        configMap[varName] = value;
                    }
                }
            }
        }
        
        return configMap;
    }
    
    /**
     * Gets a variable value from configMap, handling arrays and indices
     * @param {Object} configMap - Parsed CONFIG_BLOCK map
     * @param {string} varName - Variable name
     * @param {number|string} index - Optional array index (defaults to 0 or uses initial_extruder)
     * @param {string} initialExtruder - Initial extruder index (defaults to '0')
     * @returns {string|null} Variable value or null if not found
     */
    function getConfigValue(configMap, varName, index = null, initialExtruder = '0') {
        if (!configMap[varName]) return null;
        
        const value = configMap[varName];
        if (Array.isArray(value)) {
            const idx = index !== null ? parseInt(index, 10) : parseInt(initialExtruder || '0', 10);
            return value[idx] || value[0] || null;
        }
        return value;
    }
    
    /**
     * Extracts variable values from G-code CONFIG_BLOCK or actual G-code commands
     * Uses parseConfigBlock for systematic parsing, then extracts specific needed variables
     * @param {string} gcodeContent - Full G-code content
     * @param {string} gcodeConfig - CONFIG_BLOCK content
     * @returns {Object} Object with variable names as keys and values as strings
     */
    function extractVariableValues(gcodeContent, gcodeConfig) {
        const vars = {};
        
        // Parse entire CONFIG_BLOCK into a map
        const configMap = parseConfigBlock(gcodeConfig);
        
        // Extract initial_extruder first (needed for array lookups)
        vars['initial_extruder'] = getConfigValue(configMap, 'initial_extruder') || '0';
        
        // Extract variables using getConfigValue (systematic approach - NO redundant code)
        if (gcodeConfig) {
            // Extract all variables using getConfigValue (clean, systematic)
            vars['nozzle_temperature_initial_layer'] = getConfigValue(configMap, 'nozzle_temperature_initial_layer', null, vars['initial_extruder']);
            vars['filament_type'] = getConfigValue(configMap, 'filament_type', null, vars['initial_extruder']);
            vars['curr_bed_type'] = getConfigValue(configMap, 'curr_bed_type');
            vars['hot_plate_temp_initial_layer'] = getConfigValue(configMap, 'hot_plate_temp_initial_layer');
            vars['cool_plate_temp_initial_layer'] = getConfigValue(configMap, 'cool_plate_temp_initial_layer');
            vars['filament_max_volumetric_speed'] = getConfigValue(configMap, 'filament_max_volumetric_speed', null, vars['initial_extruder']);
            vars['nozzle_temperature_range_high'] = getConfigValue(configMap, 'nozzle_temperature_range_high', null, vars['initial_extruder']);
            vars['bed_temperature'] = getConfigValue(configMap, 'bed_temperature', null, vars['initial_extruder']);
            vars['bed_temperature_initial_layer'] = getConfigValue(configMap, 'bed_temperature_initial_layer', null, vars['initial_extruder']);
            vars['bed_temperature_initial_layer_single'] = getConfigValue(configMap, 'bed_temperature_initial_layer_single');
            
            // Determine bed_temperature_initial_layer_single based on curr_bed_type (smart fallback)
            if (!vars['bed_temperature_initial_layer_single']) {
                if (vars['bed_temperature_initial_layer']) {
                    vars['bed_temperature_initial_layer_single'] = vars['bed_temperature_initial_layer'];
                } else if (vars['bed_temperature']) {
                    vars['bed_temperature_initial_layer_single'] = vars['bed_temperature'];
                } else if (vars['curr_bed_type']) {
                    const bedType = vars['curr_bed_type'].toLowerCase();
                    if ((bedType.includes('textured') || bedType.includes('pei') || bedType.includes('hot')) && vars['hot_plate_temp_initial_layer']) {
                        vars['bed_temperature_initial_layer_single'] = vars['hot_plate_temp_initial_layer'];
                    } else if (bedType.includes('cool') && vars['cool_plate_temp_initial_layer']) {
                        vars['bed_temperature_initial_layer_single'] = vars['cool_plate_temp_initial_layer'];
                    }
                }
            }
            
            // CRITICAL: Ensure bed_temperature and bed_temperature_initial_layer have fallback values for conditional evaluation
            // These are needed for conditional statements even if not used directly in [brackets]
            if (!vars['bed_temperature'] && vars['bed_temperature_initial_layer_single']) {
                vars['bed_temperature'] = vars['bed_temperature_initial_layer_single'];
            }
            if (!vars['bed_temperature_initial_layer'] && vars['bed_temperature_initial_layer_single']) {
                vars['bed_temperature_initial_layer'] = vars['bed_temperature_initial_layer_single'];
            }
        }
        
        // Fallback: Extract from actual G-code commands if not found in CONFIG_BLOCK
        if (!vars['nozzle_temperature_initial_layer']) {
            const m104Match = gcodeContent.match(/M104\s+S(\d+)\s*;.*nozzle.*temp/i);
            if (m104Match) vars['nozzle_temperature_initial_layer'] = m104Match[1];
        }
        
        if (!vars['bed_temperature_initial_layer_single']) {
            const m140Match = gcodeContent.match(/M140\s+S(\d+)/i);
            if (m140Match) vars['bed_temperature_initial_layer_single'] = m140Match[1];
        }
        
        if (!vars['initial_extruder'] || vars['initial_extruder'] === '0') {
            const tMatch = gcodeContent.match(/T(\d+)/);
            if (tMatch) vars['initial_extruder'] = tMatch[1];
        }
        
        // CRITICAL: Ensure bed_temperature and bed_temperature_initial_layer have values for conditional evaluation
        // These must be set BEFORE defaults are applied, so conditionals can use them
        if (!vars['bed_temperature'] && vars['bed_temperature_initial_layer_single']) {
            vars['bed_temperature'] = vars['bed_temperature_initial_layer_single'];
        }
        if (!vars['bed_temperature_initial_layer'] && vars['bed_temperature_initial_layer_single']) {
            vars['bed_temperature_initial_layer'] = vars['bed_temperature_initial_layer_single'];
        }
        
        // Apply safe fallback defaults (CRITICAL: prevents "140¬∞C" error)
        const DEFAULTS = {
            'nozzle_temperature_initial_layer': '220',
            'bed_temperature_initial_layer_single': '60',
            'bed_temperature': '60', // Also set default for conditional evaluation
            'bed_temperature_initial_layer': '60', // Also set default for conditional evaluation
            'filament_max_volumetric_speed': '12',
            'nozzle_temperature_range_high': '240', // Default: nozzle_temp + 20
            'initial_extruder': '0'
        };
        
        for (const [key, defaultValue] of Object.entries(DEFAULTS)) {
            if (!vars[key]) {
                vars[key] = defaultValue;
            }
        }
        
        // Calculate nozzle_temperature_range_high from nozzle_temperature_initial_layer if not found
        if (!vars['nozzle_temperature_range_high'] || vars['nozzle_temperature_range_high'] === '240') {
            if (vars['nozzle_temperature_initial_layer']) {
                const nozzleTemp = parseInt(vars['nozzle_temperature_initial_layer'], 10);
                if (!isNaN(nozzleTemp)) {
                    vars['nozzle_temperature_range_high'] = (nozzleTemp + 20).toString();
                }
            }
        }
        
        return vars;
    }
    
    /**
     * Replaces variables in START_CODE_3MF with actual values
     * @param {string} startCode - START_CODE_3MF template
     * @param {Object} vars - Variable values object
     * @returns {string} Start code with variables replaced
     */
    function replaceStartCodeVariables(startCode, vars) {
        let result = startCode;
        const initialExtruder = vars['initial_extruder'] || '0';
        
        // STEP 1: Replace conditional {if} statements FIRST (before replacing [initial_extruder] in conditionals)
        // CRITICAL: Must evaluate ALL nested conditionals BEFORE replacing [initial_extruder] to avoid "bed_temperature255" issue
        // Replace conditional {if} statements for PLA fan
        // Pattern: {if filament_type[initial_extruder]=="PLA"} ... {if (bed_temperature[initial_extruder] >45)||(bed_temperature_initial_layer[initial_extruder] >45)} ... {endif} ... {endif}
        // We need to process nested conditionals from innermost to outermost
        
        // FIRST: Process the innermost conditional (bed_temperature check) - this must happen BEFORE [initial_extruder] replacement
        const innerBedTempPattern = /\{if\s+\(bed_temperature\[initial_extruder\]\s*>\s*45\)\|\|\(bed_temperature_initial_layer\[initial_extruder\]\s*>\s*45\)\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(innerBedTempPattern, (innerMatch, innerContent) => {
            // Use bed_temperature_initial_layer_single as fallback if bed_temperature or bed_temperature_initial_layer not found
            let bedTemp = parseFloat(vars['bed_temperature'] || vars['bed_temperature_initial_layer_single'] || '0');
            let bedTempInit = parseFloat(vars['bed_temperature_initial_layer'] || vars['bed_temperature_initial_layer_single'] || '0');
            
            // Also try hot_plate_temp_initial_layer or cool_plate_temp_initial_layer as fallback
            if (bedTemp === 0 && vars['hot_plate_temp_initial_layer']) {
                bedTemp = parseFloat(vars['hot_plate_temp_initial_layer']);
            }
            if (bedTempInit === 0 && vars['hot_plate_temp_initial_layer']) {
                bedTempInit = parseFloat(vars['hot_plate_temp_initial_layer']);
            }
            if (bedTemp === 0 && vars['cool_plate_temp_initial_layer']) {
                bedTemp = parseFloat(vars['cool_plate_temp_initial_layer']);
            }
            if (bedTempInit === 0 && vars['cool_plate_temp_initial_layer']) {
                bedTempInit = parseFloat(vars['cool_plate_temp_initial_layer']);
            }
            
            if (bedTemp > 45 || bedTempInit > 45) {
                // Return the content (M106 line) - [initial_extruder] will be replaced later in STEP 3
                return innerContent.trim();
            } else {
                return ''; // Remove content if condition is false
            }
        });
        
        // SECOND: Process the outer conditional (filament_type check)
        const plaFanPattern = /\{if\s+filament_type\[initial_extruder\]=="PLA"\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(plaFanPattern, (match, content) => {
            if (vars['filament_type'] && vars['filament_type'].toUpperCase() === 'PLA') {
                // Content already has inner conditionals processed, just return it
                // [initial_extruder] will be replaced later in STEP 3
                return content;
            } else {
                return ''; // Remove entire PLA fan block if not PLA
            }
        });
        
        // Replace curr_bed_type conditional
        const bedTypePattern = /\{if\s+curr_bed_type=="Textured PEI Plate"\}([\s\S]*?)\{endif\}/gi;
        result = result.replace(bedTypePattern, (match, content) => {
            if (vars['curr_bed_type'] && vars['curr_bed_type'].includes('Textured PEI')) {
                return content; // Keep content for Textured PEI
            } else {
                return ''; // Remove content for other bed types
            }
        });
        
        // STEP 2: Replace {braces} variables (expressions) - AFTER conditionals but BEFORE [brackets]
        // Use default if not found (should not happen due to DEFAULTS, but safety check)
        const nozzleTemp = parseFloat(vars['nozzle_temperature_initial_layer'] || '220');
        if (!isNaN(nozzleTemp)) {
            // {nozzle_temperature_initial_layer[initial_extruder]-20}
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_extruder\]-20\}/g, (nozzleTemp - 20).toString());
            // {nozzle_temperature_initial_layer[initial_no_support_extruder]-20}
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_no_support_extruder\]-20\}/g, (nozzleTemp - 20).toString());
            // {nozzle_temperature_initial_layer[initial_extruder]} (without -20)
            result = result.replace(/\{nozzle_temperature_initial_layer\[initial_extruder\]\}/g, nozzleTemp.toString());
        }
        
        // Replace filament_max_volumetric_speed expression
        // Pattern: {filament_max_volumetric_speed[initial_extruder]/2.4053*60}
        if (vars['filament_max_volumetric_speed']) {
            const volumetricSpeed = parseFloat(vars['filament_max_volumetric_speed']);
            if (!isNaN(volumetricSpeed)) {
                // Calculate: volumetricSpeed / 2.4053 * 60
                const calculatedValue = Math.round((volumetricSpeed / 2.4053) * 60);
                result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, calculatedValue.toString());
                // Also handle without [initial_extruder] if present
                result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, calculatedValue.toString());
            } else {
                // Fallback: use safe default speed F1200
                result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, '1200');
                result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, '1200');
            }
        } else {
            // Fallback: use safe default speed F1200
            result = result.replace(/\{filament_max_volumetric_speed\[initial_extruder\]\/2\.4053\*60\}/g, '1200');
            result = result.replace(/\{filament_max_volumetric_speed\/2\.4053\*60\}/g, '1200');
        }
        
        // Handle other mathematical expressions in {braces}
        // Pattern: {expression} where expression can contain variables and math
        // Example: {outer_wall_volumetric_speed/(0.3*0.5) * 60}
        // For safety, we'll use a fixed value F1200 for complex speed calculations
        result = result.replace(/\{outer_wall_volumetric_speed[^}]*\}/g, '1200'); // Replace with safe default
        
        // Replace nozzle_temperature_range_high
        if (vars['nozzle_temperature_range_high']) {
            result = result.replace(/\{nozzle_temperature_range_high\[initial_extruder\]\}/g, vars['nozzle_temperature_range_high']);
        } else {
            // Fallback: use nozzle_temperature_initial_layer + 20 as safe default
            const defaultRangeHigh = vars['nozzle_temperature_initial_layer'] ? (parseInt(vars['nozzle_temperature_initial_layer'], 10) + 20).toString() : '240';
            result = result.replace(/\{nozzle_temperature_range_high\[initial_extruder\]\}/g, defaultRangeHigh);
        }
        
        // Replace {+0.0} constant (not a variable, but ensure it's handled)
        result = result.replace(/\{\+0\.0\}/g, '0.0');
        
        // STEP 3: Replace [brackets] variables LAST (simple replacements)
        // Use defaults if not found (should not happen due to DEFAULTS, but safety check)
        const nozzleTempFinal = vars['nozzle_temperature_initial_layer'] || '220';
        result = result.replace(/\[nozzle_temperature_initial_layer\]/g, nozzleTempFinal);
        
        const bedTempFinal = vars['bed_temperature_initial_layer_single'] || '60';
        result = result.replace(/\[bed_temperature_initial_layer_single\]/g, bedTempFinal);
        
        const initialExtruderFinal = vars['initial_extruder'] || '0';
        result = result.replace(/\[initial_extruder\]/g, initialExtruderFinal);
        
        // Remove any remaining unmatched variables (leave them as-is for printer to evaluate)
        // This is safer than removing them completely
        
        return result;
    }

    async function process3MFFile(file, loops) {
        // Show loading state
        setLoadingState(true, "Processing 3MF file...");
        updateProgress(10, "Reading 3MF file...");
        
        // Remove file extension (only the last one to handle cases like "file.gcode.3mf")
        originalFilename = file.name.replace(/\.[^.]*$/, "") || "looprint_factorian";
        
        try {
            updateProgress(10, "Reading 3MF file...");
            
            // Check if JSZip is available
            if (typeof JSZip === 'undefined') {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: JSZip library not loaded. Please refresh the page.");
                return;
            }
            
            // Read file as array buffer
            const arrayBuffer = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            updateProgress(30, "Finding G-code file...");
            
            // Find G-code file(s) in Metadata folder
            const gcodeFiles = [];
            zip.forEach((relativePath, file) => {
                if (relativePath.match(GCODE_FILE_IN_3MF_REGEX)) {
                    gcodeFiles.push(relativePath);
                }
            });
            
            if (gcodeFiles.length === 0) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: No G-code file found in 3MF structure. Expected: Metadata/plate_*.gcode");
                return;
            }
            
            // Process first G-code file (support multiple plates later if needed)
            const gcodePath = gcodeFiles[0];
            const gcodeContent = await zip.file(gcodePath).async('string');
            
            updateProgress(40, "Processing G-code...");
            
            // Validate G-code (already validated in validateFileImmediate, but double-check)
            // Check for both the signature and watermarks to ensure file hasn't been looped
            const hasLooprint = gcodeContent.includes(LOOPRINT_SIGNATURE) ||
                               gcodeContent.includes("Generated by Looprint") ||
                               gcodeContent.includes("Contact: Nicki.Andersen@gmail.com");
            
            if (hasLooprint) {
                setLoadingState(false);
                showStatus("validationErrorLooprint", "error");
                return;
            }
            
            updateProgress(50, "Building loop structure...");
            updateStatsDisplay(gcodeContent, loops);
            
            // Extract max_z_height from G-code header
            const maxZMatch = gcodeContent.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let maxZHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                maxZHeight = parseFloat(maxZMatch[1]);
                if (isNaN(maxZHeight) || maxZHeight <= 0 || maxZHeight > MAX_Z_HEIGHT_MM) {
                    if (DEBUG_MODE) console.warn(`Invalid max_z_height value: ${maxZMatch[1]}`);
                    maxZHeight = null;
                }
            }
            
            // Get end code
            const endCodeElement = document.getElementById(`end${currentDirection.charAt(0).toUpperCase() + currentDirection.slice(1)}Code`);
            if (!endCodeElement) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: Could not find end code element. Please refresh the page.");
                return;
            }
            let activeEndCode = endCodeElement.value;
            
            if (!activeEndCode || activeEndCode.trim().length === 0) {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", "Error: End code is empty. Please refresh the page.");
                return;
            }
            
            // Replace {max_layer_z} with actual value and evaluate conditionals
            if (maxZHeight !== null && !isNaN(maxZHeight)) {
                activeEndCode = activeEndCode.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2));
                activeEndCode = activeEndCode.replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (match, op, val) => {
                    const numVal = parseFloat(val);
                    if (isNaN(numVal)) {
                        if (DEBUG_MODE) console.error(`Invalid value in expression: ${match}`);
                        return match;
                    }
                    const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                    return result.toFixed(2);
                });
                activeEndCode = activeEndCode.replace(/\{if\s*\(max_layer_z\s*\)\s*>\s*([\d\.]+)\}([\s\S]*?)(?:\{else\}([\s\S]*?))?\{endif\}/g, (match, threshold, ifBlock, elseBlock) => {
                    const thresholdNum = parseFloat(threshold);
                    if (isNaN(thresholdNum)) {
                        if (DEBUG_MODE) console.error(`Invalid threshold in conditional: ${match}`);
                        return match;
                    }
                    if (maxZHeight > thresholdNum) {
                        return ifBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                     .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                         const numVal = parseFloat(val);
                                         if (isNaN(numVal)) {
                                             if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                             return m;
                                         }
                                         const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                         return result.toFixed(2);
                                     }).trim();
                    } else {
                        return elseBlock ? elseBlock.replace(/\{max_layer_z\}/g, maxZHeight.toFixed(2))
                                                  .replace(/\{max_layer_z\s*([+\-])\s*([\d\.]+)\}/g, (m, op, val) => {
                                                      const numVal = parseFloat(val);
                                                      if (isNaN(numVal)) {
                                                          if (DEBUG_MODE) console.error(`Invalid value in expression: ${m}`);
                                                          return m;
                                                      }
                                                      const result = op === '+' ? maxZHeight + numVal : maxZHeight - numVal;
                                                      return result.toFixed(2);
                                                  }).trim() : '';
                    }
                });
            } else {
                setLoadingState(false);
                showStatus("validationErrorParse", "error", 
                    "Error: Could not extract model height (max_z_height) from G-code header. " +
                    "The generated file would contain invalid variables. Please ensure your G-code file contains 'max_z_height' in the header.");
                return;
            }
            
            // Extract print G-code only (remove existing end code)
            const endCodeStartMarker = END_CODE_START_MARKER;
            let printGcodeOnly = gcodeContent;
            const endCodeIndex = gcodeContent.lastIndexOf(endCodeStartMarker);
            if (endCodeIndex !== -1) {
                printGcodeOnly = gcodeContent.substring(0, endCodeIndex).trim();
            } else {
                if (DEBUG_MODE) console.warn("Factorian End Code marker not found. Looping entire file without safely deleting end code.");
            }
            
            // Find where executable block starts (after CONFIG_BLOCK)
            const executableBlockStart = printGcodeOnly.indexOf('; EXECUTABLE_BLOCK_START');
            let gcodeHeader = '';
            let gcodeConfig = '';
            let printGcodeExecutable = printGcodeOnly;
            
            if (executableBlockStart !== -1) {
                // Split into header/config and executable parts
                gcodeHeader = printGcodeOnly.substring(0, executableBlockStart).trim();
                printGcodeExecutable = printGcodeOnly.substring(executableBlockStart).trim();
                
                // Find CONFIG_BLOCK
                const configStart = gcodeHeader.indexOf('; CONFIG_BLOCK_START');
                const configEnd = gcodeHeader.indexOf('; CONFIG_BLOCK_END');
                if (configStart !== -1 && configEnd !== -1) {
                    gcodeConfig = gcodeHeader.substring(configStart, configEnd + '; CONFIG_BLOCK_END'.length);
                    gcodeHeader = gcodeHeader.substring(0, configStart).trim() + '\n' + gcodeHeader.substring(configEnd + '; CONFIG_BLOCK_END'.length).trim();
                }
                
                // Extract setup commands (M73, M201, etc.) and FEATURE: Custom, but remove original start code
                // Structure: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> start code -> print G-code
                // We want: EXECUTABLE_BLOCK_START -> setup commands -> FEATURE: Custom -> START_CODE_3MF -> print G-code
                
                // Split into: setup part (up to FEATURE: Custom) and print part (after original start code)
                let setupPart = '';
                let printPart = '';
                
                const featureIndex = printGcodeExecutable.indexOf('; FEATURE: Custom');
                if (featureIndex !== -1) {
                    // Keep everything up to and including "FEATURE: Custom"
                    setupPart = printGcodeExecutable.substring(0, featureIndex + '; FEATURE: Custom'.length);
                    
                    // After FEATURE: Custom, there's original start code, then print G-code
                    const afterFeature = printGcodeExecutable.substring(featureIndex + '; FEATURE: Custom'.length);
                    
                    // ROBUST REGEX: Leder efter standard Bambu/Orca lag-skift eller Z-h√∏jde mark√∏rer
                    // Prioriteret liste af mark√∏rer der indikerer starten af faktisk print
                    // CRITICAL: Layer markers must come FIRST - they are the most reliable indicators
                    // G1 Z commands are removed because they match too early (in old start code)
                    const startCodeEndRegex = /; CHANGE_LAYER|;LAYER_CHANGE|; layer num\/total_layer_count|; layer |;Z_HEIGHT|;LAYER_NUM|; GEOMETRY_START/i;
                    
                    // Find where original start code ends using robust regex
                    // CRITICAL: We need to find the FIRST occurrence of the marker, not any occurrence
                    const splitMatch = afterFeature.match(startCodeEndRegex);
                    
                    if (!splitMatch) {
                        if (DEBUG_MODE) {
                            console.warn("WARNING: Could not find start point (Layer Change) in file. Start code may be duplicated!");
                            console.warn("Attempting fallback: Split after last M109 (Wait for temp)...");
                        }
                        
                        // Fallback: Try to find last M109 (Wait for temp) which marks the end of start code
                        const m109Matches = [...afterFeature.matchAll(/M109\s+S\d+/gi)];
                        if (m109Matches.length > 0) {
                            const lastM109 = m109Matches[m109Matches.length - 1];
                            const afterM109 = afterFeature.substring(lastM109.index + lastM109[0].length);
                            
                            // Try to find first print command after M109
                            const firstPrintMatch = afterM109.match(/(M73\s+P\d+|G1\s+X|G0\s+X|;LAYER|; layer)/i);
                            if (firstPrintMatch) {
                                printPart = afterM109.substring(firstPrintMatch.index).trim();
                            } else {
                                // Last fallback: use everything after last M109
                                printPart = afterM109.trim();
                                if (DEBUG_MODE) console.warn("Using everything after last M109 as fallback - start code may still be duplicated!");
                            }
                        } else {
                            // No M109 found - try to find first print command
                            const firstPrintMatch = afterFeature.match(/(M73\s+P\d+|G1\s+X|G0\s+X|G28|;LAYER|; layer)/i);
                            if (firstPrintMatch) {
                                printPart = afterFeature.substring(firstPrintMatch.index).trim();
                            } else {
                                // Last fallback: use everything after FEATURE: Custom (NOT IDEAL - start code may be duplicated)
                                printPart = afterFeature.trim();
                                if (DEBUG_MODE) console.error("CRITICAL: Could not find start point. Start code will likely be duplicated!");
                            }
                        }
                    } else {
                        // Found a match - start from the matched position
                        // CRITICAL: splitMatch.index gives us the position of the marker in afterFeature
                        // We want everything AFTER the marker, not before it
                        let layerStart = afterFeature.substring(splitMatch.index);
                        
                        // Remove any temperature commands (M104 S140 or M109 S140) that come right after the marker
                        // These are remnants from the original start code that should be removed
                        const lines = layerStart.split('\n');
                        let startIndex = 0;
                        
                        // Skip marker line and any following M104 S140 or M109 S140 commands
                        for (let i = 0; i < Math.min(lines.length, 20); i++) {
                            const line = lines[i].trim();
                            // Skip empty lines and comments (but keep layer markers like ; CHANGE_LAYER, ; layer num)
                            if (!line || (line.startsWith(';') && !line.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i))) {
                                startIndex += lines[i].length + 1; // +1 for newline
                                continue;
                            }
                            // Skip M104 S140 or M109 S140 commands
                            if (line.match(/^M(104|109)\s+S140/i)) {
                                startIndex += lines[i].length + 1;
                                continue;
                            }
                            // Found first non-temp command - this is where print actually starts
                            break;
                        }
                        
                        printPart = layerStart.substring(startIndex).trim();
                        
                        // Safety check: If printPart still contains old start code, try to find layer marker again
                        if (printPart.includes('G1 Z5 F300') || printPart.includes('M17 X1.2 Y1.2 Z0.75') || printPart.includes('G90\nM17 X1.2')) {
                            if (DEBUG_MODE) console.warn('WARNING: printPart may still contain old start code! Attempting to fix...');
                            // Try to find where the actual print starts by looking for layer markers
                            const layerMarkerMatch = printPart.match(/; (CHANGE_LAYER|LAYER_CHANGE|layer num)/i);
                            if (layerMarkerMatch) {
                                printPart = printPart.substring(layerMarkerMatch.index);
                            }
                        }
                    }
                } else {
                    // If no FEATURE: Custom, keep everything as is
                    setupPart = printGcodeExecutable;
                }
                
                // Store both parts separately so we can insert START_CODE_3MF between them
                printGcodeExecutable = { setup: setupPart, print: printPart };
            }
            
            updateProgress(60, `Generating ${loops} loops...`);
            
            // Extract variable values from CONFIG_BLOCK or G-code
            const variableValues = extractVariableValues(gcodeContent, gcodeConfig);
            
            // Replace variables in START_CODE_3MF with actual values
            const startCodeWithVars = replaceStartCodeVariables(START_CODE_3MF, variableValues);
            
            // Build looped G-code with start code in each loop
            const parts = [];
            parts.push(`; ===== ${LOOPRINT_SIGNATURE} (Start) =====`);
            parts.push(`; Source: ${file.name}`);
            parts.push(`; Loops: ${loops}`);
            parts.push(`; Generated: ${new Date().toISOString()}`);
            parts.push(`; Generated by Looprint`);
            parts.push(`; Contact: Nicki.Andersen@gmail.com`);
            parts.push(`\n`);
            
            for (let i = 1; i <= loops; i++) {
                const loopProgress = 60 + (i / loops) * 30;
                updateProgress(loopProgress, `Generating loop ${i} of ${loops}...`);
                
                parts.push(`; >>> LOOP ${i} / ${loops} <<<`);
                
                if (i === 1) {
                    // First loop: include header and config
                    if (gcodeHeader) {
                        parts.push(gcodeHeader);
                        parts.push('\n');
                    }
                    if (gcodeConfig) {
                        parts.push(gcodeConfig);
                        parts.push('\n');
                    }
                } else {
                    // Subsequent loops: M400 safety wait
                    parts.push("M400 ; Looprint safety: Wait for buffer clear before next loop");
                    parts.push('\n');
                }
                
                // Add setup part (EXECUTABLE_BLOCK_START, setup commands, FEATURE: Custom)
                if (typeof printGcodeExecutable === 'object' && printGcodeExecutable.setup) {
                    parts.push(printGcodeExecutable.setup);
                    parts.push('\n');
                    
                    // Add start code for each loop (AFTER FEATURE: Custom, BEFORE print G-code)
                    // Use startCodeWithVars which has variables replaced with actual values
                    parts.push(startCodeWithVars);
                    parts.push('\n');
                    
                    // Ensure temperature is set correctly after start code
                    // startCodeWithVars should already have correct temperature, but add safety check
                    if (printGcodeExecutable.print) {
                        // Check if print G-code starts with layer marker (no temp commands)
                        const printStart = printGcodeExecutable.print.trim();
                        if (printStart.match(/^;LAYER_CHANGE|^; layer|^;LAYER/i)) {
                            // Print starts directly with layer marker - ensure temp is set
                            // startCodeWithVars should already set temp, but add explicit command if we have the value
                            if (variableValues['nozzle_temperature_initial_layer']) {
                                parts.push(`; Ensure nozzle temperature is set for printing\n`);
                                parts.push(`M104 S${variableValues['nozzle_temperature_initial_layer']} ; Set nozzle temp for printing\n`);
                                parts.push('\n');
                            }
                        }
                        parts.push(printGcodeExecutable.print);
                        parts.push('\n');
                    }
                } else {
                    // Fallback: if structure is different, use as string
                    // Check if START_CODE_3MF already exists to prevent duplication
                    const printGcodeStr = typeof printGcodeExecutable === 'string' ? printGcodeExecutable : String(printGcodeExecutable);
                    if (!printGcodeStr.includes('machine: P1S') && !printGcodeStr.includes('FactorianDesigns')) {
                        // Original start code not found, safe to add
                        parts.push(printGcodeExecutable);
                        parts.push('\n');
                        parts.push(startCodeWithVars);
                        parts.push('\n');
                    } else {
                        // Start code already present, don't duplicate
                        parts.push(printGcodeExecutable);
                        parts.push('\n');
                    }
                }
                
                // Add end code (push-off)
                parts.push(activeEndCode);
                parts.push('\n');
            }
            
            parts.push(`; >>> END OF PRINT LOOPS <<<`);
            parts.push(`; ===== ${LOOPRINT_SIGNATURE} (End) =====`);
            
            updateProgress(95, "Repacking 3MF file...");
            
            // Replace G-code in zip
            const modifiedGcode = parts.join('\n');
            zip.file(gcodePath, modifiedGcode);
            
            // Generate new 3MF file
            updateProgress(97, "Generating final 3MF file...");
            const blob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 }
            });
            
            finalFileContent = blob;
            
            updateProgress(100, "Complete!");
            setLoadingState(false);
            
            const outputEl = DOM.output || document.getElementById("output");
            outputEl.style.display = "block";
            document.getElementById("statSourceName").textContent = file.name;
            showStatus("outputReady", "success");
            
            setTimeout(() => updateProgress(0), 500);
            outputEl.scrollIntoView({ behavior: 'smooth' });
            
        } catch (error) {
            setLoadingState(false);
            let errorMessage = "Error processing 3MF file: " + (error.message || "Unknown error");
            
            if (error.message && error.message.includes("JSZip")) {
                errorMessage = "Error: JSZip library failed to load. Please refresh the page.";
            }
            
            showStatus("validationErrorParse", "error", errorMessage);
            if (DEBUG_MODE) console.error("Critical error during 3MF file processing:", error);
        }
    }
    // --- SLUT P√Ö process3MFFile() FUNKTION ---
    
    /**
     * Sanitizes filename to prevent security issues
     * @param {string} filename - Original filename
     * @returns {string} Sanitized filename
     */
    function sanitizeFilename(filename) {
        // Remove or replace dangerous characters
        return filename
            .replace(/[<>:"/\\|?*]/g, '_')  // Replace dangerous chars with underscore
            .replace(/\.\./g, '_')           // Remove parent directory references
            .replace(/^\.+|\.+$/g, '')       // Remove leading/trailing dots
            .trim()
            .substring(0, 200);              // Limit length
    }

    /**
     * Downloads the generated looped file (G-code or 3MF)
     * Filename is sanitized for security
     * Handles both string and Blob content
     * Uses try/finally to ensure URL cleanup (prevents memory leaks)
     */
    async function downloadFile() {
        if (!finalFileContent) return;
        
        let blob;
        
        if (currentFileType === "3mf") {
            // For 3MF files, ensure correct MIME type to prevent browser from auto-unzipping
            if (finalFileContent instanceof Blob) {
                // Recreate blob with correct MIME type
                const arrayBuffer = await finalFileContent.arrayBuffer();
                blob = new Blob([arrayBuffer], { type: "model/3mf" });
            } else {
                // Should not happen for 3MF, but handle it
                blob = new Blob([finalFileContent], { type: "model/3mf" });
            }
        } else {
            // For G-code files
            blob = finalFileContent instanceof Blob 
                ? finalFileContent 
                : new Blob([finalFileContent], { type: "text/plain" });
        }
        
        let url = null;
        try {
            url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        
            // Use cached DOM element if available, otherwise query
            const loopCountEl = DOM.loopCount || document.getElementById("loopCount");
            let filename = `${originalFilename}_Looprint_x${loopCountEl.value}`;
        
        if (currentFilamentUsage) {
            filename += `_${currentFilamentUsage}g`;
        }
        
            filename += currentFileType === "3mf" ? ".3mf" : ".gcode";
        
            // Sanitize filename before download to prevent security issues
            a.download = sanitizeFilename(filename);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        } finally {
            // Always revoke URL to prevent memory leaks
            if (url) {
        URL.revokeObjectURL(url);
            }
        }
    }

    /**
     * Copies code to clipboard using modern Clipboard API
     * Falls back to execCommand for older browsers
     * @param {string} id - ID of textarea element to copy from
     */
    async function copyCode(id) {
        const el = document.getElementById(id);
        const textToCopy = el.value;
        
        try {
            // Try modern Clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(textToCopy);
            showStatus('copySuccess', 'success');
            } else {
                // Fallback to execCommand for older browsers
                el.select();
                el.setSelectionRange(0, 99999); // For mobile devices
                const successful = document.execCommand("copy");
                if (successful) {
                    showStatus('copySuccess', 'success');
                } else {
                    throw new Error('execCommand failed');
                }
            }
        } catch (err) {
            if (DEBUG_MODE) console.error('Failed to copy:', err);
            showStatus('copyError', 'error');
        }
    }

    /**
     * Applies Z offset value with validation
     */
    /**
     * Updates push lane offset and validates against model placement
     * Shows warning if offset is auto-adjusted and displays maximum possible offset
     */
    function updatePushLaneOffset() {
        try {
            const inputEl = document.getElementById("pushLaneOffsetInput");
            if (!inputEl) {
                if (DEBUG_MODE) console.warn("pushLaneOffsetInput element not found");
                return;
            }
            
            const val = parseFloat(inputEl.value);
            const statusEl = document.getElementById("pushLaneOffsetStatus");
            const maxInfoEl = document.getElementById("pushLaneOffsetMaxInfo");
            
            // Validate input range
            if (isNaN(val) || val < MIN_PUSH_LANE_OFFSET || val > MAX_PUSH_LANE_OFFSET) {
                if (statusEl) {
                    statusEl.textContent = `Invalid range. Must be between ${MIN_PUSH_LANE_OFFSET}mm and ${MAX_PUSH_LANE_OFFSET}mm.`;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.style.display = "none";
                }
                return;
            }
            
            // Calculate dynamic coordinates to check for warnings
            const dynamicCoords = calculateDynamicPushCoordinates(val);
            
            if (dynamicCoords) {
                // Show maximum possible offset info
                if (maxInfoEl) {
                    maxInfoEl.textContent = `Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm`;
                    maxInfoEl.style.display = "block";
                }
                
                // Show warning if offset was auto-adjusted
                if (statusEl) {
                    if (dynamicCoords.warning) {
                        statusEl.textContent = dynamicCoords.warning;
                        statusEl.style.color = "var(--danger)";
                        statusEl.style.display = "block";
                    } else {
                        statusEl.textContent = `Offset set to ${val}mm. Left lane: X${dynamicCoords.leftX}, Right lane: X${dynamicCoords.rightX}`;
                        statusEl.style.color = "var(--accent)";
                        statusEl.style.display = "block";
                    }
                }
            } else {
                // No model data available yet
                if (statusEl) {
                    statusEl.textContent = `Offset set to ${val}mm. Will be validated when file is uploaded.`;
                    statusEl.style.color = "var(--accent)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.style.display = "none";
                }
            }
            
            // Update end code textareas
            updateEndCodeTextareas();
            saveSettings();
            
            // Clear status after 5 seconds
            setTimeout(() => {
                if (statusEl && !dynamicCoords?.warning) {
                    statusEl.style.display = "none";
                }
            }, 5000);
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in updatePushLaneOffset:", error);
            const statusEl = document.getElementById("pushLaneOffsetStatus");
            if (statusEl) {
                statusEl.textContent = "Error updating offset. Please try again.";
                statusEl.style.color = "var(--danger)";
                statusEl.style.display = "block";
            }
        }
    }
    
    function applyOffset() {
        const val = parseFloat(document.getElementById("zOffsetInput").value);
        const statusEl = document.getElementById("zOffsetStatus"); 
        const dict = LANG.en;

        if (isNaN(val) || val < MIN_OFFSET || val > MAX_OFFSET) {
            statusEl.textContent = dict.zOffsetErrorRange;
            statusEl.style.color = "var(--danger)";
            statusEl.style.display = "block";
            return;
        }

        currentOffset = val;
        document.getElementById("bedOffsetDisplay").textContent = val;
        updateEndCodeTextareas();
        saveSettings();
        
        statusEl.textContent = dict.zOffsetApplied;
        statusEl.style.color = "var(--accent)";
        statusEl.style.display = "block";
        setTimeout(() => { 
            if (statusEl.textContent === dict.zOffsetApplied) statusEl.style.display = 'none'; 
        }, 3000);
    }

    /**
     * Gets cooldown temperature from input, with validation
     * @returns {number} Validated temperature value
     */
    function getCooldownTemp() {
        let val = parseInt(document.getElementById("cooldownTempInput").value, 10);
        return (isNaN(val) || val < MIN_TEMP) ? DEFAULT_TEMP : val;
    }

    /**
     * Checks and displays warning if cooldown temperature is too high
     */
    function checkCooldownWarning() {
        const val = parseInt(document.getElementById("cooldownTempInput").value, 10);
        const el = document.getElementById("cooldownWarningMessage");
        const dict = LANG.en;
        
        if (!isNaN(val) && val >= COOLDOWN_WARNING_THRESHOLD) {
            el.textContent = dict.cooldownRiskWarning;
            el.style.display = "block";
        } else {
            el.style.display = "none";
        }
    }
    
    /**
     * Shows status message to user
     * @param {string} key - Language key for message
     * @param {string} type - Message type: 'error' or 'success'
     * @param {string} directMsg - Optional direct message (overrides key)
     */
    function showStatus(key, type = "error", directMsg = null) {
        const el = document.getElementById("statusMessage");
        const dict = LANG.en;
        const msg = directMsg || dict[key] || key;
        
        el.style.display = "block";
        el.textContent = msg;
        el.style.color = (type === "error") ? "var(--danger)" : "var(--accent)";
    }

    function clearStatus() {
        document.getElementById("statusMessage").style.display = "none";
    }
    
    /**
     * Sets loading state for file processing
     * @param {boolean} isLoading - Whether loading is active
     * @param {string} message - Optional loading message
     */
    function setLoadingState(isLoading, message = "Processing file, please wait...") {
        const generateBtn = DOM.generateBtn || document.getElementById("generateBtn");
        const statusEl = document.getElementById("statusMessage");
        const loadingContainer = document.getElementById("loadingContainer");
        const progressText = document.getElementById("progressText");
        
        if (isLoading) {
            generateBtn.disabled = true;
            const originalText = generateBtn.textContent;
            generateBtn.setAttribute('data-original-text', originalText);
            generateBtn.textContent = "Generating...";
            statusEl.textContent = message;
            statusEl.style.display = "block";
            statusEl.style.color = "var(--accent)";
            loadingContainer.classList.add('active');
            progressText.textContent = message;
        } else {
            generateBtn.disabled = false;
            const originalText = generateBtn.getAttribute('data-original-text') || LANG.en.generateBtn;
            generateBtn.textContent = originalText;
            loadingContainer.classList.remove('active');
            document.getElementById("progressBar").style.width = "0%";
        }
    }
    
    /**
     * Updates progress bar during file processing
     * @param {number} percent - Progress percentage (0-100)
     * @param {string} message - Optional progress message
     */
    function updateProgress(percent, message = null) {
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        
        progressBar.style.width = Math.min(100, Math.max(0, percent)) + "%";
        if (message) {
            progressText.textContent = message;
        }
    }

    const RAW_P1_END_CODE_TEMPLATE = `;===== date: 20230428 ===================== Made by FactorianDesigns, please completely watch the related Youtube video before you try this out
M400 ; wait for buffer to clear
G92 E0 ; zero the extruder
G1 E-0.8 F1800 ; retract
G1 Z{max_layer_z + 0.5} F900 ; lower z a little
G1 X65 Y245 F12000 ; move to safe pos
G1 Y265 F3000

G1 X65 Y245 F12000
G1 Y265 F3000
M140 S0 ; turn off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan

G1 X100 F12000 ; wipe
; pull back filament to AMS
M620 S255
G1 X20 Y50 F12000
G1 Y-3
T255
G1 X65 F12000
G1 Y265
G1 X100 F12000 ; wipe
M621 S255
M104 S0 ; turn off hotend

M622.1 S1 ; for prev firware, default turned on
M1002 judge_flag timelapse_record_flag
M622 J1
    M400 ; wait all motion done
    M991 S0 P-1 ;end smooth timelapse at safe pos
    M400 S3 ;wait for last picture to be taken
M623; end of "timelapse_record_flag"

M400 ; wait all motion done
M17 S
;M17 Z0.4 ; lower z motor current to reduce impact if there is something in the bottom
;{if (max_layer_z + 100.0) < 250}
;    G1 Z{max_layer_z + 100.0} F600
;    G1 Z{max_layer_z +98.0}
;{else}
;    G1 Z250 F600
;    G1 Z248
;{endif}
;M400 P100
;M17 R ; restore z current
                                
; ====== Cool Down =====
M400 				;wait for all print moves to be done											 
M17 Z0.4 			;lower z motor current to reduce impact if there is something in the top																					
G1 Z1 F600 			;move nozzle up, BE VERY CAREFUL this can hit the top of your print, extruder or AMS
M400				;wait all motion done
M106 P2 S255 		;turn Aux fan on
M106 P3 S200 		;turn on chamber cooling fan

M190 S18 ; wait for bed temp, Enter your own target cooldown temperatur here (-3 ¬∞C because printer stops cooling down earlier at low temps, here the target temp is 23 ¬∞C)
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp 
M190 S18 ; wait for bed temp, total max wait time of all lines = 60 min 
                            
M106 P2 S0 					;turn off Aux fan 
M106 P3 S0					;turn off chamber cooling fan 
                            
;=== Cool Down Done, Start Push Off ===  !!! CAREFUL !!! You have to enter your own print specific coordinates here, or this will damage your printer !!!  
;!!! CAREFUL !!! You have to enter your own print specific coordinates below, or this will damage your printer !!!
; if you push off multiple objects then always start from right to left so you don't hit your LIDAR, this only works with small objects 
; The following lines lower the bed to initiate the push off
; Bed is lowered by 110mm from model height to ensure model top has adequate clearance from printer edge
; This ensures front shield can push model while preventing model top from hitting printer edge

M400
{if (max_layer_z ) > 31}
    G1 Z{max_layer_z - 30} F600
{else}
    G1 Z1 F600
{endif}
M400 P100

;G1 Z1 F600 			; Alternative to z moves lines above

G1 X170 Y254 F600		; move nozzle a little to the side for safety
M400				; Wait all motion done
G1 X120 Y230 F1200 		; take start middle push off position, -8mm in x from center of the print is the center of the toolhead  
G1 X120 Y25 F300		; Very slowly push off

;====Push off complete, start safety clear ==== You can enter your own specific coordinates here as well or erase this part if not wanted

;G1 z1 F600			;uncomment this if you want to do the safety clear at a different height
G1 X120 Y200 F2000 	;take start push off position at back
G1 X180 Y200 F2000 	;move to the right
G1 X180 Y25 F2000 	;push off at right position

G1 X180 Y200 F2000 	;take start push off position at back
G1 X60 Y200 F2000 	;move to the left
G1 X60 Y25 F2000 	;push off at left position

;==== safety clear complete ====
                    
M220 S100  ; Reset feedrate magnitude
M201.2 K1.0 ; Reset acc magnitude
M73.2   R1.0 ;Reset left time magnitude
M1002 set_gcode_claim_speed_level : 0

M17 X0.8 Y0.8 Z0.5 ; lower motor current to 45% power
`;

    /**
     * Uses Factorian's original method for Z-offset calculation
     * Simple and proven method from Factorian Designs
     * 
     * Factorian's original method:
     * - If max_layer_z > 31mm: G1 Z{max_layer_z - 30}
     * - Else: G1 Z1
     * 
     * @returns {Object} { zOffset: number, threshold: number, method: string }
     */
    function calculateOptimalZOffset() {
        // Factorian's original method - simple and proven
        const FACTORIAN_THRESHOLD = 31; // mm - Factorian's threshold
        const FACTORIAN_OFFSET = 30; // mm - Factorian's offset for models > 31mm
        
        return {
            zOffset: FACTORIAN_OFFSET,
            threshold: FACTORIAN_THRESHOLD,
            method: "Factorian original"
        };
    }

    /**
     * Generates end G-code with push-off sequence
     * @param {number} offset - Z push offset in mm (legacy parameter, now calculated automatically)
     * @param {number} temp - Target bed temperature
     * @param {number} xStart - Starting X position
     * @param {number} xLane1 - First push lane X position
     * @param {number} xLane2 - Second push lane X position
     * @returns {string} Generated end G-code
     */
    /**
     * Generates end code with dynamic multi-lane push-off system
     * @param {number} offset - Z offset for bed lowering
     * @param {number} temp - Cooldown temperature
     * @param {number} xStart - Safe X position (to the side)
     * @param {number} xLeft - Left push lane X coordinate (center - 30mm)
     * @param {number} xCenter - Center push lane X coordinate (model center)
     * @param {number} xRight - Right push lane X coordinate (center + 30mm)
     * @returns {string} Generated end code
     */
    function getEndCode(offset, temp, xStart, xLeft, xCenter, xRight) {
        try {
            // Validate inputs
            offset = parseFloat(offset) || DEFAULT_OFFSET;
            temp = parseFloat(temp) || DEFAULT_TEMP;
            xStart = parseFloat(xStart);
            xLeft = parseFloat(xLeft);
            xCenter = parseFloat(xCenter);
            xRight = parseFloat(xRight);
            
            if (isNaN(offset) || isNaN(temp) || isNaN(xStart) || isNaN(xLeft) || isNaN(xCenter) || isNaN(xRight)) {
                if (DEBUG_MODE) console.error("Invalid parameters in getEndCode:", { offset, temp, xStart, xLeft, xCenter, xRight });
                // Use safe defaults
                offset = DEFAULT_OFFSET;
                temp = DEFAULT_TEMP;
                xStart = 128;
                xLeft = 98;
                xCenter = 128;
                xRight = 158;
            }
            
            // Use Factorian's original method - template already has correct logic
            // No need to call calculateOptimalZOffset() as template is unchanged
            let code = RAW_P1_END_CODE_TEMPLATE;

            const targetActualTemp = temp + 5;
            code = code.replace(/M190 S18/g, `M190 S${temp}`);
            
            // Replace temperature placeholder in end code template
            code = code.replace(
                /(here the target temp is )[^)]*( ¬∞C)/, 
                `here the target temp is ${targetActualTemp} ¬∞C`
            );

            // Use Factorian's original method - no changes needed
            // Template already has: {if (max_layer_z ) > 31}
            //                    G1 Z{max_layer_z - 30} F600
            //                    {else}
            //                    G1 Z1 F600
            //                    {endif}
            // We keep this exactly as Factorian designed it
            
            const PUSH_BLOCK_START = "G1 X170 Y254 F600		; move nozzle a little to the side for safety";
            const SAFETY_CLEAR_START = ";====Push off complete, start safety clear ====";
            const SAFETY_CLEAR_END = ";==== safety clear complete ====";
            
            const startIdx = code.indexOf(PUSH_BLOCK_START);
            const safetyClearStartIdx = code.indexOf(SAFETY_CLEAR_START);
            const safetyClearEndIdx = code.indexOf(SAFETY_CLEAR_END);
            
            // Replace original Push/Clear block with Dynamic Multi-Lane Push system
            // Three push lanes: Center (model center), Left (center - 30mm), Right (center + 30mm)
            // Push order: Center first (main force), then Left, then Right (for stability)
            
            const MULTI_LANE_PUSH_REPLACEMENT = `G1 X${xStart} Y254 F600		; move nozzle a little to the side for safety
M400				; Wait all motion done
; --- DYNAMIC MULTI-LANE PUSH SYSTEM (Looprint) ---
; Model center calculated from G-code: X${xCenter}
; Left lane: X${xLeft} (center - 30mm), Right lane: X${xRight} (center + 30mm)

; --- PUSH LANE 1: CENTER (Primary push force at model center) ---
G1 X${xCenter} Y230 F1200 	; take start position at model center
G1 X${xCenter} Y5 F300		; Push center lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety

; --- PUSH LANE 2: LEFT (30mm left of center for stability) ---
G1 X${xLeft} Y230 F1200 	; take start position at left lane
G1 X${xLeft} Y5 F300		; Push left lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety

; --- PUSH LANE 3: RIGHT (30mm right of center for stability) ---
G1 X${xRight} Y230 F1200 	; take start position at right lane
G1 X${xRight} Y5 F300		; Push right lane (pushed to Y5 for maximum clearance)
G1 Y230 F5000               ; Retract back for safety
`; 

            if (startIdx !== -1 && safetyClearStartIdx !== -1) {
                 const prePush = code.substring(0, startIdx);
                 // Skip safety clear sequence - start after it ends (removes extra push to right and left)
                 const postSafetyClear = safetyClearEndIdx !== -1 
                     ? code.substring(safetyClearEndIdx + SAFETY_CLEAR_END.length)
                     : code.substring(safetyClearStartIdx + SAFETY_CLEAR_START.length); 
                 
                 code = prePush + MULTI_LANE_PUSH_REPLACEMENT + postSafetyClear;
            }

            code = `;===== ${currentDirection.toUpperCase()} PRESET (Offset: ${offset}mm, Temp: ${temp}C, DYNAMIC MULTI-LANE PUSH: Center=${xCenter}, Left=${xLeft}, Right=${xRight}) =====\n` + code;
            
            return code;
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in getEndCode:", error);
            // Return a safe fallback end code
            return RAW_P1_END_CODE_TEMPLATE;
        }
    }

    /**
     * Calculates dynamic push-off coordinates based on model placement
     * @param {number} [offset] - Offset from model center for left/right lanes (default: from input)
     * @returns {Object|null} { centerX, leftX, rightX, safeX, adjustedOffset, maxPossibleOffset, warning } or null if no model data
     */
    function calculateDynamicPushCoordinates(offset = null) {
        try {
            // Check if we have model placement data
            if (!lastDebugData || !lastDebugData.minX || !lastDebugData.maxX) {
                return null;
            }
            
            // Validate model data
            const minX = parseFloat(lastDebugData.minX);
            const maxX = parseFloat(lastDebugData.maxX);
            if (isNaN(minX) || isNaN(maxX) || minX < 0 || maxX < 0 || minX >= maxX) {
                if (DEBUG_MODE) console.warn("Invalid model placement data:", { minX, maxX });
                return null;
            }
            
            // Get offset from input if not provided
            if (offset === null) {
                const offsetInput = document.getElementById("pushLaneOffsetInput");
                if (offsetInput) {
                    offset = parseFloat(offsetInput.value);
                    if (isNaN(offset) || offset < MIN_PUSH_LANE_OFFSET || offset > MAX_PUSH_LANE_OFFSET) {
                        offset = DEFAULT_PUSH_LANE_OFFSET;
                    }
                } else {
                    offset = DEFAULT_PUSH_LANE_OFFSET;
                }
            }
            
            // Validate provided offset
            if (isNaN(offset) || offset < MIN_PUSH_LANE_OFFSET || offset > MAX_PUSH_LANE_OFFSET) {
                offset = DEFAULT_PUSH_LANE_OFFSET;
            }
            
            // Calculate model center
            const centerX = (minX + maxX) / 2;
            
            // Validate and clamp offset to safe range
            let safeOffset = Math.max(MIN_PUSH_LANE_OFFSET, Math.min(MAX_PUSH_LANE_OFFSET, offset));
            
            // Calculate maximum possible offset based on model placement
            const maxOffsetLeft = centerX - BED_MIN_X;   // How far left we can go from center
            const maxOffsetRight = BED_MAX_X - centerX; // How far right we can go from center
            const maxPossibleOffset = Math.min(maxOffsetLeft, maxOffsetRight);
            
            // Auto-adjust if offset is too large for this model placement
            let adjustedOffset = safeOffset;
            let warning = null;
            if (safeOffset > maxPossibleOffset) {
                adjustedOffset = maxPossibleOffset;
                warning = `Offset auto-adjusted from ${safeOffset.toFixed(1)}mm to ${adjustedOffset.toFixed(1)}mm to prevent collision. Maximum safe offset for this model: ${maxPossibleOffset.toFixed(1)}mm.`;
            }
            
            // Calculate three push lanes: center, left (center - offset), right (center + offset)
            const leftX = Math.max(BED_MIN_X, centerX - adjustedOffset);  // Ensure minimum from left edge
            const rightX = Math.min(BED_MAX_X, centerX + adjustedOffset); // Ensure maximum from left edge
            
            // Calculate safe position based on model placement (most reliable approach)
            // Safety position should always be AWAY from the model to prevent collisions
            // Bed center is approximately 128mm (256mm / 2)
            const BED_CENTER_X = 128;
            
            let safeX;
            if (centerX < BED_CENTER_X) {
                // Model is on left side of bed - place safety position to the LEFT of model
                safeX = Math.max(BED_MIN_X, minX - 20);
            } else {
                // Model is on right side or center of bed - place safety position to the RIGHT of model
                safeX = Math.min(BED_MAX_X, maxX + 20);
            }
            
            // Additional safety check: Ensure safeX is not too close to any push lane
            // Minimum 10mm clearance from push lanes
            const minSafeDistance = 10;
            if (Math.abs(safeX - leftX) < minSafeDistance || 
                Math.abs(safeX - centerX) < minSafeDistance || 
                Math.abs(safeX - rightX) < minSafeDistance) {
                // If too close, move further away
                if (centerX < BED_CENTER_X) {
                    safeX = Math.max(BED_MIN_X, minX - 30);
                } else {
                    safeX = Math.min(BED_MAX_X, maxX + 30);
                }
            }
            
            return {
                centerX: centerX.toFixed(1),
                leftX: leftX.toFixed(1),
                rightX: rightX.toFixed(1),
                safeX: safeX.toFixed(1),
                adjustedOffset: adjustedOffset.toFixed(1),
                maxPossibleOffset: maxPossibleOffset.toFixed(1),
                warning: warning
            };
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in calculateDynamicPushCoordinates:", error);
            return null;
        }
    }

    /**
     * Updates start code textarea with variable replacement
     * @param {string|null} gcodeContent - G-code content to extract variables from, or null to show template
     */
    function updateStartCodeTextarea(gcodeContent) {
        try {
            const startCodeTextarea = document.getElementById("startCode");
            if (!startCodeTextarea) return; // Element doesn't exist if advanced settings not visible
            
            // If no G-code content provided, show template
            if (!gcodeContent) {
                startCodeTextarea.value = START_CODE_3MF;
                return;
            }
            
            // Parse G-code structure to get config block
            const structure = parseGcodeStructure(gcodeContent);
            const gcodeConfig = structure.config || '';
            
            // Extract variable values
            const variableValues = extractVariableValues(gcodeContent, gcodeConfig);
            
            // Replace variables in start code
            const startCodeWithVars = replaceStartCodeVariables(START_CODE_3MF, variableValues);
            
            // Update textarea
            startCodeTextarea.value = startCodeWithVars;
        } catch (error) {
            if (DEBUG_MODE) console.error("Error updating start code textarea:", error);
            // If error, show template without variable replacement
            const startCodeTextarea = document.getElementById("startCode");
            if (startCodeTextarea) {
                startCodeTextarea.value = START_CODE_3MF;
            }
        }
    }

    /**
     * Updates all end code textareas with current settings
     * Uses dynamic push coordinates based on model placement if available
     */
    function updateEndCodeTextareas() {
        const off = currentOffset;
        const temp = getCooldownTemp();
        
        const originalDirection = currentDirection;
        
        // Try to get dynamic coordinates from model placement
        const dynamicCoords = calculateDynamicPushCoordinates();
        
        if (dynamicCoords) {
            // Use dynamic coordinates based on actual model placement
            // All directions use the same calculated coordinates (center, left, right lanes)
            
            // Show warning if offset was auto-adjusted
            if (dynamicCoords.warning) {
                const statusEl = document.getElementById("pushLaneOffsetStatus");
                const maxInfoEl = document.getElementById("pushLaneOffsetMaxInfo");
                if (statusEl) {
                    statusEl.textContent = dynamicCoords.warning;
                    statusEl.style.color = "var(--danger)";
                    statusEl.style.display = "block";
                }
                if (maxInfoEl) {
                    maxInfoEl.textContent = `Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm`;
                    maxInfoEl.style.display = "block";
                }
            }
            
            currentDirection = 'center';
            document.getElementById("endCenterCode").value = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
            
            currentDirection = 'right';
            document.getElementById("endRightCode").value = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
            
            currentDirection = 'left';
            document.getElementById("endLeftCode").value = getEndCode(off, temp, 
                parseFloat(dynamicCoords.safeX),
                parseFloat(dynamicCoords.leftX),
                parseFloat(dynamicCoords.centerX),
                parseFloat(dynamicCoords.rightX)
            );
        } else {
            // Fallback to hardcoded coordinates if no model data available
            // CENTER (40mm separation): X108, X148
            currentDirection = 'center'; 
            document.getElementById("endCenterCode").value = getEndCode(off, temp, 
                170, 
                108, 148, 148
            ); 

            // RIGHT (40mm separation): X180, X220
            currentDirection = 'right';
            document.getElementById("endRightCode").value = getEndCode(off, temp, 
                220, 
                180, 220, 220
            ); 
                
            // LEFT (40mm separation): X30, X70
            currentDirection = 'left';
            document.getElementById("endLeftCode").value = getEndCode(off, temp, 
                36, 
                30, 70, 70
            );
        }
            
        currentDirection = originalDirection;
        selectDirection(currentDirection, false); 
    }

    /**
     * Shows info dialog about test file before generating
     * Handles both G-code and 3MF files
     */
    async function showTestFileInfo() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) {
            showStatus("fileError", "error");
            return;
        }

        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        let content = null;
        
        try {
            if (is3MF) {
                // For 3MF files, unzip and extract G-code
                if (typeof JSZip === 'undefined') {
                    alert("Error: JSZip library not loaded. Please refresh the page.");
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Find G-code file
                const gcodeFiles = [];
                zip.forEach((relativePath) => {
                    if (relativePath.match(/^Metadata\/plate_\d+\.gcode$/i)) {
                        gcodeFiles.push(relativePath);
                    }
                });
                
                if (gcodeFiles.length === 0) {
                    alert("Error: No G-code file found in 3MF.");
                    return;
                }
                
                content = await zip.file(gcodeFiles[0]).async('string');
            } else {
                // For G-code files, read directly
                content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            // Extract model height from G-code header
            const maxZMatch = content.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let modelHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                modelHeight = parseFloat(maxZMatch[1]);
            }

            if (!modelHeight || modelHeight <= 0) {
                alert("Could not detect model height from G-code header. Please ensure the file contains 'max_z_height' in the header.");
                return;
            }

            // Calculate bed position
            let bedZ;
            if (modelHeight > 31) {
                bedZ = modelHeight - 30;
            } else {
                bedZ = 1;
            }

            const directionNames = { left: "Left", center: "Center", right: "Right" };
            const directionName = directionNames[currentDirection] || currentDirection;

            const message = `Test File Information:

This will generate a simple test file that:
‚Ä¢ Moves hotend to safe position
‚Ä¢ Lowers bed to ${bedZ.toFixed(2)}mm (Factorian method: ${modelHeight.toFixed(2)}mm - 30mm)
‚Ä¢ Performs push-off from ${directionName} side (outer lane first, then inner lane)

The test file does NOT include:
‚Ä¢ Print G-code
‚Ä¢ Cooldown sequence
‚Ä¢ Multiple loops

Use this to test if the push-off height is correct before running the full looped print.

Model height: ${modelHeight.toFixed(2)}mm
Push direction: ${directionName}
Bed will lower to: Z${bedZ.toFixed(2)}

Generate test file?`;

            if (confirm(message)) {
                generateTestFile();
            }
        } catch (error) {
            if (DEBUG_MODE) console.error("Error reading file for test info:", error);
            alert("Error reading file: " + error.message);
        }
    }

    /**
     * Generates a test file for push-off testing
     * Creates a simple G-code file that only performs push-off sequence
     * Based on the uploaded file's model height and selected push direction
     */
    /**
     * Generates a test G-code file for push-off testing
     * Validates direction and extracts model height from G-code header
     * Creates a minimal test file with only push-off sequence
     * Handles both G-code and 3MF files
     */
    async function generateTestFile() {
        const fileInput = DOM.fileInput || document.getElementById("fileInput");
        if (!fileInput.files.length) {
            showStatus("fileError", "error");
            return;
        }

        const file = fileInput.files[0];
        const is3MF = file.name.toLowerCase().endsWith('.3mf');
        
        let content = null;
        
        try {
            if (is3MF) {
                // For 3MF files, unzip and extract G-code
                if (typeof JSZip === 'undefined') {
                    alert("Error: JSZip library not loaded. Please refresh the page.");
                    return;
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Find G-code file
                const gcodeFiles = [];
                zip.forEach((relativePath) => {
                    if (relativePath.match(/^Metadata\/plate_\d+\.gcode$/i)) {
                        gcodeFiles.push(relativePath);
                    }
                });
                
                if (gcodeFiles.length === 0) {
                    alert("Error: No G-code file found in 3MF.");
                    return;
                }
                
                content = await zip.file(gcodeFiles[0]).async('string');
            } else {
                // For G-code files, read directly
                content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            // Extract model height from G-code header
            const maxZMatch = content.match(/;\s*max_z_height\s*[:=]\s*([\d\.]+)/i);
            let modelHeight = null;
            if (maxZMatch && maxZMatch[1]) {
                modelHeight = parseFloat(maxZMatch[1]);
            }

            if (!modelHeight || modelHeight <= 0) {
                alert("Could not detect model height from G-code header. Please ensure the file contains 'max_z_height' in the header.");
                return;
            }

            // Validate push direction (edge case #15)
            const validDirections = ['left', 'center', 'right'];
            if (!validDirections.includes(currentDirection)) {
                alert(`Invalid push direction: ${currentDirection}. Please select a valid direction.`);
                return;
            }
            
            // Get push lane offset from input
            const pushLaneOffsetInput = document.getElementById("pushLaneOffsetInput");
            const pushLaneOffset = pushLaneOffsetInput ? (parseFloat(pushLaneOffsetInput.value) || DEFAULT_PUSH_LANE_OFFSET) : DEFAULT_PUSH_LANE_OFFSET;
            
            // Get dynamic push coordinates if available, otherwise use fallback
            let xStart, xLeft, xCenter, xRight;
            const dynamicCoords = calculateDynamicPushCoordinates(pushLaneOffset);
            
            if (dynamicCoords) {
                // Use dynamic coordinates based on actual model placement
                xStart = parseFloat(dynamicCoords.safeX);
                xLeft = parseFloat(dynamicCoords.leftX);
                xCenter = parseFloat(dynamicCoords.centerX);
                xRight = parseFloat(dynamicCoords.rightX);
            } else {
                // Fallback to hardcoded coordinates if no model data
                if (currentDirection === 'center') {
                    xStart = 170;
                    xLeft = 108;
                    xCenter = 128;
                    xRight = 148;
                } else if (currentDirection === 'right') {
                    xStart = 220;
                    xLeft = 180;
                    xCenter = 200;
                    xRight = 220;
                } else { // left
                    xStart = 36;
                    xLeft = 30;
                    xCenter = 50;
                    xRight = 70;
                }
            }

            // Calculate bed position using Factorian's method
            let bedZ;
            if (modelHeight > 31) {
                bedZ = modelHeight - 30; // Factorian's method
            } else {
                bedZ = 1; // Minimum safe position
            }

            // Generate test file with dynamic multi-lane push system
            const testCode = `; Test G-code for push-off testing (Dynamic Multi-Lane Push System)
            ; Model height: ${modelHeight.toFixed(2)}mm (max_layer_z = ${modelHeight.toFixed(2)})
            ; Push direction: ${currentDirection.toUpperCase()}
            ${dynamicCoords ? `; Dynamic coordinates calculated from model placement:
            ; Model center: X${xCenter} (calculated from minX=${lastDebugData.minX.toFixed(1)}, maxX=${lastDebugData.maxX.toFixed(1)})
            ; Push lane offset: ${pushLaneOffset}mm (${dynamicCoords.adjustedOffset !== pushLaneOffset.toFixed(1) ? `auto-adjusted from ${pushLaneOffset}mm to ${dynamicCoords.adjustedOffset}mm` : 'as set'})
            ; Left lane: X${xLeft} (center - ${dynamicCoords.adjustedOffset}mm)
            ; Right lane: X${xRight} (center + ${dynamicCoords.adjustedOffset}mm)
            ${dynamicCoords.maxPossibleOffset ? `; Maximum safe offset for this model: ${dynamicCoords.maxPossibleOffset}mm` : ''}` : `; Using fallback coordinates (no model placement data available)
            ; Push lane offset: ${pushLaneOffset}mm`}
            ; 
            ; Factorian's original method:
            ; - If max_layer_z > 31: G1 Z{max_layer_z - 30}
            ; - Else: G1 Z1
            ; 
            ; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 31 ? `${modelHeight.toFixed(2)} > 31` : `${modelHeight.toFixed(2)} <= 31`} ‚Üí G1 Z${bedZ.toFixed(2)}
            ; This lowers bed from ${modelHeight.toFixed(2)}mm to ${bedZ.toFixed(2)}mm (${(modelHeight - bedZ).toFixed(2)}mm lower)

            ; Initialize
            G28 ; Home all axes
            G90 ; Absolute positioning
            G21 ; Set units to millimeters

            ; CRITICAL STEP 1: Move hotend to safe position AND safe Z height
            ; Move hotend AWAY from print (to safe X/Y position)
            G1 X65 Y245 F12000 ; Move to safe X/Y position (away from print)
            G1 Y265 F3000
            ; CRITICAL: Move hotend UP to safe Z height BEFORE lowering bed
            ; Hotend must be HIGHER than model (${modelHeight.toFixed(2)}mm) + safety margin
            G1 Z${Math.max(150, modelHeight + 20).toFixed(0)} F600 ; Move hotend to safe Z height (above ${modelHeight.toFixed(2)}mm model)
            M400 ; Wait for motion to complete

            ; CRITICAL STEP 2: Lower bed using Factorian's original method
            ; Factorian's logic: {if (max_layer_z ) > 31}
            ;                    G1 Z{max_layer_z - 30} F600
            ;                    {else}
            ;                    G1 Z1 F600
            ;                    {endif}
            ; 
            ; For ${modelHeight.toFixed(2)}mm model: ${modelHeight > 31 ? `${modelHeight.toFixed(2)} > 31` : `${modelHeight.toFixed(2)} <= 31`} ‚Üí G1 Z${bedZ.toFixed(2)}
            ; Since hotend is now at safe height, this is safe
            ; NOTE: In test file, we hardcode the value since max_layer_z is not defined
            ; In actual Looprint-generated code, the IF statement will work correctly
            G1 Z${bedZ.toFixed(2)} F600 ; Factorian method: max_layer_z (${modelHeight.toFixed(2)}) - ${modelHeight > 31 ? '30' : `${modelHeight - 1}`} = ${bedZ.toFixed(2)}
            M400 ; Wait for motion to complete

            ; CRITICAL STEP 3: Move hotend to push-off start position
            ; Now that bed is lowered, hotend can safely move to push position
            G1 X${xStart} Y254 F600 ; Move nozzle a little to the side for safety
            M400 ; Wait all motion done

            ; === DYNAMIC MULTI-LANE PUSH-OFF SEQUENCE ===
            ; Three push lanes ensure centered force regardless of model shape
            
            ; --- PUSH LANE 1: CENTER (Primary push force at model center) ---
            G1 X${xCenter} Y230 F1200 ; Take start position at model center (X=${xCenter})
            G1 X${xCenter} Y5 F300 ; Push center lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety

            ; --- PUSH LANE 2: LEFT (30mm left of center for stability) ---
            G1 X${xLeft} Y230 F1200 ; Take start position at left lane (X=${xLeft}, center - 30mm)
            G1 X${xLeft} Y5 F300 ; Push left lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety

            ; --- PUSH LANE 3: RIGHT (30mm right of center for stability) ---
            G1 X${xRight} Y230 F1200 ; Take start position at right lane (X=${xRight}, center + 30mm)
            G1 X${xRight} Y5 F300 ; Push right lane (slowly, pushed to Y5 for maximum clearance)
            G1 Y230 F5000 ; Retract back for safety

; Return to safe position
G1 X65 Y245 F12000 ; Return to safe position
G1 Y265 F3000

; End
M400 ; Wait for all motion to complete
M30 ; End of program
`;

            // Download the test file (with memory leak protection)
            const blob = new Blob([testCode], { type: 'text/plain' });
            let url = null;
            try {
                url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // Handle both G-code and 3MF filenames
                const originalFilename = is3MF 
                    ? file.name.replace(/\.[^.]*$/, "") 
                    : file.name.replace(/\.(gcode|gco|g|txt)$/i, "") || "test";
                // Test files are always G-code format (G-code is extracted from 3MF if needed)
                a.download = `${originalFilename}_test_pushoff_${modelHeight.toFixed(0)}mm.gcode`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } finally {
                if (url) {
                    URL.revokeObjectURL(url);
                }
            }

            showStatus("Test file generated successfully!", "success");
        } catch (error) {
            if (DEBUG_MODE) console.error("Error in generateTestFile:", error);
            alert("Error generating test file: " + error.message);
        }
    }
    
    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', function(e) {
        // Enter = Generate (if button is not disabled and not in input field)
        if (e.key === 'Enter' && 
            !(DOM.generateBtn || document.getElementById("generateBtn")).disabled &&
            e.target.tagName !== 'INPUT' && 
            e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            processFiles();
        }
        
        // Esc = Reset (if not in input field) or close instructions
        if (e.key === 'Escape') {
            if (document.getElementById('instructionsModal').classList.contains('active')) {
                closeInstructions();
            } else if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            resetDefaults();
            }
        }
    });

    /**
     * Opens the instructions modal
     */
    function openInstructions() {
        const modal = document.getElementById('instructionsModal');
        if (modal) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
    }

    /**
     * Closes the instructions modal
     */
    function closeInstructions() {
        const modal = document.getElementById('instructionsModal');
        if (modal) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    }

    /**
     * Closes instructions modal when clicking on backdrop
     */
    function closeInstructionsOnBackdrop(event) {
        if (event.target.id === 'instructionsModal') {
            closeInstructions();
        }
    }
</script>
</body>
</html>
